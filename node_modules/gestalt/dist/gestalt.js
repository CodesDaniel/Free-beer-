(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react-dom'), require('classnames'), require('react'), require('prop-types')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react-dom', 'classnames', 'react', 'prop-types'], factory) :
  (factory((global.gestalt = {}),global.ReactDOM,global.classnames,global.React,global.PropTypes));
}(this, (function (exports,reactDom,classnames,React,PropTypes) { 'use strict';

  classnames = classnames && classnames.hasOwnProperty('default') ? classnames['default'] : classnames;
  PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;

  var styles = { "box": "zI7 iyn Hsu", "xsDisplayNone": "ESm", "xsDisplayFlex": "Jea", "xsDisplayBlock": "oy8", "xsDisplayInlineBlock": "FNs", "xsDisplayVisuallyHidden": "NVN", "smDisplayNone": "_As", "smDisplayFlex": "d5Q", "smDisplayBlock": "BFv", "smDisplayInlineBlock": "_Jd", "smDisplayVisuallyHidden": "Afg", "mdDisplayNone": "TJs", "mdDisplayFlex": "i_c", "mdDisplayBlock": "PrF", "mdDisplayInlineBlock": "Frz", "mdDisplayVisuallyHidden": "MPk", "lgDisplayNone": "jZa", "lgDisplayFlex": "GDP", "lgDisplayBlock": "V1t", "lgDisplayInlineBlock": "yiw", "lgDisplayVisuallyHidden": "GOd", "xsDirectionRow": "hs0", "xsDirectionColumn": "jzS", "smDirectionRow": "ccF", "smDirectionColumn": "FDl", "mdDirectionRow": "T9f", "mdDirectionColumn": "hqI", "lgDirectionRow": "IR2", "lgDirectionColumn": "e8G", "xsCol0": "YPQ", "xsCol1": "d5S wA7", "xsCol2": "dSH sxy", "xsCol3": "Goa xEW", "xsCol4": "cz_ MRE", "xsCol5": "gPb tYG", "xsCol6": "GCs UHc", "xsCol7": "aoh ojd", "xsCol8": "wXu PX-", "xsCol9": "z-m Qfr", "xsCol10": "quJ vdP", "xsCol11": "Q35 kaP", "xsCol12": "xcv L4E", "smCol0": "NYp", "smCol1": "pMp Djc", "smCol2": "fut tar", "smCol3": "Jra QS3", "smCol4": "nUE V_L", "smCol5": "QM0 kh1", "smCol6": "eU_ Fue", "smCol7": "YhO cgB", "smCol8": "xPk DkM", "smCol9": "rDN AXh", "smCol10": "Pd1 UtM", "smCol11": "fC1 Wyy", "smCol12": "NUf dXC", "mdCol0": "_8v", "mdCol1": "tJY U8q", "mdCol2": "dok shx", "mdCol3": "HUu EGm", "mdCol4": "cXK XMp", "mdCol5": "ad9 H2Q", "mdCol6": "BD5 HHc", "mdCol7": "bi8 JWr", "mdCol8": "i_s h5B", "mdCol9": "gog Eeb", "mdCol10": "fEC TIo", "mdCol11": "M5b rPE", "mdCol12": "IRj QwK", "lgCol0": "_Hm", "lgCol1": "dTO VSa", "lgCol2": "NCg aml", "lgCol3": "z5O huk", "lgCol4": "n-N Vnj", "lgCol5": "M7z KgZ", "lgCol6": "P6z c2A", "lgCol7": "qTG IGd", "lgCol8": "rtP hMf", "lgCol9": "y22 swh", "lgCol10": "xQy Hs0", "lgCol11": "kM1 YXE", "lgCol12": "AiQ XTp" };

  var borderStyles = { "border": "KI_", "borderTop": "uNu", "borderRight": "w7l", "borderBottom": "vCE", "borderLeft": "mQC", "square": "gL3", "circle": "INd", "pill": "Lfz", "rounded": "mix", "roundedTop": "mO6", "radiusLarge": "_Vw", "radiusSmall": "jJP", "roundedRight": "t6-", "roundedBottom": "BqC", "roundedLeft": "ere", "noBorder": "adn" };

  var colors = { "red": "lZJ", "redBg": "Jrn", "white": "erh", "whiteBg": "qJc", "lightGray": "odN", "lightGrayBg": "gpV", "gray": "B9u", "grayBg": "gfP", "darkGray": "pBj", "darkGrayBg": "BsF", "green": "yXb", "greenBg": "VFV", "pine": "amR", "pineBg": "Pym", "olive": "mwW", "oliveBg": "b5Z", "blue": "mi-", "blueBg": "rTt", "navy": "xxo", "navyBg": "hz-", "midnight": "Ime", "midnightBg": "E14", "purple": "NL9", "purpleBg": "vfO", "orchid": "myR", "orchidBg": "f-y", "eggplant": "oKX", "eggplantBg": "bPM", "maroon": "ska", "maroonBg": "Z_T", "watermelon": "Wo3", "watermelonBg": "iRv", "orange": "GoP", "orangeBg": "Lgc", "transparentBg": "YbY", "transparentDarkGray": "wcy", "transparentDarkGrayBg": "prG", "lightWashBg": "eZS", "darkWashBg": "hle" };

  var layout = { "block": "kVc", "inline": "goI", "inlineBlock": "KhY", "table": "zsR", "overflowHidden": "sLG", "overflowScroll": "xqS", "overflowScrollX": "vVc", "overflowScrollY": "Cii", "overflowAuto": "XbT", "fit": "xuU", "relative": "XiG", "fixed": "_he", "absolute": "MIw", "sticky": "qiB", "top0": "QLY", "right0": "p6V", "bottom0": "ojN", "left0": "Rym", "small": "I56", "medium": "aZc", "large": "xD4", "borderBox": "Hsu", "contentBox": "jr-", "-webkit-box-flex": "_O1", "-webkit-flex": "_O1", "-ms-flex": "_O1", "flex": "_O1", "smFlex": "pRa", "mdFlex": "t6T", "lgFlex": "i0q", "flexColumn": "qT6", "flexWrap": "kzZ", "itemsStart": "Fje", "itemsEnd": "pP3", "itemsCenter": "gjz", "itemsBaseline": "Rnj", "itemsStretch": "wHp", "selfStart": "X0f", "selfEnd": "gRy", "selfCenter": "Z2K", "selfBaseline": "Op6", "selfStretch": "Zvs", "justifyStart": "rrK", "justifyEnd": "jx-", "justifyCenter": "mQ8", "justifyBetween": "b8T", "justifyAround": "Ah0", "contentStart": "yOS", "contentEnd": "hwG", "contentCenter": "TpD", "contentBetween": "bkI", "contentAround": "x9O", "contentStretch": "kBO", "flexGrow": "ujU", "flexNone": "Eqh", "orderFirst": "oTa", "orderLast": "nEN" };

  var whitespace = { "marginStart1": "xvE", "marginEnd1": "Rz6", "marginStartN1": "F6l", "marginEndN1": "k1A", "marginTop1": "hDW", "marginRight1": "Hb9", "marginBottom1": "X6t", "marginLeft1": "kMA", "marginTopN1": "XBe", "marginRightN1": "f03", "marginBottomN1": "Uex", "marginLeftN1": "uro", "paddingY1": "C9q", "paddingX1": "Shl", "marginStart2": "JME", "marginEnd2": "wc1", "marginStartN2": "wfr", "marginEndN2": "z4_", "marginTop2": "hjj", "marginRight2": "Gd1", "marginBottom2": "VxL", "marginLeft2": "n9m", "marginTopN2": "CP0", "marginRightN2": "d2j", "marginBottomN2": "Uxw", "marginLeftN2": "VDP", "paddingY2": "hA-", "paddingX2": "wYR", "marginStart3": "Pyg", "marginEnd3": "Umk", "marginStartN3": "eyO", "marginEndN3": "fmw", "marginTop3": "Hvp", "marginRight3": "ocu", "marginBottom3": "snW", "marginLeft3": "XTf", "marginTopN3": "ck1", "marginRightN3": "w-W", "marginBottomN3": "Kgo", "marginLeftN3": "QMJ", "paddingY3": "hUC", "paddingX3": "Zr3", "marginStart4": "rDA", "marginEnd4": "jar", "marginStartN4": "qaC", "marginEndN4": "vCT", "marginTop4": "KO4", "marginRight4": "lTs", "marginBottom4": "RDc", "marginLeft4": "L3z", "marginTopN4": "J95", "marginRightN4": "Qe1", "marginBottomN4": "hes", "marginLeftN4": "qwE", "paddingY4": "qDf", "paddingX4": "fZz", "marginStart5": "iD5", "marginEnd5": "wzk", "marginStartN5": "bvu", "marginEndN5": "XQa", "marginTop5": "MMr", "marginRight5": "R1w", "marginBottom5": "kKU", "marginLeft5": "vPt", "marginTopN5": "jYK", "marginRightN5": "kLV", "marginBottomN5": "Ahn", "marginLeftN5": "Hl7", "paddingY5": "Mhr", "paddingX5": "l7T", "marginStart6": "fte", "marginEnd6": "dxm", "marginStartN6": "Zgg", "marginEndN6": "CjC", "marginTop6": "Tte", "marginRight6": "I_w", "marginBottom6": "PKX", "marginLeft6": "fIf", "marginTopN6": "joO", "marginRightN6": "Kuo", "marginBottomN6": "I5z", "marginLeftN6": "UOL", "paddingY6": "fBv", "paddingX6": "QDA", "marginStart7": "WC-", "marginEnd7": "D4_", "marginStartN7": "Y7_", "marginEndN7": "l_x", "marginTop7": "JcM", "marginRight7": "yA9", "marginBottom7": "Y-G", "marginLeft7": "dax", "marginTopN7": "ROS", "marginRightN7": "Ifs", "marginBottomN7": "A44", "marginLeftN7": "r7P", "paddingY7": "kli", "paddingX7": "hvO", "marginStart8": "Vg5", "marginEnd8": "kTA", "marginStartN8": "n8t", "marginEndN8": "ddc", "marginTop8": "CDp", "marginRight8": "QrW", "marginBottom8": "m2F", "marginLeft8": "xBE", "marginTopN8": "t6x", "marginRightN8": "GzA", "marginBottomN8": "FBy", "marginLeftN8": "NGU", "paddingY8": "Lej", "paddingX8": "LCN", "marginStart9": "Roz", "marginEnd9": "Hgb", "marginStartN9": "Xke", "marginEndN9": "cUu", "marginTop9": "vks", "marginRight9": "y7W", "marginBottom9": "mDD", "marginLeft9": "jUv", "marginTopN9": "ZG2", "marginRightN9": "H15", "marginBottomN9": "jCP", "marginLeftN9": "sQU", "paddingY9": "SMG", "paddingX9": "kxF", "marginStart10": "Bdr", "marginEnd10": "UJS", "marginStartN10": "Ylh", "marginEndN10": "bNJ", "marginTop10": "WbA", "marginRight10": "VhO", "marginBottom10": "lAM", "marginLeft10": "VcB", "marginTopN10": "YFA", "marginRightN10": "JcX", "marginBottomN10": "jyq", "marginLeftN10": "r2E", "paddingY10": "ZDm", "paddingX10": "TwP", "marginStart11": "ziA", "marginEnd11": "IM6", "marginStartN11": "F94", "marginEndN11": "fIt", "marginTop11": "u3U", "marginRight11": "J1A", "marginBottom11": "K5L", "marginLeft11": "EVV", "marginTopN11": "eK4", "marginRightN11": "_ES", "marginBottomN11": "zkc", "marginLeftN11": "dQD", "paddingY11": "WGZ", "paddingX11": "wi3", "marginStart12": "_EQ", "marginEnd12": "JFk", "marginStartN12": "WL0", "marginEndN12": "KRR", "marginTop12": "uqM", "marginRight12": "jzb", "marginBottom12": "fma", "marginLeft12": "Tyx", "marginTopN12": "ltU", "marginRightN12": "ELl", "marginBottomN12": "SAt", "marginLeftN12": "T9E", "paddingY12": "_4T", "paddingX12": "oqv", "smMarginStart1": "Kv_", "smMarginEnd1": "yqk", "smMarginStartN1": "Ogs", "smMarginEndN1": "HgQ", "smMarginTop1": "qql", "smMarginRight1": "zVn", "smMarginBottom1": "zZt", "smMarginLeft1": "Y8f", "smMarginTopN1": "MNO", "smMarginRightN1": "QQl", "smMarginBottomN1": "nJV", "smMarginLeftN1": "PvB", "smPaddingY1": "Nzy", "smPaddingX1": "tuI", "smMarginStart2": "oKe", "smMarginEnd2": "L7H", "smMarginStartN2": "sLc", "smMarginEndN2": "MNH", "smMarginTop2": "THn", "smMarginRight2": "Q12", "smMarginBottom2": "PdC", "smMarginLeft2": "lNR", "smMarginTopN2": "NoR", "smMarginRightN2": "yS5", "smMarginBottomN2": "xUA", "smMarginLeftN2": "iHC", "smPaddingY2": "hCD", "smPaddingX2": "c-A", "smMarginStart3": "c92", "smMarginEnd3": "pcD", "smMarginStartN3": "y4M", "smMarginEndN3": "Wuh", "smMarginTop3": "bJD", "smMarginRight3": "k2h", "smMarginBottom3": "EVE", "smMarginLeft3": "Wa2", "smMarginTopN3": "_DO", "smMarginRightN3": "eQ1", "smMarginBottomN3": "aVq", "smMarginLeftN3": "H4N", "smPaddingY3": "ydS", "smPaddingX3": "H0r", "smMarginStart4": "J1r", "smMarginEnd4": "DRg", "smMarginStartN4": "oa0", "smMarginEndN4": "sOL", "smMarginTop4": "PB_", "smMarginRight4": "v_H", "smMarginBottom4": "SV2", "smMarginLeft4": "dRT", "smMarginTopN4": "vOi", "smMarginRightN4": "pxb", "smMarginBottomN4": "xwY", "smMarginLeftN4": "spp", "smPaddingY4": "dwY", "smPaddingX4": "_VW", "smMarginStart5": "WKc", "smMarginEnd5": "Mra", "smMarginStartN5": "W8s", "smMarginEndN5": "Ehr", "smMarginTop5": "lek", "smMarginRight5": "ypO", "smMarginBottom5": "idm", "smMarginLeft5": "oPi", "smMarginTopN5": "X3B", "smMarginRightN5": "FMa", "smMarginBottomN5": "P6b", "smMarginLeftN5": "HKo", "smPaddingY5": "whM", "smPaddingX5": "L-L", "smMarginStart6": "Uxg", "smMarginEnd6": "b9X", "smMarginStartN6": "nUU", "smMarginEndN6": "mac", "smMarginTop6": "Ovc", "smMarginRight6": "nRg", "smMarginBottom6": "DzC", "smMarginLeft6": "WjQ", "smMarginTopN6": "IL1", "smMarginRightN6": "c6f", "smMarginBottomN6": "P5p", "smMarginLeftN6": "cyd", "smPaddingY6": "gux", "smPaddingX6": "qaR", "smMarginStart7": "s_b", "smMarginEnd7": "K2I", "smMarginStartN7": "z9d", "smMarginEndN7": "Prp", "smMarginTop7": "J9t", "smMarginRight7": "yhK", "smMarginBottom7": "Ppv", "smMarginLeft7": "UpC", "smMarginTopN7": "mJQ", "smMarginRightN7": "S8O", "smMarginBottomN7": "uxh", "smMarginLeftN7": "OkY", "smPaddingY7": "O8I", "smPaddingX7": "wck", "smMarginStart8": "FUA", "smMarginEnd8": "pNn", "smMarginStartN8": "Qo5", "smMarginEndN8": "Arx", "smMarginTop8": "iqv", "smMarginRight8": "ka2", "smMarginBottom8": "E0F", "smMarginLeft8": "BrS", "smMarginTopN8": "kRT", "smMarginRightN8": "ME7", "smMarginBottomN8": "HmQ", "smMarginLeftN8": "t7R", "smPaddingY8": "Ger", "smPaddingX8": "ynl", "smMarginStart9": "u9O", "smMarginEnd9": "OTd", "smMarginStartN9": "pH8", "smMarginEndN9": "IsE", "smMarginTop9": "t5d", "smMarginRight9": "wUg", "smMarginBottom9": "y5U", "smMarginLeft9": "UNV", "smMarginTopN9": "uz6", "smMarginRightN9": "PxX", "smMarginBottomN9": "Wwk", "smMarginLeftN9": "y0P", "smPaddingY9": "_EA", "smPaddingX9": "tPb", "smMarginStart10": "vwP", "smMarginEnd10": "wdO", "smMarginStartN10": "Qi0", "smMarginEndN10": "SSs", "smMarginTop10": "ZE2", "smMarginRight10": "l-q", "smMarginBottom10": "RTY", "smMarginLeft10": "nLH", "smMarginTopN10": "FCI", "smMarginRightN10": "vGP", "smMarginBottomN10": "hpC", "smMarginLeftN10": "SlI", "smPaddingY10": "hsT", "smPaddingX10": "zbx", "smMarginStart11": "CoG", "smMarginEnd11": "jXh", "smMarginStartN11": "rwL", "smMarginEndN11": "jb_", "smMarginTop11": "i34", "smMarginRight11": "A7E", "smMarginBottom11": "ngz", "smMarginLeft11": "fwp", "smMarginTopN11": "e2v", "smMarginRightN11": "JU5", "smMarginBottomN11": "ZII", "smMarginLeftN11": "fYp", "smPaddingY11": "HV1", "smPaddingX11": "pKp", "smMarginStart12": "eCQ", "smMarginEnd12": "kbl", "smMarginStartN12": "gl9", "smMarginEndN12": "V9b", "smMarginTop12": "qXr", "smMarginRight12": "u03", "smMarginBottom12": "J0h", "smMarginLeft12": "EYn", "smMarginTopN12": "FvJ", "smMarginRightN12": "L4s", "smMarginBottomN12": "Vfb", "smMarginLeftN12": "dJ2", "smPaddingY12": "INL", "smPaddingX12": "Hmw", "mdMarginStart1": "dNW", "mdMarginEnd1": "X55", "mdMarginStartN1": "PRF", "mdMarginEndN1": "rrG", "mdMarginTop1": "Ctk", "mdMarginRight1": "gih", "mdMarginBottom1": "VpK", "mdMarginLeft1": "HvT", "mdMarginTopN1": "SP3", "mdMarginRightN1": "pk2", "mdMarginBottomN1": "nty", "mdMarginLeftN1": "EUw", "mdPaddingY1": "hYR", "mdPaddingX1": "Jbl", "mdMarginStart2": "l9y", "mdMarginEnd2": "n23", "mdMarginStartN2": "tiw", "mdMarginEndN2": "qxN", "mdMarginTop2": "zXr", "mdMarginRight2": "vFO", "mdMarginBottom2": "HSI", "mdMarginLeft2": "T3h", "mdMarginTopN2": "DbB", "mdMarginRightN2": "Yel", "mdMarginBottomN2": "lRW", "mdMarginLeftN2": "pDE", "mdPaddingY2": "QyJ", "mdPaddingX2": "zXR", "mdMarginStart3": "sbv", "mdMarginEnd3": "wQe", "mdMarginStartN3": "l7Q", "mdMarginEndN3": "dbu", "mdMarginTop3": "zf5", "mdMarginRight3": "HUO", "mdMarginBottom3": "Imv", "mdMarginLeft3": "Q0N", "mdMarginTopN3": "Ir5", "mdMarginRightN3": "_z0", "mdMarginBottomN3": "O5V", "mdMarginLeftN3": "GdN", "mdPaddingY3": "xTL", "mdPaddingX3": "xJA", "mdMarginStart4": "c96", "mdMarginEnd4": "rp5", "mdMarginStartN4": "Nyq", "mdMarginEndN4": "DrW", "mdMarginTop4": "usG", "mdMarginRight4": "XMf", "mdMarginBottom4": "YeC", "mdMarginLeft4": "VeN", "mdMarginTopN4": "WOm", "mdMarginRightN4": "hGE", "mdMarginBottomN4": "kRc", "mdMarginLeftN4": "f9N", "mdPaddingY4": "b8i", "mdPaddingX4": "dz0", "mdMarginStart5": "ngM", "mdMarginEnd5": "bho", "mdMarginStartN5": "Baz", "mdMarginEndN5": "hXs", "mdMarginTop5": "j0g", "mdMarginRight5": "eot", "mdMarginBottom5": "a38", "mdMarginLeft5": "smZ", "mdMarginTopN5": "kIo", "mdMarginRightN5": "FD4", "mdMarginBottomN5": "ZYa", "mdMarginLeftN5": "bYo", "mdPaddingY5": "xgw", "mdPaddingX5": "mEU", "mdMarginStart6": "bo4", "mdMarginEnd6": "zn2", "mdMarginStartN6": "utr", "mdMarginEndN6": "xeh", "mdMarginTop6": "bKb", "mdMarginRight6": "T9P", "mdMarginBottom6": "fXc", "mdMarginLeft6": "y_z", "mdMarginTopN6": "_zR", "mdMarginRightN6": "Vyo", "mdMarginBottomN6": "PDE", "mdMarginLeftN6": "vMx", "mdPaddingY6": "Iqj", "mdPaddingX6": "_X7", "mdMarginStart7": "aEO", "mdMarginEnd7": "dBK", "mdMarginStartN7": "RIN", "mdMarginEndN7": "aL4", "mdMarginTop7": "iP0", "mdMarginRight7": "zNZ", "mdMarginBottom7": "BFq", "mdMarginLeft7": "fDT", "mdMarginTopN7": "M5v", "mdMarginRightN7": "yjP", "mdMarginBottomN7": "dWF", "mdMarginLeftN7": "tDH", "mdPaddingY7": "JsH", "mdPaddingX7": "ld3", "mdMarginStart8": "Bfr", "mdMarginEnd8": "sVz", "mdMarginStartN8": "KnD", "mdMarginEndN8": "FnC", "mdMarginTop8": "rdA", "mdMarginRight8": "cty", "mdMarginBottom8": "XrP", "mdMarginLeft8": "hFm", "mdMarginTopN8": "zOu", "mdMarginRightN8": "Sqb", "mdMarginBottomN8": "fBQ", "mdMarginLeftN8": "wzL", "mdPaddingY8": "EKn", "mdPaddingX8": "JYy", "mdMarginStart9": "blI", "mdMarginEnd9": "egt", "mdMarginStartN9": "wWp", "mdMarginEndN9": "TVJ", "mdMarginTop9": "L4W", "mdMarginRight9": "Crl", "mdMarginBottom9": "SU5", "mdMarginLeft9": "RRQ", "mdMarginTopN9": "W2O", "mdMarginRightN9": "XJq", "mdMarginBottomN9": "Syd", "mdMarginLeftN9": "vtM", "mdPaddingY9": "K4G", "mdPaddingX9": "Hmo", "mdMarginStart10": "gA8", "mdMarginEnd10": "Q4Z", "mdMarginStartN10": "WRW", "mdMarginEndN10": "xK-", "mdMarginTop10": "PHK", "mdMarginRight10": "ay0", "mdMarginBottom10": "_jf", "mdMarginLeft10": "NWA", "mdMarginTopN10": "pdI", "mdMarginRightN10": "DSy", "mdMarginBottomN10": "zXD", "mdMarginLeftN10": "_GW", "mdPaddingY10": "Hhi", "mdPaddingX10": "FGl", "mdMarginStart11": "O3e", "mdMarginEnd11": "qZY", "mdMarginStartN11": "j88", "mdMarginEndN11": "fu-", "mdMarginTop11": "HP6", "mdMarginRight11": "wAY", "mdMarginBottom11": "sfp", "mdMarginLeft11": "yDF", "mdMarginTopN11": "htC", "mdMarginRightN11": "VqQ", "mdMarginBottomN11": "B1G", "mdMarginLeftN11": "Gno", "mdPaddingY11": "OiD", "mdPaddingX11": "gRN", "mdMarginStart12": "MYx", "mdMarginEnd12": "US2", "mdMarginStartN12": "JeA", "mdMarginEndN12": "h2s", "mdMarginTop12": "bHN", "mdMarginRight12": "qtC", "mdMarginBottom12": "r8B", "mdMarginLeft12": "Ujf", "mdMarginTopN12": "dm8", "mdMarginRightN12": "oue", "mdMarginBottomN12": "cCH", "mdMarginLeftN12": "g8h", "mdPaddingY12": "tfF", "mdPaddingX12": "lxJ", "lgMarginStart1": "GZc", "lgMarginEnd1": "ZWO", "lgMarginStartN1": "C4R", "lgMarginEndN1": "Mm6", "lgMarginTop1": "_7z", "lgMarginRight1": "Do-", "lgMarginBottom1": "mKZ", "lgMarginLeft1": "e2U", "lgMarginTopN1": "tWr", "lgMarginRightN1": "LUw", "lgMarginBottomN1": "rhe", "lgMarginLeftN1": "dTY", "lgPaddingY1": "NXQ", "lgPaddingX1": "UiP", "lgMarginStart2": "jW-", "lgMarginEnd2": "hHg", "lgMarginStartN2": "O6n", "lgMarginEndN2": "K3-", "lgMarginTop2": "q1b", "lgMarginRight2": "qp_", "lgMarginBottom2": "anz", "lgMarginLeft2": "r3b", "lgMarginTopN2": "UHw", "lgMarginRightN2": "nsb", "lgMarginBottomN2": "teB", "lgMarginLeftN2": "Q62", "lgPaddingY2": "Qwh", "lgPaddingX2": "azY", "lgMarginStart3": "bOM", "lgMarginEnd3": "NgB", "lgMarginStartN3": "InG", "lgMarginEndN3": "vJs", "lgMarginTop3": "FE_", "lgMarginRight3": "R_r", "lgMarginBottom3": "DbS", "lgMarginLeft3": "QGw", "lgMarginTopN3": "Rfg", "lgMarginRightN3": "Ic5", "lgMarginBottomN3": "QOZ", "lgMarginLeftN3": "KJa", "lgPaddingY3": "ftd", "lgPaddingX3": "MHw", "lgMarginStart4": "lUN", "lgMarginEnd4": "eCf", "lgMarginStartN4": "ajY", "lgMarginEndN4": "Ebi", "lgMarginTop4": "A9H", "lgMarginRight4": "UuS", "lgMarginBottom4": "ewa", "lgMarginLeft4": "qCE", "lgMarginTopN4": "J9s", "lgMarginRightN4": "ezp", "lgMarginBottomN4": "emj", "lgMarginLeftN4": "wQo", "lgPaddingY4": "c3l", "lgPaddingX4": "B4M", "lgMarginStart5": "XcK", "lgMarginEnd5": "fH2", "lgMarginStartN5": "Yve", "lgMarginEndN5": "pMc", "lgMarginTop5": "IOs", "lgMarginRight5": "ByX", "lgMarginBottom5": "XN6", "lgMarginLeft5": "YiL", "lgMarginTopN5": "Pqr", "lgMarginRightN5": "IvR", "lgMarginBottomN5": "Gjs", "lgMarginLeftN5": "yxs", "lgPaddingY5": "w8G", "lgPaddingX5": "Dkn", "lgMarginStart6": "SXU", "lgMarginEnd6": "Zwb", "lgMarginStartN6": "Duw", "lgMarginEndN6": "Hln", "lgMarginTop6": "tWt", "lgMarginRight6": "OV-", "lgMarginBottom6": "mgl", "lgMarginLeft6": "C59", "lgMarginTopN6": "eGv", "lgMarginRightN6": "ZL4", "lgMarginBottomN6": "_Y9", "lgMarginLeftN6": "z8s", "lgPaddingY6": "Kyn", "lgPaddingX6": "em2", "lgMarginStart7": "Gao", "lgMarginEnd7": "qRO", "lgMarginStartN7": "ya6", "lgMarginEndN7": "cER", "lgMarginTop7": "Ysn", "lgMarginRight7": "D9Y", "lgMarginBottom7": "O_7", "lgMarginLeft7": "CnO", "lgMarginTopN7": "iot", "lgMarginRightN7": "oX7", "lgMarginBottomN7": "H0V", "lgMarginLeftN7": "mcV", "lgPaddingY7": "RyI", "lgPaddingX7": "kPz", "lgMarginStart8": "AQe", "lgMarginEnd8": "lpW", "lgMarginStartN8": "URa", "lgMarginEndN8": "cYL", "lgMarginTop8": "dFw", "lgMarginRight8": "huN", "lgMarginBottom8": "dl4", "lgMarginLeft8": "ZDH", "lgMarginTopN8": "IvC", "lgMarginRightN8": "QvB", "lgMarginBottomN8": "TAW", "lgMarginLeftN8": "Ugj", "lgPaddingY8": "Zjh", "lgPaddingX8": "Xp9", "lgMarginStart9": "J4D", "lgMarginEnd9": "dlQ", "lgMarginStartN9": "vTn", "lgMarginEndN9": "zlU", "lgMarginTop9": "ito", "lgMarginRight9": "syD", "lgMarginBottom9": "zyU", "lgMarginLeft9": "fxs", "lgMarginTopN9": "Pt2", "lgMarginRightN9": "rwa", "lgMarginBottomN9": "Whv", "lgMarginLeftN9": "RRq", "lgPaddingY9": "ODF", "lgPaddingX9": "Bto", "lgMarginStart10": "AEu", "lgMarginEnd10": "_ss", "lgMarginStartN10": "N4A", "lgMarginEndN10": "XQe", "lgMarginTop10": "T9p", "lgMarginRight10": "gPV", "lgMarginBottom10": "W1m", "lgMarginLeft10": "HYB", "lgMarginTopN10": "OuJ", "lgMarginRightN10": "gRb", "lgMarginBottomN10": "_t9", "lgMarginLeftN10": "GxJ", "lgPaddingY10": "oqL", "lgPaddingX10": "adH", "lgMarginStart11": "f53", "lgMarginEnd11": "klb", "lgMarginStartN11": "AU2", "lgMarginEndN11": "FvD", "lgMarginTop11": "Iz0", "lgMarginRight11": "rOZ", "lgMarginBottom11": "JCh", "lgMarginLeft11": "ulG", "lgMarginTopN11": "MUh", "lgMarginRightN11": "uSX", "lgMarginBottomN11": "fwy", "lgMarginLeftN11": "t9b", "lgPaddingY11": "zK2", "lgPaddingX11": "HA4", "lgMarginStart12": "ofl", "lgMarginEnd12": "Mgh", "lgMarginStartN12": "Y3B", "lgMarginEndN12": "rjG", "lgMarginTop12": "V3k", "lgMarginRight12": "MdX", "lgMarginBottom12": "g9B", "lgMarginLeft12": "M-l", "lgMarginTopN12": "l29", "lgMarginRightN12": "onD", "lgMarginBottomN12": "zP_", "lgMarginLeftN12": "CVf", "lgPaddingY12": "C0G", "lgPaddingX12": "kLA" };

  var whitespaceLegacy = { "mlAuto": "E9n", "mrAuto": "MTm", "m0": "e43", "mt0": "o9W", "mr0": "hHC", "mb0": "QxV", "ml0": "o8a", "p0": "yQo", "px0": "CE_", "py0": "nK6", "m1": "hRJ", "mt1": "X_z", "mr1": "agz", "mb1": "v1V", "ml1": "Y6T", "mn1": "rRR", "mtn1": "one", "mbn1": "pS4", "mln1": "gt-", "mrn1": "jht", "mxn1": "LQ5", "myn1": "oM8", "p1": "YNp", "px1": "lKP", "py1": "KCB", "m2": "U4M", "mt2": "sEd", "mr2": "ZcW", "mb2": "ALO", "ml2": "Ivt", "mn2": "A-B", "mtn2": "kZj", "mbn2": "u6C", "mln2": "BRM", "mrn2": "XWl", "mxn2": "cJd", "myn2": "TGm", "p2": "Lvf", "px2": "nBD", "py2": "D5V", "m3": "ZTZ", "mt3": "g_k", "mr3": "pXb", "mb3": "mAj", "ml3": "Ml1", "mn3": "FON", "mtn3": "OL_", "mbn3": "MCM", "mln3": "Flj", "mrn3": "u8X", "mxn3": "d8y", "myn3": "HhC", "p3": "ylW", "px3": "yW5", "py3": "wY2", "m4": "dFj", "mt4": "n_4", "mr4": "Q93", "mb4": "bmY", "ml4": "xPp", "mn4": "md-", "mtn4": "T71", "mbn4": "JPJ", "mln4": "fDd", "mrn4": "xdD", "mxn4": "xYi", "myn4": "xic", "p4": "jj9", "px4": "BaR", "py4": "CFG", "m5": "jvk", "mt5": "MUb", "mr5": "HTL", "mb5": "R4-", "ml5": "QRr", "mn5": "X7W", "mtn5": "zD-", "mbn5": "gWO", "mln5": "QRS", "mrn5": "aCZ", "mxn5": "hYu", "myn5": "CMh", "p5": "frk", "px5": "r8R", "py5": "U3u", "m6": "ZbA", "mt6": "err", "mr6": "DbP", "mb6": "DF3", "ml6": "NR0", "mn6": "UDJ", "mtn6": "DV3", "mbn6": "Bm3", "mln6": "bKJ", "mrn6": "Rcd", "mxn6": "Zzj", "myn6": "Wk_", "p6": "L0y", "px6": "lAO", "py6": "bhh" };

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var objectWithoutProperties = function (obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  /*

  Style is a monoid that capture the "to-be-applied" styles (inline and classes)
  for a Box. It's basically set that is closed under an associative binary
  operation and has an identity element such that for all HA HA HA. Yes, it's a
  monoid, which sounds scary but it's not really and actually super useful. All
  that means is that basically you can do two things with it:

      1. concat(concat(a, b), c) === concat(a, concat(b, c));
      2. concat(identity(), a) === concat(a, identity()) === a;

  What that means is that it's really easy to compose styles together and the
  order in which you do so doesn't really matter.

  */

  var identity = function identity() {
    return {
      className: new Set(),
      inlineStyle: {}
    };
  };

  // TODO: This type should be opaque, however the Babel parser doesn't support
  //       the opaque syntax yet.


  var fromClassName = function fromClassName() {
    for (var _len = arguments.length, classNames = Array(_len), _key = 0; _key < _len; _key++) {
      classNames[_key] = arguments[_key];
    }

    return {
      className: new Set(classNames),
      inlineStyle: {}
    };
  };

  var fromInlineStyle = function fromInlineStyle(inlineStyle) {
    return {
      className: new Set(),
      inlineStyle: inlineStyle
    };
  };

  var concat = function concat(styles) {
    return styles.reduce(function (_ref, _ref2) {
      var classNameA = _ref.className,
          inlineStyleA = _ref.inlineStyle;
      var classNameB = _ref2.className,
          inlineStyleB = _ref2.inlineStyle;
      return {
        className: new Set([].concat(toConsumableArray(classNameA), toConsumableArray(classNameB))),
        inlineStyle: _extends({}, inlineStyleA, inlineStyleB)
      };
    }, identity());
  };

  var mapClassName = function mapClassName(fn) {
    return function (_ref3) {
      var className = _ref3.className,
          inlineStyle = _ref3.inlineStyle;
      return {
        className: new Set(Array.from(className).map(fn)),
        inlineStyle: inlineStyle
      };
    };
  };

  var toProps = function toProps(_ref4) {
    var className = _ref4.className,
        inlineStyle = _ref4.inlineStyle;

    var props = {};

    if (className.size > 0) {
      // Sorting here ensures that classNames are always stable, reducing diff
      // churn. Box usually has a small number of properties so it's not a perf
      // concern.
      props.className = Array.from(className).sort().join(' ');
    }

    if (Object.keys(inlineStyle).length > 0) {
      props.style = inlineStyle;
    }

    return props;
  };

  /*

  Transforms

  These are a collection of a few functors that take values and returns Style's. OMG, I used the word functor - it's really just a fancy word for function.

  */

  // Adds a classname when a property is present.
  //
  //     <Box top />
  //
  var toggle = function toggle() {
    for (var _len = arguments.length, classNames = Array(_len), _key = 0; _key < _len; _key++) {
      classNames[_key] = arguments[_key];
    }

    return function (val) {
      return val ? fromClassName.apply(undefined, classNames) : identity();
    };
  };

  // Maps string values to classes
  //
  //     <Box alignItems="center" />
  //
  var mapping = function mapping(map) {
    return function (val) {
      return Object.prototype.hasOwnProperty.call(map, val) ? fromClassName(map[val]) : identity();
    };
  };

  // Maps a range of integers to a range of classnames
  //
  //     <Box padding={1} />
  //
  var range = function range(scale) {
    return function (n) {
      return fromClassName('' + scale + (n < 0 ? 'N' + Math.abs(n) : n));
    };
  };

  // Like `range`, maps a range of integers to a range of classnames, excluding
  // zero values.
  //
  //     <Box padding={0} />
  var rangeWithoutZero = function rangeWithoutZero(scale) {
    return function (n) {
      return n === 0 ? identity() : range(scale)(n);
    };
  };

  // Binds a string classname to the value in an object. Useful when interacting
  // with ranges that need to come dynamically from a style object. This is
  // similar to the NPM package 'classnames/bind'.
  var bind = function bind(fn, scope) {
    return function (val) {
      return mapClassName(function (name) {
        return scope[name];
      })(fn(val));
    };
  };

  // This takes a series of the previously defined functors, runs them all
  // against a value and returns the set of their classnames.
  var union = function union() {
    for (var _len2 = arguments.length, fns = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      fns[_key2] = arguments[_key2];
    }

    return function (val) {
      return concat(fns.map(function (fn) {
        return fn(val);
      }));
    };
  };

  /*

  # ProTypes

  Box's type definition is exhaustive. With the exception of `dangerouslySetInlineStyle`, values shouldn't be ambigious. That means that we have to type out things like boints, but that's also where Box's magic lies. Also, by putting in extra effort around type definitions here, we can skip extra runtime typechecks in the transformers for performance.

  */

  // --

  /*

  # Transformers

  This is where the meat and the bones of Box's transforms are. You can read more about the DSL in `./transforms.js`, but basically they are a small declarative way of specifying how a property (i.e. `marginTop={4}`) gets turned into a CSS class (`marginTop4`).

  There's a little preamble here, but it culminates in a big object mapping the actual property names to the transformer values.

  */

  var marginStart = bind(rangeWithoutZero('marginStart'), whitespace);
  var marginEnd = bind(rangeWithoutZero('marginEnd'), whitespace);
  var marginTop = bind(rangeWithoutZero('marginTop'), whitespace);
  var marginRight = bind(rangeWithoutZero('marginRight'), whitespace);
  var marginBottom = bind(rangeWithoutZero('marginBottom'), whitespace);
  var marginLeft = bind(rangeWithoutZero('marginLeft'), whitespace);
  var margin = union(marginTop, marginBottom, marginLeft, marginRight);

  var smMarginTop = bind(rangeWithoutZero('smMarginTop'), whitespace);
  var smMarginRight = bind(rangeWithoutZero('smMarginRight'), whitespace);
  var smMarginBottom = bind(rangeWithoutZero('smMarginBottom'), whitespace);
  var smMarginLeft = bind(rangeWithoutZero('smMarginLeft'), whitespace);
  var smMargin = union(smMarginTop, smMarginBottom, smMarginLeft, smMarginRight);

  var mdMarginTop = bind(rangeWithoutZero('mdMarginTop'), whitespace);
  var mdMarginRight = bind(rangeWithoutZero('mdMarginRight'), whitespace);
  var mdMarginBottom = bind(rangeWithoutZero('mdMarginBottom'), whitespace);
  var mdMarginLeft = bind(rangeWithoutZero('mdMarginLeft'), whitespace);
  var mdMargin = union(mdMarginTop, mdMarginBottom, mdMarginLeft, mdMarginRight);

  var lgMarginTop = bind(rangeWithoutZero('lgMarginTop'), whitespace);
  var lgMarginRight = bind(rangeWithoutZero('lgMarginRight'), whitespace);
  var lgMarginBottom = bind(rangeWithoutZero('lgMarginBottom'), whitespace);
  var lgMarginLeft = bind(rangeWithoutZero('lgMarginLeft'), whitespace);
  var lgMargin = union(lgMarginTop, lgMarginBottom, lgMarginLeft, lgMarginRight);

  var paddingX = bind(rangeWithoutZero('paddingX'), whitespace);
  var paddingY = bind(rangeWithoutZero('paddingY'), whitespace);
  var padding = union(paddingX, paddingY);

  var smPaddingX = bind(rangeWithoutZero('smPaddingX'), whitespace);
  var smPaddingY = bind(rangeWithoutZero('smPaddingY'), whitespace);
  var smPadding = union(smPaddingX, smPaddingY);

  var mdPaddingX = bind(rangeWithoutZero('mdPaddingX'), whitespace);
  var mdPaddingY = bind(rangeWithoutZero('mdPaddingY'), whitespace);
  var mdPadding = union(mdPaddingX, mdPaddingY);

  var lgPaddingX = bind(rangeWithoutZero('lgPaddingX'), whitespace);
  var lgPaddingY = bind(rangeWithoutZero('lgPaddingY'), whitespace);
  var lgPadding = union(lgPaddingX, lgPaddingY);

  /*

  These functions are legacy. I'd like to get rid of most of this file's dependency on importing `./style.js` directly once these are removed.

  */

  var prefix = function prefix(pre) {
    return mapClassName(function (name) {
      return '' + pre + name;
    });
  };
  var display = function display(value) {
    switch (value) {
      case 'flex':
        return fromClassName('DisplayFlex', 'DirectionRow');
      case 'flexColumn':
        return fromClassName('DisplayFlex', 'DirectionColumn');
      case 'inlineBlock':
        return fromClassName('DisplayInlineBlock');
      case 'visuallyHidden':
        return fromClassName('DisplayVisuallyHidden');
      case false:
        return fromClassName('DisplayNone');
      default:
        /* block */
        return fromClassName('DisplayBlock');
    }
  };
  var column = range('Col');

  var formatIntBoint = function formatIntBoint(x) {
    return x < 0 ? 'n' + Math.abs(x) : x.toString();
  };

  /*

  It's preferable to put new properties into that object directly just so it's easier to read.

  */

  var propToFn = {
    xs: function xs(value) {
      if (!value) {
        return identity();
      }
      return mapClassName(function (c) {
        return styles[c];
      })(prefix('xs')(concat([value.column ? column(value.column) : identity(), typeof value.display !== 'undefined' ? display(value.display) : identity()])));
    },
    sm: function sm(value) {
      if (!value) {
        return identity();
      }
      return mapClassName(function (c) {
        return styles[c];
      })(prefix('sm')(concat([value.column ? column(value.column) : identity(), typeof value.display !== 'undefined' ? display(value.display) : identity()])));
    },
    md: function md(value) {
      if (!value) {
        return identity();
      }
      return mapClassName(function (c) {
        return styles[c];
      })(prefix('md')(concat([value.column ? column(value.column) : identity(), typeof value.display !== 'undefined' ? display(value.display) : identity()])));
    },
    lg: function lg(value) {
      if (!value) {
        return identity();
      }
      return mapClassName(function (c) {
        return styles[c];
      })(prefix('lg')(concat([value.column ? column(value.column) : identity(), typeof value.display !== 'undefined' ? display(value.display) : identity()])));
    },

    display: mapping({
      none: styles.xsDisplayNone,
      flex: styles.xsDisplayFlex,
      block: styles.xsDisplayBlock,
      inlineBlock: styles.xsDisplayInlineBlock,
      visuallyHidden: styles.xsDisplayVisuallyHidden
    }),
    column: bind(range('xsCol'), styles),
    direction: mapping({
      row: styles.xsDirectionRow,
      column: styles.xsDirectionColumn
    }),

    smDisplay: mapping({
      none: styles.smDisplayNone,
      flex: styles.smDisplayFlex,
      block: styles.smDisplayBlock,
      inlineBlock: styles.smDisplayInlineBlock,
      visuallyHidden: styles.smDisplayVisuallyHidden
    }),
    smColumn: bind(range('smCol'), styles),
    smDirection: mapping({
      row: styles.smDirectionRow,
      column: styles.smDirectionColumn
    }),

    mdDisplay: mapping({
      none: styles.mdDisplayNone,
      flex: styles.mdDisplayFlex,
      block: styles.mdDisplayBlock,
      inlineBlock: styles.mdDisplayInlineBlock,
      visuallyHidden: styles.mdDisplayVisuallyHidden
    }),
    mdColumn: bind(range('mdCol'), styles),
    mdDirection: mapping({
      row: styles.mdDirectionRow,
      column: styles.mdDirectionColumn
    }),

    lgDisplay: mapping({
      none: styles.lgDisplayNone,
      flex: styles.lgDisplayFlex,
      block: styles.lgDisplayBlock,
      inlineBlock: styles.lgDisplayInlineBlock,
      visuallyHidden: styles.lgDisplayVisuallyHidden
    }),
    lgColumn: bind(range('lgCol'), styles),
    lgDirection: mapping({
      row: styles.lgDirectionRow,
      column: styles.lgDirectionColumn
    }),

    alignContent: mapping({
      start: layout.contentStart,
      end: layout.contentEnd,
      center: layout.contentCenter,
      between: layout.contentBetween,
      around: layout.contentAround
      // default: stretch
    }),
    alignItems: mapping({
      start: layout.itemsStart,
      end: layout.itemsEnd,
      center: layout.itemsCenter,
      baseline: layout.itemsBaseline
      // default: stretch
    }),
    alignSelf: mapping({
      start: layout.selfStart,
      end: layout.selfEnd,
      center: layout.selfCenter,
      baseline: layout.selfBaseline,
      stretch: layout.selfStretch
      // default: auto
    }),
    bottom: toggle(layout.bottom0),
    color: mapping({
      blue: colors.blueBg,
      darkGray: colors.darkGrayBg,
      pine: colors.pineBg,
      gray: colors.grayBg,
      red: colors.redBg,
      olive: colors.oliveBg,
      lightGray: colors.lightGrayBg,
      white: colors.whiteBg,
      orange: colors.orangeBg,
      green: colors.greenBg,
      navy: colors.navyBg,
      midnight: colors.midnightBg,
      purple: colors.purpleBg,
      orchid: colors.orchidBg,
      eggplant: colors.eggplantBg,
      maroon: colors.maroonBg,
      watermelon: colors.watermelonBg,
      lightWash: colors.lightWashBg,
      darkWash: colors.darkWashBg,
      transparentDarkGray: colors.transparentDarkGrayBg
      // default: transparent
    }),
    fit: toggle(layout.fit),
    flex: mapping({
      grow: layout.flexGrow,
      none: layout.flexNone
      // default: shrink
    }),
    height: function (_height) {
      function height(_x) {
        return _height.apply(this, arguments);
      }

      height.toString = function () {
        return _height.toString();
      };

      return height;
    }(function (height) {
      return fromInlineStyle({ height: height });
    }),
    justifyContent: mapping({
      end: layout.justifyEnd,
      center: layout.justifyCenter,
      between: layout.justifyBetween,
      around: layout.justifyAround
      // default: start
    }),
    left: toggle(layout.left0),
    deprecatedMargin: function deprecatedMargin(value) {
      var mt = identity();
      var mb = identity();
      var ml = identity();
      var mr = identity();
      switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
        case 'number':
          return fromClassName(whitespaceLegacy['m' + formatIntBoint(value)]);
        case 'object':
          if (value.top) {
            mt = fromClassName(whitespaceLegacy['mt' + formatIntBoint(value.top)]);
          }

          if (value.bottom) {
            mb = fromClassName(whitespaceLegacy['mb' + formatIntBoint(value.bottom)]);
          }

          if (value.left) {
            ml = fromClassName(value.left === 'auto' ? whitespaceLegacy.mlAuto : whitespaceLegacy['ml' + formatIntBoint(value.left)]);
          }

          if (value.right) {
            mr = fromClassName(value.right === 'auto' ? whitespaceLegacy.mrAuto : whitespaceLegacy['mr' + formatIntBoint(value.right)]);
          }
          return concat([mt, mb, ml, mr]);
        default:
          return identity();
      }
    },
    marginStart: marginStart,
    marginEnd: marginEnd,
    margin: margin,
    marginTop: marginTop,
    marginRight: marginRight,
    marginBottom: marginBottom,
    marginLeft: marginLeft,
    smMargin: smMargin,
    smMarginTop: smMarginTop,
    smMarginRight: smMarginRight,
    smMarginBottom: smMarginBottom,
    smMarginLeft: smMarginLeft,
    mdMargin: mdMargin,
    mdMarginTop: mdMarginTop,
    mdMarginRight: mdMarginRight,
    mdMarginBottom: mdMarginBottom,
    mdMarginLeft: mdMarginLeft,
    lgMargin: lgMargin,
    lgMarginTop: lgMarginTop,
    lgMarginRight: lgMarginRight,
    lgMarginBottom: lgMarginBottom,
    lgMarginLeft: lgMarginLeft,
    maxHeight: function (_maxHeight) {
      function maxHeight(_x2) {
        return _maxHeight.apply(this, arguments);
      }

      maxHeight.toString = function () {
        return _maxHeight.toString();
      };

      return maxHeight;
    }(function (maxHeight) {
      return fromInlineStyle({ maxHeight: maxHeight });
    }),
    maxWidth: function (_maxWidth) {
      function maxWidth(_x3) {
        return _maxWidth.apply(this, arguments);
      }

      maxWidth.toString = function () {
        return _maxWidth.toString();
      };

      return maxWidth;
    }(function (maxWidth) {
      return fromInlineStyle({ maxWidth: maxWidth });
    }),
    minHeight: function (_minHeight) {
      function minHeight(_x4) {
        return _minHeight.apply(this, arguments);
      }

      minHeight.toString = function () {
        return _minHeight.toString();
      };

      return minHeight;
    }(function (minHeight) {
      return fromInlineStyle({ minHeight: minHeight });
    }),
    minWidth: function (_minWidth) {
      function minWidth(_x5) {
        return _minWidth.apply(this, arguments);
      }

      minWidth.toString = function () {
        return _minWidth.toString();
      };

      return minWidth;
    }(function (minWidth) {
      return fromInlineStyle({ minWidth: minWidth });
    }),
    overflow: mapping({
      hidden: layout.overflowHidden,
      scroll: layout.overflowScroll,
      auto: layout.overflowAuto,
      scrollX: layout.overflowScrollX,
      scrollY: layout.overflowScrollY
      // default: visible
    }),
    deprecatedPadding: function deprecatedPadding(value) {
      switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
        case 'number':
          return fromClassName(whitespaceLegacy['p' + value]);
        case 'object':
          return concat([value.x ? fromClassName(whitespaceLegacy['px' + value.x]) : identity(), value.y ? fromClassName(whitespaceLegacy['py' + value.y]) : identity()]);
        default:
          return identity();
      }
    },
    padding: padding,
    paddingX: paddingX,
    paddingY: paddingY,
    smPadding: smPadding,
    smPaddingX: smPaddingX,
    smPaddingY: smPaddingY,
    mdPadding: mdPadding,
    mdPaddingX: mdPaddingX,
    mdPaddingY: mdPaddingY,
    lgPadding: lgPadding,
    lgPaddingX: lgPaddingX,
    lgPaddingY: lgPaddingY,
    position: mapping({
      absolute: layout.absolute,
      relative: layout.relative,
      fixed: layout.fixed
      // default: static
    }),
    right: toggle(layout.right0),
    shape: mapping({
      circle: borderStyles.circle,
      pill: borderStyles.pill,
      rounded: borderStyles.rounded,
      roundedBottom: borderStyles.roundedBottom,
      roundedLeft: borderStyles.roundedLeft,
      roundedRight: borderStyles.roundedRight,
      roundedTop: borderStyles.roundedTop
      // default: square
    }),
    top: toggle(layout.top0),
    width: function (_width) {
      function width(_x6) {
        return _width.apply(this, arguments);
      }

      width.toString = function () {
        return _width.toString();
      };

      return width;
    }(function (width) {
      return fromInlineStyle({ width: width });
    }),
    wrap: toggle(layout.flexWrap),
    dangerouslySetInlineStyle: function dangerouslySetInlineStyle(value) {
      return (
        /* eslint-disable-next-line no-underscore-dangle */
        value && value.__style ? fromInlineStyle(value.__style) : identity()
      );
    }
  };

  /*

  # The Component

  */

  var contains = function contains(key, arr) {
    return arr.indexOf(key) >= 0;
  };
  var omit = function omit(keys, obj) {
    return Object.keys(obj).reduce(function (acc, k) {
      if (contains(k, keys)) {
        return acc;
      }
      return _extends({}, acc, defineProperty({}, k, obj[k]));
    }, {});
  };

  // $FlowIssue https://github.com/facebook/flow/issues/6103
  var Box = React.forwardRef(function (_ref, ref) {
    var children = _ref.children,
        props = objectWithoutProperties(_ref, ['children']);

    // Flow can't reason about the constant nature of Object.keys so we can't use
    // a functional (reduce) style here.

    // Box is a "pass-through" component, meaning that if you pass properties to
    // it that it doesn't know about (`aria-label` for instance) it passes
    // directly back to the underlying `<div/>`. That's generally useful, but
    // we'd also like to strip out a few naughty properties that break style
    // encapsulation (className, style) or accessibility (onClick).
    var blacklist = ['onClick', 'className', 'style'];

    // All Box's are box-sized by default, so we start off building up the styles
    // to be applied with a Box base class.
    var s = fromClassName(styles.box);

    // This loops through each property and if it exists in the previously
    // defined transform map, concatentes the resulting styles to the base
    // styles. If there's a match, we also don't pass through that property. This
    // means Box's runtime is only dependent on the number of properties passed
    // to it (which is typically small) instead of the total number of possible
    // properties (~30 or so). While it may ~feel~ like Box is innefficient, its
    // biggest performance impact is on startup time because there's so much code
    // here.

    // eslint-disable-next-line no-restricted-syntax
    for (var prop in props) {
      if (Object.prototype.hasOwnProperty.call(propToFn, prop)) {
        var fn = propToFn[prop];
        var value = props[prop];
        blacklist = blacklist.concat(prop);
        s = concat([s, fn(value)]);
      }
    }

    // And... magic!
    return React.createElement(
      'div',
      _extends({}, omit(blacklist, props), toProps(s), { ref: ref }),
      children
    );
  });

  //  NOTE: This is needed in order to override the ForwardRef display name that is
  //  used in dev tools and in snapshot testing.
  Box.displayName = 'Box';

  /*

  # PropTypes

  And we're done here :)

  */

  var ColumnPropType = PropTypes.oneOf([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);

  var MarginPropType = PropTypes.oneOf([-12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);

  var PaddingPropType = PropTypes.oneOf([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);

  // $FlowIssue https://github.com/facebook/flow/issues/7484
  Box.propTypes = {
    children: PropTypes.node,
    dangerouslySetInlineStyle: PropTypes.exact({
      __style: PropTypes.object
    }),

    xs: PropTypes.exact({
      display: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['flex', 'flexColumn', 'inlineBlock'])]),
      column: PropTypes.number
    }),
    sm: PropTypes.exact({
      display: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['flex', 'flexColumn', 'inlineBlock'])]),
      column: PropTypes.number
    }),
    md: PropTypes.exact({
      display: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['flex', 'flexColumn', 'inlineBlock'])]),
      column: PropTypes.number
    }),
    lg: PropTypes.exact({
      display: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['flex', 'flexColumn', 'inlineBlock'])]),
      column: PropTypes.number
    }),
    deprecatedMargin: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
      top: PropTypes.number,
      bottom: PropTypes.number,
      left: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['auto'])]),
      right: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['auto'])])
    })]),
    deprecatedPadding: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
      x: PropTypes.number,
      y: PropTypes.number
    })]),

    display: PropTypes.oneOf(['none', 'flex', 'block', 'inlineBlock', 'visuallyHidden']),
    direction: PropTypes.oneOf(['row', 'column']),
    column: ColumnPropType,

    smDisplay: PropTypes.oneOf(['none', 'flex', 'block', 'inlineBlock', 'visuallyHidden']),
    smDirection: PropTypes.oneOf(['row', 'column']),
    smColumn: ColumnPropType,

    mdDisplay: PropTypes.oneOf(['none', 'flex', 'block', 'inlineBlock', 'visuallyHidden']),
    mdDirection: PropTypes.oneOf(['row', 'column']),
    mdColumn: ColumnPropType,

    lgDisplay: PropTypes.oneOf(['none', 'flex', 'block', 'inlineBlock', 'visuallyHidden']),
    lgDirection: PropTypes.oneOf(['row', 'column']),
    lgColumn: ColumnPropType,

    alignContent: PropTypes.oneOf(['start', 'end', 'center', 'between', 'around', 'stretch']),
    alignItems: PropTypes.oneOf(['start', 'end', 'center', 'baseline', 'stretch']),
    alignSelf: PropTypes.oneOf(['auto', 'start', 'end', 'center', 'baseline', 'stretch']),
    bottom: PropTypes.bool,
    color: PropTypes.oneOf(['blue', 'darkGray', 'darkWash', 'eggplant', 'gray', 'green', 'lightGray', 'lightWash', 'maroon', 'midnight', 'navy', 'olive', 'orange', 'orchid', 'pine', 'purple', 'red', 'transparent', 'transparentDarkGray', 'watermelon', 'white']),
    fit: PropTypes.bool,
    flex: PropTypes.oneOf(['grow', 'shrink', 'none']),
    grow: PropTypes.bool,
    height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    justifyContent: PropTypes.oneOf(['start', 'end', 'center', 'between', 'around']),
    left: PropTypes.bool,

    marginStart: MarginPropType,
    marginEnd: MarginPropType,

    margin: MarginPropType,
    marginTop: MarginPropType,
    marginRight: MarginPropType,
    marginBottom: MarginPropType,
    marginLeft: MarginPropType,

    smMargin: MarginPropType,
    smMarginTop: MarginPropType,
    smMarginRight: MarginPropType,
    smMarginBottom: MarginPropType,
    smMarginLeft: MarginPropType,

    mdMargin: MarginPropType,
    mdMarginTop: MarginPropType,
    mdMarginRight: MarginPropType,
    mdMarginBottom: MarginPropType,
    mdMarginLeft: MarginPropType,

    lgMargin: MarginPropType,
    lgMarginTop: MarginPropType,
    lgMarginRight: MarginPropType,
    lgMarginBottom: MarginPropType,
    lgMarginLeft: MarginPropType,

    maxHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    maxWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    minHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    minWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    overflow: PropTypes.oneOf(['visible', 'hidden', 'scroll', 'scrollX', 'scrollY', 'auto']),

    padding: PaddingPropType,
    paddingX: PaddingPropType,
    paddingY: PaddingPropType,

    smPadding: PaddingPropType,
    smPaddingX: PaddingPropType,
    smPaddingY: PaddingPropType,

    mdPadding: PaddingPropType,
    mdPaddingX: PaddingPropType,
    mdPaddingY: PaddingPropType,

    lgPadding: PaddingPropType,
    lgPaddingX: PaddingPropType,
    lgPaddingY: PaddingPropType,

    position: PropTypes.oneOf(['static', 'absolute', 'relative', 'fixed']),
    right: PropTypes.bool,
    shape: PropTypes.oneOf(['square', 'rounded', 'pill', 'circle', 'roundedTop', 'roundedBottom', 'roundedLeft', 'roundedRight']),
    top: PropTypes.bool,
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    wrap: PropTypes.bool
  };

  var styles$1 = { "icon": "gUZ", "iconBlock": "U9O kVc" };

  var add = 'M22 10h-8V2a2 2 0 0 0-4 0v8H2a2 2 0 0 0 0 4h8v8a2 2 0 0 0 4 0v-8h8a2 2 0 0 0 0-4';

  var addCircle = 'M17.75 13.25h-4.5v4.5a1.25 1.25 0 0 1-2.5 0v-4.5h-4.5a1.25 1.25 0 0 1 0-2.5h4.5v-4.5a1.25 1.25 0 0 1 2.5 0v4.5h4.5a1.25 1.25 0 0 1 0 2.5M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

  var addPin = 'M21.5 8.69c1.49.87 2.5 2.46 2.5 4.31h-4v7.96L19 23l-1-2.04V13h-4c0-1.85 1.01-3.44 2.5-4.31V2.93c-.86-.22-1.5-1-1.5-1.93h8c0 .93-.64 1.71-1.5 1.93v5.76zm-11.25.81a1.25 1.25 0 0 1 0 2.5H7v3.25a1.25 1.25 0 0 1-2.5 0V12H1.25a1.25 1.25 0 0 1 0-2.5H4.5V6.25a1.25 1.25 0 0 1 2.5 0V9.5h3.25z';

  var alert = 'M14.177 7.819l-1.698 5.824c-.142.476-.816.475-.958-.001L9.822 7.819h.009a2.227 2.227 0 0 1-.081-.569 2.25 2.25 0 1 1 4.5 0c0 .198-.034.386-.082.569h.009zM12 19a1.75 1.75 0 1 1 0-3.5 1.75 1.75 0 0 1 0 3.5zm0-19C5.372 0 0 5.372 0 12c0 6.627 5.372 12 12 12 6.627 0 12-5.373 12-12 0-6.628-5.373-12-12-12z';

  var alignBottomCenter = 'M20.5 19.75c0 .413-.337.75-.75.75H15.5V14h-7v6.5H4.25a.752.752 0 0 1-.75-.75V4.25a.75.75 0 0 1 .75-.75h15.5a.75.75 0 0 1 .75.75v15.5zM19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1z';

  var alignBottomLeft = 'M20.5 19.75c0 .413-.337.75-.75.75H10V14H3.5V4.25a.75.75 0 0 1 .75-.75h15.5a.75.75 0 0 1 .75.75v15.5zM19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1z';

  var alignBottomRight = 'M3.5 19.75V4.25a.75.75 0 0 1 .75-.75h15.5a.75.75 0 0 1 .75.75V14H14v6.5H4.25a.752.752 0 0 1-.75-.75M19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1';

  var alignBottom = 'M4.25 3.5h15.5a.75.75 0 0 1 .75.75V14h-17V4.25a.75.75 0 0 1 .75-.75M19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1';

  var alignMiddle = 'M19.75 20.5H4.25a.75.75 0 0 1-.75-.75V15.5h17v4.25a.75.75 0 0 1-.75.75m-15.5-17h15.5a.75.75 0 0 1 .75.75V8.5h-17V4.25a.75.75 0 0 1 .75-.75M19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1';

  var alignTopCenter = 'M20.5 19.75a.75.75 0 0 1-.75.75H4.25a.75.75 0 0 1-.75-.75V4.25a.75.75 0 0 1 .75-.75H8.5V10h7V3.5h4.25a.75.75 0 0 1 .75.75v15.5zM19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1z';

  var alignTopLeft = 'M20.5 19.75a.75.75 0 0 1-.75.75H4.25a.75.75 0 0 1-.75-.75V10H10V3.5h9.75a.75.75 0 0 1 .75.75v15.5zM19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1z';

  var alignTopRight = 'M19.75 20.5H4.25a.75.75 0 0 1-.75-.75V4.25a.75.75 0 0 1 .75-.75H14V10h6.5v9.75a.75.75 0 0 1-.75.75m0-19.5H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1';

  var alignTop = 'M19.75 20.5H4.25a.752.752 0 0 1-.75-.75V10h17v9.75c0 .413-.337.75-.75.75m0-19.5H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1';

  var angledPin = 'M13.988,19.153 C15.485,17.656 15.985,15.446 15.481,13.537 L19.740,9.074 L22.662,8.807 L22.645,8.789 C22.739,8.804 22.837,8.780 22.909,8.708 C23.030,8.587 23.031,8.391 22.910,8.271 L15.730,1.090 C15.609,0.970 15.413,0.970 15.292,1.091 C15.220,1.163 15.197,1.262 15.211,1.356 L15.194,1.338 L14.927,4.261 L10.463,8.520 C8.554,8.015 6.344,8.516 4.847,10.012 L8.656,13.821 L3.324,19.153 C2.562,19.915 0.711,22.108 1.039,22.962 C1.892,23.290 4.086,21.438 4.847,20.676 C5.609,19.915 10.179,15.344 10.179,15.344 L13.988,19.153 Z';

  var apps = 'M20 17a3 3 0 1 0 0 6 3 3 0 0 0 0-6m0-8a3 3 0 1 0 0 6 3 3 0 0 0 0-6m0-8a3 3 0 1 0 0 6 3 3 0 0 0 0-6m-8 16a3 3 0 1 0 0 6 3 3 0 0 0 0-6m0-8a3 3 0 1 0 0 6 3 3 0 0 0 0-6m0-8a3 3 0 1 0 0 6 3 3 0 0 0 0-6M4 17a3 3 0 1 0 0 6 3 3 0 0 0 0-6m0-8a3 3 0 1 0 0 6 3 3 0 0 0 0-6m3-5a3 3 0 1 1-6 0 3 3 0 0 1 6 0';

  var arrowBack = 'M17.28 24c-.57 0-1.14-.22-1.58-.66L4.5 12 15.7.66a2.21 2.21 0 0 1 3.15 0c.87.88.87 2.3 0 3.18L10.79 12l8.06 8.16c.87.88.87 2.3 0 3.18-.44.44-1 .66-1.57.66';

  var arrowCircleDown = 'M0 12c0 6.63 5.37 12 12 12s12-5.37 12-12S18.63 0 12 0 0 5.37 0 12zm10.77-3.75a1.25 1.25 0 0 1 2.5 0v3.95l1.03-1.03a1.25 1.25 0 0 1 1.77 0c.48.49.48 1.28 0 1.77L12 17l-4.07-4.06c-.48-.49-.48-1.28 0-1.77a1.25 1.25 0 0 1 1.77 0l1.07 1.06V8.25z';

  var arrowCircleForward = 'M12.94 16.07c-.49.48-1.28.48-1.77 0a1.25 1.25 0 0 1 0-1.77l1.06-1.07H8.25a1.25 1.25 0 0 1 0-2.5h3.95L11.17 9.7a1.25 1.25 0 0 1 0-1.77c.49-.48 1.28-.48 1.77 0L17 12l-4.06 4.07zM12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0z';

  var arrowCircleUp = 'M24 12c0-6.627-5.372-12-12-12C5.373 0 0 5.373 0 12s5.373 12 12 12c6.628 0 12-5.373 12-12zm-10.767 3.75a1.25 1.25 0 0 1-2.5 0v-3.948l-1.031 1.031a1.25 1.25 0 0 1-1.768-1.768L12 7l4.066 4.065a1.25 1.25 0 0 1-1.768 1.768l-1.065-1.065v3.982z';

  var arrowDown = 'M12 19.5L.66 8.29c-.88-.86-.88-2.27 0-3.14.88-.87 2.3-.87 3.18 0L12 13.21l8.16-8.06c.88-.87 2.3-.87 3.18 0 .88.87.88 2.28 0 3.14L12 19.5z';

  var arrowForward = 'M6.72 24c.57 0 1.14-.22 1.57-.66L19.5 12 8.29.66c-.86-.88-2.27-.88-3.14 0-.87.88-.87 2.3 0 3.18L13.21 12l-8.06 8.16c-.87.88-.87 2.3 0 3.18.43.44 1 .66 1.57.66';

  var arrowUp = 'M21.75 19.5c-.58 0-1.15-.22-1.59-.65L12 10.79l-8.16 8.06c-.88.87-2.3.87-3.18 0a2.21 2.21 0 0 1 0-3.15L12 4.5l11.34 11.2c.88.87.88 2.28 0 3.15-.44.43-1.01.65-1.59.65';

  var arrowUpRight = 'M4.9283,1 C3.6273,1 2.5713,2.054 2.5713,3.357 C2.5713,4.66 3.6273,5.714 4.9283,5.714 L14.9523,5.714 L1.6893,18.976 C0.7703,19.896 0.7703,21.389 1.6893,22.31 C2.1503,22.771 2.7533,23 3.3573,23 C3.9603,23 4.5633,22.771 5.0243,22.31 L18.2853,9.047 L18.2853,19.071 C18.2853,20.374 19.3413,21.429 20.6433,21.429 C21.9443,21.429 23.0003,20.374 23.0003,19.071 L23.0003,1 L4.9283,1 Z';

  var bell = 'M12 24c-1.66 0-3-1.34-3-3h6c0 1.66-1.34 3-3 3zm7-10.83c1.58 1.52 2.67 3.55 3 5.83H2c.33-2.28 1.42-4.31 3-5.83V7c0-3.87 3.13-7 7-7s7 3.13 7 7v6.17z';

  var camera = 'M6.36 4.99L8.56 2h6.88l2.2 2.99h3.09c1.8 0 3.27 1.49 3.27 3.33v10.35c0 1.84-1.47 3.33-3.27 3.33H3.27C1.47 22 0 20.51 0 18.67V8.32c0-1.84 1.47-3.33 3.27-3.33h3.09zM12 7.22a5.74 5.74 0 1 0 0 11.48 5.74 5.74 0 0 0 0-11.48m0 2.73c1.66 0 3.01 1.35 3.01 3.01 0 1.66-1.35 3.01-3.01 3.01-1.66 0-3.01-1.35-3.01-3.01 0-1.66 1.35-3.01 3.01-3.01';

  var cameraRoll = 'M8 10c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2M6.25 3.5h11.5c1.52 0 2.75 1.23 2.75 2.75v8.25L17 11l-6 6-3.5-3.5-4 4V6.25c0-1.52 1.23-2.75 2.75-2.75M17.75 1H6.25A5.25 5.25 0 0 0 1 6.25v11.5C1 20.64 3.35 23 6.25 23h11.5c2.89 0 5.25-2.36 5.25-5.25V6.25C23 3.35 20.64 1 17.75 1';

  var cancel = 'M15.18 12l7.16-7.16c.88-.88.88-2.3 0-3.18-.88-.88-2.3-.88-3.18 0L12 8.82 4.84 1.66c-.88-.88-2.3-.88-3.18 0-.88.88-.88 2.3 0 3.18L8.82 12l-7.16 7.16c-.88.88-.88 2.3 0 3.18.44.44 1.01.66 1.59.66.58 0 1.15-.22 1.59-.66L12 15.18l7.16 7.16c.44.44 1.01.66 1.59.66.58 0 1.15-.22 1.59-.66.88-.88.88-2.3 0-3.18L15.18 12z';

  var canonicalPin = 'M19 20c0 .551-.448 1-1 1h-7.471c-.551 0-1-.449-1-1v-2H14a2 2 0 0 0 2-2V8h2c.552 0 1 .449 1 1v11zM5.705 9.996a1.126 1.126 0 0 1 1.59-1.591L8.7 9.809l3.004-3.004a1.125 1.125 0 1 1 1.592 1.591L8.7 12.991 5.705 9.996zM18 6h-2V3a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2h2.529v2c0 1.654 1.346 3 3 3H18c1.654 0 3-1.346 3-3V9c0-1.654-1.346-3-3-3z';

  var check = 'M9.17 21.75L.73 12.79c-.97-1.04-.97-2.71 0-3.75a2.403 2.403 0 0 1 3.53 0l4.91 5.22L19.74 3.03c.98-1.04 2.55-1.04 3.53 0 .97 1.03.97 2.71 0 3.74L9.17 21.75z';

  var checkCircle = 'M18.88 9.88l-8.66 8.67-5.12-5.13a1.25 1.25 0 0 1 0-1.77c.48-.49 1.28-.49 1.76 0l3.36 3.36 6.9-6.89c.49-.49 1.28-.49 1.76 0 .49.49.49 1.28 0 1.76M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

  var circleOutline = 'M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.6 0 12 0zm0 22.2C6.45 22.2 1.8 17.7 1.8 12 1.8 6.3 6.3 1.8 12 1.8c5.7 0 10.2 4.5 10.2 10.2 0 5.7-4.65 10.2-10.2 10.2z';

  var clear = 'M15.18 16.95L12 13.77l-3.18 3.18c-.49.49-1.28.49-1.77 0a1.25 1.25 0 0 1 0-1.77L10.23 12 7.05 8.82a1.25 1.25 0 0 1 0-1.77 1.25 1.25 0 0 1 1.77 0L12 10.23l3.18-3.18a1.25 1.25 0 0 1 1.77 0c.49.49.49 1.28 0 1.77L13.77 12l3.18 3.18c.49.49.49 1.28 0 1.77s-1.28.49-1.77 0M24 12c0-6.63-5.37-12-12-12S0 5.37 0 12s5.37 12 12 12 12-5.37 12-12';

  var clock = 'M17.83 17.83c-.37.36-.85.55-1.33.55-.48 0-.96-.19-1.33-.55l-5.04-5.05V6c0-1.04.83-1.87 1.87-1.87s1.88.83 1.88 1.87v5.22l3.95 3.95c.73.74.73 1.92 0 2.66M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

  var cog = 'M6.25 2L.5 12l5.75 10h11.5l5.75-10-5.75-10H6.25zm1.703 10a4 4 0 1 1 8 0 4 4 0 0 1-8 0z';

  var colorPicker = 'M1.73 18.751l8.23-8.231 3.52 3.52-8.232 8.23a2.487 2.487 0 0 1-3.519 0 2.487 2.487 0 0 1 0-3.519zM22.026 1.972a3.318 3.318 0 0 1 0 4.693l-3.907 3.908.116.118a1.493 1.493 0 1 1-2.111 2.111l-4.928-4.927a1.494 1.494 0 0 1 2.112-2.112l.117.117 3.908-3.908a3.318 3.318 0 0 1 4.693 0z';

  var compass = 'M12.868 12.9A1.25 1.25 0 1 0 11.1 11.13a1.25 1.25 0 0 0 1.77 1.768m2.268 1.134c-.207.517-.62.924-1.139 1.124L5.62 18.38l3.223-8.377c.2-.52.607-.933 1.124-1.139l8.617-3.447-3.447 8.617zm5.348-10.519c-4.686-4.686-12.284-4.686-16.97 0-4.687 4.687-4.687 12.285 0 16.971 4.686 4.686 12.284 4.686 16.97 0 4.686-4.686 4.686-12.284 0-16.97z';

  var compose = 'M2.337 19.942l5.671-1.977L19.265 6.706c.981-.98.981-2.57 0-3.55l-1.42-1.421a2.51 2.51 0 0 0-3.55 0L3.036 12.992l-1.978 5.671a1.005 1.005 0 0 0 1.279 1.279M23 22c0 .55-.45 1-1 1H2c-.55 0-1-.45-1-1s.45-1 1-1h20c.55 0 1 .45 1 1';

  var crop = 'M22.5 4a1.5 1.5 0 1 1 0 3H20v11.5a1.5 1.5 0 0 1-1.5 1.5H7v2.5a1.5 1.5 0 1 1-3 0V20H1.5a1.5 1.5 0 1 1 0-3H4V5.5A1.5 1.5 0 0 1 5.5 4H17V1.5a1.5 1.5 0 1 1 3 0V4h2.5zM7 17h10V7H7v10zm5-3a2 2 0 1 1 .001-4.001A2 2 0 0 1 12 14z';

  var dash = 'M20 16H4c-2.2 0-4-1.8-4-4s1.8-4 4-4h16c2.2 0 4 1.8 4 4s-1.8 4-4 4';

  var download = 'M21 14a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2v-6a2 2 0 0 1 4 0v4h14v-4a2 2 0 0 1 2-2zM8.815 6.987l1.176 1.178V2a2 2 0 0 1 4 0v6.178l1.196-1.193a2 2 0 1 1 2.826 2.831l-6.025 6.013-6.004-6.016a2 2 0 0 1 2.831-2.826z';

  var edit = 'M13.386 6.018l4.596 4.596L7.097 21.499 1 22.999l1.501-6.096L13.386 6.018zm8.662-4.066a3.248 3.248 0 0 1 0 4.596L19.75 8.848 15.154 4.25l2.298-2.299a3.248 3.248 0 0 1 4.596 0z';

  var ellipsis = 'M12 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3M3 9c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm18 0c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3z';

  var ellipsisCircleOutline = 'M12 10.5c.9 0 1.5.6 1.5 1.5s-.6 1.5-1.5 1.5-1.5-.6-1.5-1.5.6-1.5 1.5-1.5zm-4.5 0c.9 0 1.5.6 1.5 1.5s-.6 1.5-1.5 1.5S6 12.9 6 12s.6-1.5 1.5-1.5zm9 0c.9 0 1.5.6 1.5 1.5s-.6 1.5-1.5 1.5S15 12.9 15 12s.6-1.5 1.5-1.5zM12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.6 0 12 0zm0 22.2C6.45 22.2 1.8 17.7 1.8 12 1.8 6.3 6.3 1.8 12 1.8c5.7 0 10.2 4.5 10.2 10.2 0 5.7-4.65 10.2-10.2 10.2z';

  var envelope = 'M21.53 7.508l-7.586 7.452c-.536.526-1.24.79-1.944.79a2.77 2.77 0 0 1-1.945-.79L2.47 7.508a.728.728 0 0 1 0-1.043.76.76 0 0 1 1.061 0l7.586 7.452c.487.48 1.28.48 1.768 0l7.585-7.452a.76.76 0 0 1 1.061 0 .728.728 0 0 1 0 1.043zM1 19h22V5H1v14z';

  var eye = 'M10,12 C10,13.105 10.895,14 12,14 C13.105,14 14,13.105 14,12 C14,10.895 13.105,10 12,10 C10.895,10 10,10.895 10,12 Z M12,17 C9.239,17 7,14.761 7,12 C7,9.239 9.239,7 12,7 C14.761,7 17,9.239 17,12 C17,14.761 14.761,17 12,17 M12,3.5 C6.455,3.5 1.751,7.051 0,12 C1.751,16.949 6.455,20.5 12,20.5 C17.545,20.5 22.249,16.949 24,12 C22.249,7.051 17.545,3.5 12,3.5';

  var facebook = 'M17.75 3.984l-2.312.001c-1.811 0-2.163.842-2.163 2.077v2.724h4.323l-.563 4.267h-3.76V24H8.769V13.053H5V8.786h3.769V5.64C8.769 1.988 11.05 0 14.383 0c1.596 0 2.967.116 3.367.168v3.816z';

  var faceHappy = 'M12.023 20.713c-2.944 0-5.378-1.96-5.356-4.906.017-2.117 1.728-.536 5.33-.545 3.6-.01 5.322-1.645 5.327.548.007 2.946-2.356 4.903-5.3 4.903m4.439-9.83a1.675 1.675 0 1 1 0-3.351 1.675 1.675 0 0 1 0 3.35M6.093 9.207a1.675 1.675 0 1 1 3.35 0 1.675 1.675 0 0 1-3.35 0m17.906 2.782C23.994 5.367 18.623 0 12 0 5.373 0 0 5.373 0 12c0 6.628 5.373 12 12 12C18.624 24 23.995 18.633 24 12.01L24 12l-.001-.01';

  var faceSad = 'M17.088 17.841a1.2 1.2 0 0 1-1.593.58 4.517 4.517 0 0 0-.744-.217c-.738-.168-1.653-.27-2.75-.271-1.098 0-2.012.103-2.752.27-.411.094-.657.18-.741.217a1.199 1.199 0 1 1-1.014-2.174c.237-.11.643-.251 1.223-.383.915-.207 2.008-.33 3.284-.33 1.276.001 2.369.123 3.281.33.582.132.988.273 1.226.384.601.279.86.992.58 1.594zm-.624-6.959a1.675 1.675 0 1 1 0-3.35 1.675 1.675 0 0 1 0 3.35zM6.093 9.207a1.675 1.675 0 1 1 3.35 0 1.675 1.675 0 0 1-3.35 0zM24 11.989C23.995 5.367 18.624 0 12.002 0 5.373 0 0 5.373 0 12c0 6.628 5.373 12 12.002 12C18.623 24 23.995 18.633 24 12.01v-.02z';

  var faceSmiley = 'M16.5 11a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3m.449 5.95A6.947 6.947 0 0 1 12 19a6.96 6.96 0 0 1-4.948-2.048.999.999 0 0 1 0-1.414.999.999 0 0 1 1.414-.001A4.968 4.968 0 0 0 12 17c1.336 0 2.592-.52 3.535-1.464a1 1 0 0 1 1.414 1.414M6 9.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0';

  var filter = 'M24 3.5c0-1.1-.9-2-2-2H2c-1.1 0-2 .9-2 2 0 .55.22 1.05.58 1.41L9 13.46v9.04l6-2v-7.05l8.37-8.5c.39-.36.63-.88.63-1.45';

  var fillOpaque = 'M6 18h12V6H6v12zm14.5 1.75a.75.75 0 0 1-.75.75H4.25a.75.75 0 0 1-.75-.75V4.25a.75.75 0 0 1 .75-.75h15.5a.75.75 0 0 1 .75.75v15.5zM19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1z';

  var fillTransparent = 'M15 18h3v-3h-3v3zm-6 0h3v-3H9v3zm3-3h3v-3h-3v3zm-6 0h3v-3H6v3zm9-3h3V9h-3v3zm-6 0h3V9H9v3zm3-3h3V6h-3v3zM6 9h3V6H6v3zM4.25 3.5a.75.75 0 0 0-.75.75v15.5c0 .414.337.75.75.75h15.5a.75.75 0 0 0 .75-.75V4.25a.75.75 0 0 0-.75-.75H4.25zM19.75 23H4.25A3.254 3.254 0 0 1 1 19.75V4.25A3.254 3.254 0 0 1 4.25 1h15.5A3.254 3.254 0 0 1 23 4.25v15.5A3.254 3.254 0 0 1 19.75 23z';

  var flag = 'M17 7.5L22 0H2v22c0 1.1.9 2 2 2s2-.9 2-2v-7h16l-5-7.5z';

  var flashlight = 'M6 7.08V10H1V7.08A6.086 6.086 0 0 1 7.079 1H10v5H6v1.08zM6 18h4v5H7.079A6.086 6.086 0 0 1 1 16.921V14h5v4zM16.92 1A6.086 6.086 0 0 1 23 7.079V10h-5V6h-4V1h2.92zM18 16.92V14h5v2.92A6.086 6.086 0 0 1 16.921 23H14v-5h4v-1.08z';

  var flipHorizontal = 'M12 4.118v16.384H3.815L12 4.118zm10.778 15.975L13.792 2.107A1.98 1.98 0 0 0 12 1c-.712 0-1.423.37-1.792 1.107L1.22 20.093C.541 21.422 1.51 23 3.006 23h17.99c1.495 0 2.462-1.578 1.782-2.907z';

  var flipVertical = 'M19.882 12H3.498V3.814L19.882 12zm2.012-1.792L3.907 1.22A1.98 1.98 0 0 0 2.999 1C1.951 1 1 1.843 1 3.005v17.99C1 22.157 1.951 23 3 23c.3 0 .61-.07.907-.221l17.987-8.987c1.475-.737 1.475-2.847 0-3.584z';

  var gif = 'M19.5 3h-15C2.02 3 0 5.03 0 7.5v9C0 18.98 2.02 21 4.5 21h15c2.47 0 4.5-2.02 4.5-4.5v-9C24 5.03 21.97 3 19.5 3zm-7.41 12.88v-7.8h1.59v7.8h-1.59zm3.45-7.8h5.58v1.34h-4v1.88h3.39v1.35h-3.39v3.23h-1.58v-7.8zm-11.4 6.83c-.33-.37-.58-.79-.76-1.28-.17-.49-.26-1.03-.26-1.62 0-.66.11-1.26.33-1.8.22-.55.53-1.01.95-1.39.32-.29.68-.51 1.1-.66.41-.15.88-.23 1.4-.23.49 0 .93.06 1.32.19s.72.31 1 .54c.27.23.5.51.67.83.17.32.29.67.35 1.04H8.69a1.67 1.67 0 0 0-.56-.93c-.29-.24-.69-.36-1.19-.36-.37 0-.7.07-.97.21-.27.14-.5.34-.69.59-.18.25-.32.54-.41.88-.09.34-.13.7-.13 1.09 0 .4.05.77.15 1.1.1.34.25.63.43.88.19.24.42.43.69.57.27.14.57.21.9.21.31 0 .59-.05.83-.16.25-.1.46-.23.64-.4.17-.17.31-.36.4-.57.1-.21.14-.42.14-.64v-.04H7.05v-1.22h3.28v4.14H9.14l-.05-1.05h-.03c-.27.45-.58.77-.94.94a2.8 2.8 0 0 1-1.25.27c-.59 0-1.11-.1-1.56-.3-.46-.2-.85-.48-1.17-.83z';

  var globe = 'M15.49 20.83c.87-2.01 1.37-4.75 1.48-7.58h4.44a9.53 9.53 0 0 1-5.92 7.58zm-12.9-7.58h4.44c.11 2.83.61 5.57 1.49 7.58-3.15-1.25-5.47-4.12-5.93-7.58zM8.52 3.17c-.88 2.01-1.38 4.75-1.49 7.58H2.59c.46-3.46 2.78-6.33 5.93-7.58zm1.01 7.58C9.76 5.43 11.4 2.54 12 2.5h.01c.67.06 2.24 3.01 2.46 8.25H9.53zm2.48 10.75H12c-.6-.04-2.24-2.93-2.47-8.25h4.94c-.22 5.24-1.79 8.19-2.46 8.25zm9.4-10.75h-4.44c-.11-2.83-.61-5.57-1.48-7.58a9.53 9.53 0 0 1 5.92 7.58zM24 12C24 5.39 18.62.01 12.01 0H12C5.38 0 0 5.38 0 12s5.38 12 12 12h.01C18.62 24 24 18.61 24 12z';

  var globeChecked = 'M6.8 9.8H3.1C3.5 7 5.4 4.6 8 3.6c-.7 1.7-1.1 3.9-1.2 6.2m-3.7 2.1h3.7c.1 2.3.5 4.6 1.2 6.2-2.6-1-4.5-3.3-4.9-6.2m7.8-8.8c.5 0 1.8 2.4 2 6.7H8.8c.2-4.3 1.6-6.7 2.1-6.7M9.5 16.3c-.3-1.1-.6-2.6-.7-4.4h2.7c.9-1 2.1-1.7 3.5-2.1-.1-2.3-.5-4.5-1.3-6.2 2.6 1 4.4 3.3 4.9 6.1.7.1 1.5.4 2.1.8-.2-5.3-4.5-9.5-9.8-9.5C5.4 1 1 5.4 1 10.9c0 5.3 4.2 9.6 9.5 9.8-.6-1.1-1-2.3-1-3.7v-.7m10.8-.5L16.2 20l-2.5-2.5c-.3-.3-.3-.8 0-1.1.3-.3.8-.3 1 0l1.5 1.5 3.1-3.2c.2-.3.7-.3 1 0 .3.3.3.8 0 1.1M17 11c-3.3 0-6 2.7-6 6s2.7 6 6 6 6-2.7 6-6-2.7-6-6-6';

  var gmail = 'M3.173 4L12 10.194 20.556 4H3.173zM12 13.29L1 5.806V20h22V5.548L12 13.29z';

  var googlePlus = 'M7 11v2.4h3.97c-.16 1.029-1.2 3.02-3.97 3.02-2.39 0-4.34-1.979-4.34-4.42 0-2.44 1.95-4.42 4.34-4.42 1.36 0 2.27.58 2.79 1.08l1.9-1.83C10.47 5.69 8.89 5 7 5c-3.87 0-7 3.13-7 7s3.13 7 7 7c4.04 0 6.721-2.84 6.721-6.84 0-.46-.051-.81-.111-1.16H7zm17 0v2h-3v3h-2v-3h-3v-2h3V8h2v3h3z';

  var graphBar = 'M1 23V10h5v13H1zm8.5 0V1h5v22h-5zm8.5 0V7h4.999v16H18z';

  var knoop = 'M15 10.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5m0 6c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5m-6-6c-.83 0-1.5-.67-1.5-1.5S8.17 7.5 9 7.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5m0 6c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

  var lightbulb = 'M20 8c0 2.23-.91 4.24-2.39 5.7h.02c-.99.97-1.6 2.31-1.63 3.8V19H8v-1.5c-.03-1.5-.65-2.85-1.64-3.83A7.955 7.955 0 0 1 4 8c0-4.42 3.58-8 8-8s8 3.58 8 8zM8 22.5V21h8v1.5c0 .83-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z';

  var logout = 'M12 14a2 2 0 0 0 2-2V3a2 2 0 0 0-4 0v9a2 2 0 0 0 2 2m11-2c0 2.938-1.144 5.701-3.222 7.778A10.925 10.925 0 0 1 12 23a10.925 10.925 0 0 1-7.778-3.222A10.925 10.925 0 0 1 1 12c0-2.938 1.144-5.701 3.222-7.778A2 2 0 0 1 7.05 7.051 6.952 6.952 0 0 0 5 12c0 1.87.728 3.627 2.05 4.949A6.953 6.953 0 0 0 12 19c1.87 0 3.627-.728 4.949-2.05A6.953 6.953 0 0 0 19 12c0-1.87-.728-3.627-2.05-4.949a2 2 0 1 1 2.828-2.829A10.925 10.925 0 0 1 23 12';

  var logoLarge = 'M18.656 11.196l-3.333 2.573 1.25 4.089c.25.817-.687 1.477-1.359.958L12 16.334l-3.214 2.482c-.673.519-1.609-.141-1.359-.958l1.25-4.09-3.334-2.572c-.66-.511-.304-1.578.53-1.578h4.073L11.17 5.62c.252-.826 1.41-.826 1.662 0l1.222 3.998h4.075c.833 0 1.19 1.067.528 1.578zM21.75 3.5H2.25a1.25 1.25 0 0 1 0-2.5h19.5a1.25 1.25 0 0 1 0 2.5zm0 19.5H2.25a1.25 1.25 0 0 1 0-2.5h19.5a1.25 1.25 0 0 1 0 2.5z';

  var logoSmall = 'M15.804 14.54L13.9 16.01l.714 2.337c.143.467-.392.845-.777.547L12 17.477l-1.837 1.418c-.384.297-.92-.08-.776-.547l.714-2.337-1.904-1.47c-.378-.293-.174-.902.3-.902h2.329l.7-2.285a.495.495 0 0 1 .949 0l.699 2.285h2.328c.476 0 .68.61.302.902zM21.75 9.5H2.25a1.25 1.25 0 0 1 0-2.5h19.5a1.25 1.25 0 0 1 0 2.5zm0 13.5H2.25a1.25 1.25 0 0 1 0-2.5h19.5a1.25 1.25 0 0 1 0 2.5z';

  var handle = 'M3 15h18a1 1 0 0 1 0 2H3a1 1 0 0 1 0-2zm0-4h18a1 1 0 0 1 0 2H3a1 1 0 0 1 0-2zm0-4h18a1 1 0 0 1 0 2H3a1 1 0 1 1 0-2z';

  var handPointing = 'M17.776,22.390 C13.775,23.978 9.246,22.359 7.219,18.770 C7.040,18.503 6.860,18.218 6.688,17.910 C5.132,15.163 3.028,13.782 2.588,13.581 C2.149,13.378 0.595,12.613 1.100,11.692 C1.381,11.180 2.163,10.801 2.878,10.726 C4.000,10.481 5.897,11.034 7.772,12.222 L4.054,3.419 C3.741,2.677 3.989,1.850 4.609,1.379 C4.612,1.376 4.616,1.373 4.621,1.369 C4.676,1.327 4.734,1.289 4.796,1.253 C4.810,1.247 4.821,1.239 4.835,1.231 C4.901,1.195 4.970,1.160 5.042,1.132 C5.044,1.131 5.044,1.131 5.045,1.131 C5.045,1.131 5.045,1.131 5.047,1.129 C5.119,1.101 5.193,1.079 5.267,1.060 C5.281,1.057 5.295,1.054 5.309,1.049 C5.380,1.035 5.449,1.021 5.518,1.013 C5.525,1.013 5.529,1.011 5.534,1.011 C6.317,0.928 7.093,1.347 7.406,2.088 L9.592,7.261 C9.643,6.623 10.055,6.035 10.709,5.776 C11.633,5.410 12.689,5.839 13.069,6.734 C13.071,6.742 13.074,6.752 13.077,6.759 C13.143,6.136 13.552,5.565 14.191,5.312 C15.117,4.946 16.173,5.373 16.551,6.271 C16.567,6.305 16.578,6.341 16.591,6.379 C16.680,5.784 17.079,5.249 17.695,5.006 C18.619,4.640 19.619,4.970 19.999,5.867 L20.001,5.872 C20.001,5.872 21.115,8.039 22.366,11.651 C22.413,11.791 22.457,11.931 22.495,12.072 C24.027,16.161 21.967,20.728 17.776,22.390';

  var heart = 'M11.98 22.25L1.82 11.95C-.28 9.83-.65 6.4 1.18 4.03a5.763 5.763 0 0 1 8.7-.56l2.1 2.14 1.95-1.98c2.1-2.13 5.48-2.5 7.82-.65 2.8 2.23 2.99 6.35.55 8.82L11.98 22.25z';

  var heartBroken = 'M11.98 22.25L1.82 11.95C-.28 9.83-.65 6.4 1.18 4.03a5.763 5.763 0 0 1 8.7-.56l2.1 2.14 1.95-1.98c2.1-2.13 5.48-2.5 7.82-.65 2.8 2.23 2.99 6.35.55 8.82L11.98 22.25zM15.3 9.54c.4-.4.4-1.06 0-1.46-.4-.4-1.05-.4-1.45 0L12 9.94l-1.85-1.86c-.4-.4-1.05-.4-1.45 0-.4.4-.4 1.06 0 1.46l1.85 1.86-1.85 1.86c-.4.4-.4 1.05 0 1.45.4.4 1.05.41 1.45 0L12 12.85l1.85 1.86c.4.41 1.05.41 1.45 0 .4-.4.4-1.05 0-1.45l-1.85-1.86 1.85-1.86z';

  var impressum = 'M10 12c0-1.103.897-2 2-2s2 .897 2 2-.897 2-2 2-2-.897-2-2m2-5c-1.103 0-2-.897-2-2s.897-2 2-2 2 .897 2 2h3c0-2.757-2.243-5-5-5S7 2.243 7 5a4.98 4.98 0 0 0 1.438 3.5A4.98 4.98 0 0 0 7 12c0 2.757 2.243 5 5 5 1.103 0 2 .897 2 2s-.897 2-2 2-2-.897-2-2H7c0 2.757 2.243 5 5 5s5-2.243 5-5a4.98 4.98 0 0 0-1.438-3.5A4.98 4.98 0 0 0 17 12c0-2.757-2.243-5-5-5';

  var link = 'M21 15.05c1.1 0 2 .9 2 2V21c0 1.1-.9 2-2 2H3c-1.1 0-2-.9-2-2V3c0-1.1.9-2 2-2h4a2 2 0 1 1 0 4H5v14h14v-1.95c0-1.1.9-2 2-2zM12 14c-.51 0-1.02-.2-1.41-.59-.79-.78-.79-2.04 0-2.82L16.16 5 14 5.01c-1.1 0-2-.9-2-2 0-1.11.89-2 2-2L20.99 1h2v2l.01 7a2 2 0 1 1-4 0V7.83l-5.59 5.58c-.39.39-.9.59-1.41.59z';

  var location = 'M12 4.5c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3m7.5 3C19.5 3.36 16.14 0 12 0 7.86 0 4.5 3.36 4.5 7.5c0 1.3.36 2.5.94 3.56H5.4L12 24l6.6-12.94h-.04c.58-1.06.94-2.26.94-3.56';

  var lock = 'M8 10V7c0-2.206 1.794-4 4-4s4 1.794 4 4v3H8zm11 .017V7c0-3.86-3.141-7-7-7S5 3.14 5 7v3.017a8.698 8.698 0 0 0-1.75 5.233 8.75 8.75 0 1 0 17.5 0A8.698 8.698 0 0 0 19 10.017z';

  var marginsLarge = 'M18.75 1A4.255 4.255 0 0 1 23 5.25v13.5A4.255 4.255 0 0 1 18.75 23H5.25A4.255 4.255 0 0 1 1 18.75V5.25A4.255 4.255 0 0 1 5.25 1h13.5zM5.5 18.5h13v-13h-13v13zm9.97-1.97l-1.5-1.5-1.47 1.47v-4h4l-1.47 1.47 1.5 1.5-1.06 1.06zM7.5 11.5l1.47-1.47-1.5-1.5 1.06-1.06 1.5 1.5L11.5 7.5v4h-4z';

  var marginsMedium = 'M7.53 6.47l1.5 1.5L10.5 6.5v4h-4l1.47-1.47-1.5-1.5 1.06-1.06zm9.97 7.03l-1.47 1.47 1.5 1.5-1.06 1.06-1.5-1.5-1.47 1.47v-4h4zm2 5.75a.25.25 0 0 1-.25.25H4.75a.25.25 0 0 1-.25-.25V4.75a.25.25 0 0 1 .25-.25h14.5a.25.25 0 0 1 .25.25v14.5zM19.25 1H4.75A3.754 3.754 0 0 0 1 4.75v14.5A3.754 3.754 0 0 0 4.75 23h14.5A3.754 3.754 0 0 0 23 19.25V4.75A3.754 3.754 0 0 0 19.25 1z';

  var marginsSmall = 'M18.5 14.5l-1.47 1.47 1.5 1.5-1.06 1.06-1.5-1.5-1.47 1.47v-4h4zM6.53 5.47l1.5 1.5L9.5 5.5v4h-4l1.47-1.47-1.5-1.5 1.06-1.06zM20.5 19.75a.75.75 0 0 1-.75.75H4.25a.75.75 0 0 1-.75-.75V4.25a.75.75 0 0 1 .75-.75h15.5a.75.75 0 0 1 .75.75v15.5zM19.75 1H4.25A3.254 3.254 0 0 0 1 4.25v15.5A3.254 3.254 0 0 0 4.25 23h15.5A3.254 3.254 0 0 0 23 19.75V4.25A3.254 3.254 0 0 0 19.75 1z';

  var maximize = 'M11 2.25c0 .69-.56 1.25-1.25 1.25H5.268l5.366 5.366a1.25 1.25 0 0 1-1.768 1.768L3.5 5.268V9.75a1.25 1.25 0 0 1-2.5 0V1h8.75c.69 0 1.25.56 1.25 1.25zM21.75 13c.69 0 1.25.56 1.25 1.25V23h-8.75a1.25 1.25 0 0 1 0-2.5h4.482l-5.366-5.366a1.25 1.25 0 0 1 1.768-1.768l5.366 5.366V14.25c0-.69.56-1.25 1.25-1.25z';

  var megaphone = 'M14 17.5c0 1.378-1.122 2.5-2.5 2.5A2.503 2.503 0 0 1 9 17.5V17h5v.5zm8.947-1.87L18.701 2.712a1.022 1.022 0 0 0-1.566-.521l-15.7 11.24c-.37.264-.525.744-.382 1.179l.551 1.678c.14.425.532.712.974.712H7v.5a4.5 4.5 0 0 0 9 0V17h5.973c.7 0 1.195-.696.974-1.37z';

  var menu = 'M21.5 9.5c1.38 0 2.5 1.13 2.5 2.5a2.5 2.5 0 0 1-2.5 2.5h-19C1.13 14.5 0 13.38 0 12c0-1.37 1.13-2.5 2.5-2.5h19zm-19-3C1.13 6.5 0 5.38 0 4c0-1.37 1.13-2.5 2.5-2.5h19C22.88 1.5 24 2.63 24 4a2.5 2.5 0 0 1-2.5 2.5h-19zm19 11c1.38 0 2.5 1.13 2.5 2.5a2.5 2.5 0 0 1-2.5 2.5h-19C1.13 22.5 0 21.38 0 20c0-1.37 1.13-2.5 2.5-2.5h19z';

  var minimize = 'M1 9.75c0-.69.56-1.25 1.25-1.25h4.482L1.366 3.134a1.25 1.25 0 0 1 1.768-1.768L8.5 6.732V2.25a1.25 1.25 0 0 1 2.5 0V11H2.25C1.56 11 1 10.44 1 9.75zM14.25 23c-.69 0-1.25-.56-1.25-1.25V13h8.75a1.25 1.25 0 0 1 0 2.5h-4.482l5.366 5.366a1.25 1.25 0 0 1-1.768 1.768L15.5 17.268v4.482c0 .69-.56 1.25-1.25 1.25z';

  var move = 'M14.3 18.17a1.25 1.25 0 0 1 1.77 0c.49.49.49 1.28 0 1.76L12 24l-4.07-4.07c-.48-.48-.48-1.27 0-1.76a1.25 1.25 0 0 1 1.77 0l1.05 1.04v-3.96a1.25 1.25 0 0 1 2.5 0v3.96l1.05-1.04zm-9.51-4.92l1.04 1.05c.49.49.49 1.28 0 1.77-.48.48-1.28.48-1.76 0L0 12l4.07-4.07c.48-.48 1.28-.48 1.76 0 .49.49.49 1.28 0 1.77l-1.04 1.05h3.96a1.25 1.25 0 0 1 0 2.5H4.79zm15.14-5.32L24 12l-4.07 4.07c-.48.48-1.27.48-1.76 0a1.25 1.25 0 0 1 0-1.77l1.04-1.05h-3.96a1.25 1.25 0 0 1 0-2.5h3.96L18.17 9.7a1.25 1.25 0 0 1 0-1.77c.49-.48 1.28-.48 1.76 0zM9.7 5.83c-.49.49-1.28.49-1.77 0-.48-.49-.48-1.28 0-1.76L12 0l4.07 4.07c.49.48.49 1.27 0 1.76s-1.28.49-1.77 0l-1.05-1.04v3.96a1.25 1.25 0 0 1-2.5 0V4.79L9.7 5.83z';

  var mute = 'M5.00,7.94 L5.00,7.96 L12.00,1.00 L12.00,23.00 L5.00,16.91 L5.00,16.94 L2.00,16.94 C0.90,16.94 0.00,16.04 0.00,14.94 L0.00,9.94 C0.00,8.83 0.90,7.94 2.00,7.94 L5.00,7.94 Z M23.63,14.12 C24.12,14.60 24.12,15.39 23.63,15.88 C23.15,16.37 22.35,16.37 21.87,15.88 L19.75,13.77 L17.63,15.88 C17.15,16.37 16.35,16.37 15.87,15.88 C15.38,15.39 15.38,14.60 15.87,14.12 L17.98,12.00 L15.87,9.88 C15.38,9.39 15.38,8.60 15.87,8.12 C16.35,7.63 17.15,7.63 17.63,8.12 L19.75,10.23 L21.86,8.12 C22.35,7.63 23.15,7.63 23.63,8.12 C24.12,8.60 24.12,9.40 23.63,9.88 L21.52,12.00 L23.63,14.12 Z';

  var overlayText = 'M20 1a3 3 0 0 1 3 3v16a3 3 0 0 1-3 3H4a3 3 0 0 1-3-3V4a3 3 0 0 1 3-3h16zm-6.718 4.133a1.403 1.403 0 0 0-2.564 0l-5.597 12.6a1.396 1.396 0 0 0 .714 1.846 1.401 1.401 0 0 0 1.85-.711L8.56 16.9h6.882l.874 1.967a1.404 1.404 0 0 0 1.851.71 1.397 1.397 0 0 0 .713-1.845l-5.597-12.6zM9.803 14.1L12 9.155l2.197 4.945H9.803z';

  var pause = 'M7 0c1.65 0 3 1.35 3 3v18c0 1.65-1.35 3-3 3s-3-1.35-3-3V3c0-1.65 1.35-3 3-3zm10 0c1.65 0 3 1.35 3 3v18c0 1.65-1.35 3-3 3s-3-1.35-3-3V3c0-1.65 1.35-3 3-3z';

  var people = 'M8 11a4.5 4.5 0 1 1 0-9 4.5 4.5 0 0 1 0 9zm10 3c3.314 0 6 2.713 6 6.061V22H0v-1.919C0 15.618 3.582 12 8 12c2.614 0 4.927 1.272 6.387 3.23A5.927 5.927 0 0 1 18 14zm0-1a3.25 3.25 0 1 1 0-6.5 3.25 3.25 0 0 1 0 6.5z';

  var person = 'M12 12c5.523 0 10 4.477 10 10v2H2v-2c0-5.523 4.477-10 10-10zm0-1a5.5 5.5 0 1 1 0-11 5.5 5.5 0 1 1 0 11z';

  var personAdd = 'M16.5 12a7.5 7.5 0 0 1 7.5 7.5V21H9v-1.5a7.5 7.5 0 0 1 7.5-7.5zm0-1a4 4 0 1 1 0-8 4 4 0 0 1 0 8zm-7.25 1H6.5v2.75a1.25 1.25 0 0 1-2.5 0V12H1.25a1.25 1.25 0 0 1 0-2.5H4V6.75a1.25 1.25 0 0 1 2.5 0V9.5h2.75a1.25 1.25 0 0 1 0 2.5z';

  var pin = 'M18 13.5c0-2.22-1.21-4.15-3-5.19V2.45A2.5 2.5 0 0 0 17 0H7a2.5 2.5 0 0 0 2 2.45v5.86c-1.79 1.04-3 2.97-3 5.19h5v8.46L12 24l1-2.04V13.5h5z';

  var pinHide = 'M9.13 6.37c.49.48.49 1.27 0 1.76l-2.61 2.62 2.61 2.62c.49.48.49 1.27 0 1.76-.48.49-1.27.49-1.76 0l-2.62-2.61-2.62 2.61c-.48.49-1.28.49-1.76 0-.49-.49-.49-1.28 0-1.76l2.61-2.62L.37 8.13c-.49-.49-.49-1.28 0-1.76.48-.49 1.28-.49 1.76 0l2.62 2.61 2.62-2.61c.49-.49 1.28-.49 1.76 0zM20.5 8.69c1.49.87 2.5 2.46 2.5 4.31h-4v7.96L18 23l-1-2.04V13h-4c0-1.85 1.01-3.44 2.5-4.31V2.93c-.86-.22-1.5-1-1.5-1.93h8c0 .93-.64 1.71-1.5 1.93v5.76z';

  var pinterest = 'M0 12c0 5.123 3.211 9.497 7.73 11.218-.11-.937-.227-2.482.025-3.566.217-.932 1.401-5.938 1.401-5.938s-.357-.715-.357-1.774c0-1.66.962-2.9 2.161-2.9 1.02 0 1.512.765 1.512 1.682 0 1.025-.653 2.557-.99 3.978-.281 1.189.597 2.159 1.769 2.159 2.123 0 3.756-2.239 3.756-5.471 0-2.861-2.056-4.86-4.991-4.86-3.398 0-5.393 2.549-5.393 5.184 0 1.027.395 2.127.889 2.726a.36.36 0 0 1 .083.343c-.091.378-.293 1.189-.332 1.355-.053.218-.173.265-.4.159-1.492-.694-2.424-2.875-2.424-4.627 0-3.769 2.737-7.229 7.892-7.229 4.144 0 7.365 2.953 7.365 6.899 0 4.117-2.595 7.431-6.199 7.431-1.211 0-2.348-.63-2.738-1.373 0 0-.599 2.282-.744 2.84-.282 1.084-1.064 2.456-1.549 3.235C9.584 23.815 10.77 24 12 24c6.627 0 12-5.373 12-12S18.627 0 12 0 0 5.373 0 12';

  var play = 'M20.62 9.48L6.63.48C4.63-.8 2 .63 2 3v18c0 2.37 2.63 3.8 4.63 2.52l13.99-9c1.84-1.18 1.84-3.86 0-5.04';

  var questionMark = 'M14.34 21.2c0 1.57-1.19 2.8-2.78 2.8-1.58 0-2.77-1.23-2.77-2.8 0-1.57 1.19-2.8 2.77-2.8 1.59 0 2.78 1.23 2.78 2.8m-2.53-10.88c1.41-1.23 3.3-2.05 3.3-3.87 0-1.45-1.24-2.36-2.95-2.36-2.12 0-3.52 1.48-3.55 3.43H3.75C3.88 3.3 6.96 0 12.34 0c4.86 0 7.91 2.52 7.91 6.32 0 2.36-1.09 3.81-2.3 4.78-1.68 1.33-2.84 1.89-3.49 2.61-.5.57-.62 1.04-.65 1.95H9.45c0-2.64.65-3.9 2.36-5.34';

  var remove = 'M17.75 13.25H6.25a1.25 1.25 0 0 1 0-2.5h11.5a1.25 1.25 0 0 1 0 2.5M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

  var reorderImages = 'M22 4.25a1.25 1.25 0 0 0-2.5 0v1.618C17.473 3.465 14.493 2 11.299 2 7.606 2 4.205 3.887 2.201 7.048a1.292 1.292 0 0 0 .375 1.769 1.243 1.243 0 0 0 1.739-.381c1.539-2.427 4.15-3.876 6.984-3.876 2.436 0 4.706 1.115 6.261 2.94h-1.31a1.25 1.25 0 0 0 0 2.5H22V4.25zM19 12a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-7a1 1 0 0 0-1-1h-4zm-8 0a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-7a1 1 0 0 0-1-1h-4zm-4-1H1a1 1 0 0 0-1 1v9a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-9a1 1 0 0 0-1-1z';

  var report = 'M7.91 18.89A8.013 8.013 0 0 0 18.89 7.91L7.91 18.89zm-2.82-2.83L16.06 5.09A8.015 8.015 0 0 0 5.09 16.06zM12 24C5.37 24 0 18.63 0 12S5.37 0 12 0s12 5.37 12 12-5.37 12-12 12z';

  var rotate = 'M11.003 9.96c1.105 0 2 .899 2 2.006v9.028a2.004 2.004 0 0 1-2 2.006H2.001C.896 23 0 22.102 0 20.994v-9.028C0 10.86.896 9.96 2 9.96h9.003zm12.63 1.872c.489.49.489 1.283 0 1.773l-3.885 3.896-3.878-3.897a1.256 1.256 0 0 1 .002-1.773 1.248 1.248 0 0 1 1.768.002l.865.87V7.27a3.76 3.76 0 0 0-3.75-3.762H7.251c-.69 0-1.25-.562-1.25-1.254 0-.693.56-1.254 1.25-1.254h7.502c3.447 0 6.252 2.812 6.252 6.27v5.424l.86-.862c.489-.49 1.28-.49 1.768 0z';

  var search = 'M10 16c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6m13.12 2.88l-4.26-4.26A9.842 9.842 0 0 0 20 10c0-5.52-4.48-10-10-10S0 4.48 0 10s4.48 10 10 10c1.67 0 3.24-.41 4.62-1.14l4.26 4.26a3 3 0 0 0 4.24 0 3 3 0 0 0 0-4.24';

  var security = 'M21 9.587c0 6.06-3.721 11.246-9 13.413-5.279-2.167-9-7.353-9-13.413V3a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v6.587z';

  var send = 'M6 6l-6 6 7.67 2.56L21 3 9.44 16.34 12 24l6-6 6-18';

  var share = 'M21 14c1.1 0 2 .9 2 2v6c0 1.1-.9 2-2 2H3c-1.1 0-2-.9-2-2v-6c0-1.1.9-2 2-2s2 .9 2 2v4h14v-4c0-1.1.9-2 2-2zM8.82 8.84c-.78.78-2.05.79-2.83 0-.78-.78-.79-2.04-.01-2.82L11.99 0l6.02 6.01c.78.78.79 2.05.01 2.83-.78.78-2.05.79-2.83 0l-1.2-1.19v6.18a2 2 0 1 1-4 0V7.66L8.82 8.84z';

  var shoppingBag = 'M9.5 5a2.5 2.5 0 0 1 5 0v2h-5V5zM17 7V5c0-2.76-2.24-5-5-5S7 2.24 7 5v2H2v15c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7h-5z';

  var smiley = 'M12.03 19.29h-.06c-3.48-.03-4.92-2.31-4.98-2.41a.896.896 0 0 1 .27-1.22.82.82 0 0 1 1.17.26c.06.08 1.06 1.58 3.57 1.59 2.51-.01 3.52-1.6 3.56-1.67.25-.41.78-.54 1.18-.28.39.26.52.8.28 1.21-.06.1-1.5 2.49-4.99 2.52zM18 9.43c0 .95-.77 1.71-1.71 1.71-.95 0-1.72-.76-1.72-1.71s.77-1.72 1.72-1.72c.94 0 1.71.77 1.71 1.72zm-12 0c0-.95.77-1.72 1.71-1.72.95 0 1.72.77 1.72 1.72s-.77 1.71-1.72 1.71c-.94 0-1.71-.76-1.71-1.71z';

  var smileyOutline = 'M12.03 19.29h-.06c-3.48-.03-4.92-2.31-4.98-2.41a.896.896 0 0 1 .27-1.22.82.82 0 0 1 1.17.26c.06.08 1.06 1.58 3.57 1.59 2.51-.01 3.52-1.6 3.56-1.67.25-.41.78-.54 1.18-.28.39.26.52.8.28 1.21-.06.1-1.5 2.49-4.99 2.52zM18 9.43c0 .95-.77 1.71-1.71 1.71-.95 0-1.72-.76-1.72-1.71s.77-1.72 1.72-1.72c.94 0 1.71.77 1.71 1.72zm-12 0c0-.95.77-1.72 1.71-1.72.95 0 1.72.77 1.72 1.72s-.77 1.71-1.72 1.71c-.94 0-1.71-.76-1.71-1.71zM12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.6 0 12 0zm0 22.2C6.45 22.2 1.8 17.7 1.8 12 1.8 6.3 6.3 1.8 12 1.8c5.7 0 10.2 4.5 10.2 10.2 0 5.7-4.65 10.2-10.2 10.2z';

  var sound = 'M20.48 3.51A11.92 11.92 0 0 1 24 12c0 3.2-1.25 6.22-3.51 8.48-.25.25-.57.37-.89.37-.32 0-.64-.12-.88-.37-.49-.48-.49-1.27 0-1.76A9.465 9.465 0 0 0 21.5 12c0-2.54-.99-4.93-2.79-6.72-.48-.49-.48-1.28 0-1.77a1.25 1.25 0 0 1 1.77 0zM5 7.94v.02L12 1v22l-7-6.09v.03H2c-1.1 0-2-.9-2-2v-5a2 2 0 0 1 2-2h3zm11.95-.89A6.96 6.96 0 0 1 19 12c0 1.87-.73 3.63-2.05 4.95-.24.24-.56.36-.88.36-.32 0-.64-.12-.89-.36a1.25 1.25 0 0 1 0-1.77c.85-.85 1.32-1.98 1.32-3.18 0-1.2-.47-2.33-1.32-3.18a1.25 1.25 0 0 1 0-1.77 1.25 1.25 0 0 1 1.77 0z';

  var speech = 'M12 0C5.85 0 .75 4.94.75 11.08c0 2.7.9 5.24 2.7 7.19L2.1 23.51c-.15.3.3.6.6.45l5.25-2.55c1.35.45 2.7.75 4.05.75 6.15 0 11.25-4.94 11.25-11.08S18.15 0 12 0';

  var speechEllipsis = 'M18 12.5a1.5 1.5 0 1 1 .001-3.001A1.5 1.5 0 0 1 18 12.5m-6 0a1.5 1.5 0 1 1 .001-3.001A1.5 1.5 0 0 1 12 12.5m-6 0a1.5 1.5 0 1 1 .001-3.001A1.5 1.5 0 0 1 6 12.5M12 0C5.925 0 1 4.925 1 11c0 2.653.94 5.086 2.504 6.986L2 24l5.336-3.049A10.93 10.93 0 0 0 12 22c6.075 0 11-4.925 11-11S18.075 0 12 0';

  var star = 'M22.46 10.736l-5.237 4.044 1.964 6.424c.393 1.285-1.079 2.323-2.136 1.506L12 18.81l-5.051 3.9c-1.057.817-2.529-.221-2.135-1.506l1.963-6.424-5.237-4.044c-1.039-.802-.477-2.48.83-2.48h6.402l1.921-6.282c.398-1.3 2.216-1.3 2.614 0l1.921 6.283h6.402c1.308 0 1.869 1.677.83 2.479';

  var switchAccount = 'M7.184 22.56a1.5 1.5 0 0 0-.002-2.121l-1.442-1.44 8.76-.003a1.5 1.5 0 1 0-.001-3l-8.755.003 1.437-1.44a1.5 1.5 0 1 0-2.123-2.118L0 17.508l5.063 5.054a1.5 1.5 0 0 0 2.121-.002m9.637-10.998a1.501 1.501 0 0 1-.002-2.121L18.256 8 9.5 8.005a1.5 1.5 0 0 1-.001-3L18.26 5l-1.442-1.44a1.494 1.494 0 0 1-.441-1.061 1.498 1.498 0 0 1 2.56-1.061L24 6.493l-5.058 5.067a1.5 1.5 0 0 1-2.121.002';

  var tag = 'M6 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m7.36-6.2l8.84 8.84a2.71 2.71 0 0 1 0 3.85l-7.71 7.71a2.71 2.71 0 0 1-3.85 0L1.8 13.36c-.51-.51-.8-1.2-.8-1.92V3.73C1 2.22 2.22 1 3.73 1h7.71c.72 0 1.41.29 1.92.8';

  var terms = 'M21 18H11a2 2 0 1 0 0 4h10a2 2 0 1 0 0-4M4 17a3 3 0 1 0 0 6 3 3 0 0 0 0-6m17-7H11a2 2 0 1 0 0 4h10a2 2 0 1 0 0-4M4 9a3 3 0 1 0 0 6 3 3 0 0 0 0-6m7-3h10a2 2 0 1 0 0-4H11a2 2 0 1 0 0 4M7 4a3 3 0 1 1-6 0 3 3 0 0 1 6 0';

  var textAlignCenter = 'M0 4.5h24v-3H0v3zm3 6h18V7.499H3V10.5zm-3 6h24v-3H0v3zm3 6h18v-3H3v3z';

  var textAlignLeft = 'M0 4.5h24v-3H0v3zm0 6h18V7.499H0V10.5zm0 6h24v-3H0v3zm0 6h18v-3H0v3z';

  var textAlignRight = 'M24 4.5H0v-3h24v3zm0 6H6v-3h18v3zm0 6H0v-3h24v3zm0 6H6v-3h18v3z';

  var textAllCaps = 'M16.774 13.704L18.5 9.689l1.726 4.015h-3.453zm7.13 2.948L19.509 6.426A1.102 1.102 0 0 0 18.5 5.75c-.436 0-.831.265-1.008.676l-4.398 10.226a1.152 1.152 0 0 0 .56 1.5c.146.066.297.098.447.098.423 0 .826-.253 1.008-.676l.687-1.597h5.407l.687 1.597c.247.573.897.833 1.454.578.556-.255.807-.926.56-1.5zm-20.13-2.948L5.5 9.689l1.726 4.015H3.774zm2.734-7.278A1.102 1.102 0 0 0 5.5 5.75c-.436 0-.831.265-1.008.676L.095 16.652a1.152 1.152 0 0 0 .56 1.5c.146.066.297.098.447.098.423 0 .826-.253 1.008-.676l.687-1.597h5.407l.687 1.597c.247.573.897.833 1.454.578.556-.255.807-.926.56-1.5L6.508 6.426z';

  var textExtraSmall = 'M2.25 11.5a1.25 1.25 0 0 1 0-2.5h19.5a1.25 1.25 0 0 1 0 2.5H2.25zm19.5 9a1.25 1.25 0 0 1 0 2.5H2.25a1.25 1.25 0 0 1 0-2.5h19.5zM12 13c.218 0 .416.127.504.324l2.199 4.91A.545.545 0 0 1 14.2 19a.55.55 0 0 1-.504-.325l-.344-.766h-2.703l-.344.766a.553.553 0 0 1-.727.278.543.543 0 0 1-.28-.72l2.198-4.909A.553.553 0 0 1 12 13zm-.863 3.818h1.727L12 14.891l-.863 1.927z';

  var textLarge = 'M2.25 3.5a1.25 1.25 0 0 1 0-2.5h19.5a1.25 1.25 0 0 1 0 2.5H2.25zm19.5 17a1.25 1.25 0 0 1 0 2.5H2.25a1.25 1.25 0 0 1 0-2.5h19.5zM12 5c.508 0 .968.297 1.174.757l5.131 11.454a1.266 1.266 0 0 1-.654 1.678 1.288 1.288 0 0 1-1.696-.647l-.8-1.788h-6.31l-.8 1.788a1.29 1.29 0 0 1-1.697.647 1.266 1.266 0 0 1-.654-1.678l5.13-11.454C11.03 5.297 11.491 5 12 5zm-2.014 8.908h4.027L12 9.413l-2.014 4.495z';

  var textLineHeight = 'M16 9l-4-4-4 4h2.5v6H8l4 4 4-4h-2.5V9H16zm5.75 11.5H2.25a1.25 1.25 0 0 0 0 2.5h19.5a1.25 1.25 0 0 0 0-2.5zM1 2.25C1 1.56 1.56 1 2.25 1h19.5a1.25 1.25 0 0 1 0 2.5H2.25C1.56 3.5 1 2.94 1 2.25z';

  var textMedium = 'M2.25 6.5a1.25 1.25 0 0 1 0-2.5h19.5a1.25 1.25 0 0 1 0 2.5H2.25zm19.5 14a1.25 1.25 0 0 1 0 2.5H2.25a1.25 1.25 0 0 1 0-2.5h19.5zM12 8c.399 0 .762.232.923.595l4.032 9a.996.996 0 0 1-.515 1.319 1.013 1.013 0 0 1-1.333-.51L14.479 17H9.522l-.629 1.404a1.014 1.014 0 0 1-1.333.51.996.996 0 0 1-.515-1.319l4.031-9A1.01 1.01 0 0 1 12 8zm-1.582 7h3.164L12 11.467 10.418 15z';

  var textSentenceCase = 'M19.793 16.028h-2.759a.831.831 0 0 1-.827-.833c0-.46.371-.834.827-.834h2.759v1.667zm-.828-7.778h-3.31c-.609 0-1.103.498-1.103 1.111 0 .614.494 1.111 1.103 1.111h3.31c.457 0 .828.374.828.834v.833h-2.759c-1.673 0-3.034 1.371-3.034 3.056s1.361 3.055 3.034 3.055h3.862c.61 0 1.104-.497 1.104-1.111v-5.833c0-1.685-1.362-3.056-3.035-3.056zM5.774 13.705L7.5 9.69l1.726 4.015H5.774zm7.131 2.948L8.507 6.426A1.1 1.1 0 0 0 7.5 5.75a1.1 1.1 0 0 0-1.007.676L2.095 16.653c-.247.574.004 1.245.561 1.499.145.067.296.098.446.098.422 0 .825-.252 1.008-.676l.686-1.597h5.408l.686 1.597c.247.574.897.833 1.454.578.557-.254.808-.925.561-1.499z';

  var textSize = 'M2.916 16.545l1.334-3.051 1.334 3.051H2.916zm2.112-5.532a.85.85 0 0 0-.778-.513.852.852 0 0 0-.78.513L.074 18.786a.869.869 0 0 0 .434 1.139.846.846 0 0 0 1.123-.439l.53-1.214H6.34l.53 1.214a.852.852 0 0 0 .78.514.844.844 0 0 0 .344-.075.869.869 0 0 0 .434-1.139l-3.4-7.773zm9.446 3.168l2.276-5.138 2.276 5.138h-4.552zm9.4 3.774l-5.796-13.09a1.453 1.453 0 0 0-2.656 0l-5.797 13.09a1.455 1.455 0 0 0 .739 1.919 1.451 1.451 0 0 0 1.917-.74l.905-2.044h7.128l.905 2.044a1.453 1.453 0 1 0 2.656-1.179z';

  var textSmall = 'M2.25 9.5a1.25 1.25 0 0 1 0-2.5h19.5a1.25 1.25 0 0 1 0 2.5H2.25zm19.5 11a1.25 1.25 0 0 1 0 2.5H2.25a1.25 1.25 0 0 1 0-2.5h19.5zM12 11c.29 0 .554.169.671.433l2.932 6.545a.724.724 0 0 1-.67 1.022.735.735 0 0 1-.673-.432l-.458-1.023h-3.604l-.458 1.023a.74.74 0 0 1-.97.37.725.725 0 0 1-.374-.96l2.932-6.545A.734.734 0 0 1 12 11zm-1.15 5.09h2.301l-1.15-2.568-1.152 2.569z';

  var textSpacing = 'M20 15l4 4-4 4v-2.5H4V23l-4-4 4-4v2.5h16V15zM5.5 4.782l1.727 3.854H3.774L5.5 4.782zM.656 12.906a1.104 1.104 0 0 0 1.454-.555l.686-1.533h5.408l.686 1.533c.247.551.897.8 1.454.555.557-.244.808-.889.561-1.44L6.508 1.649A1.103 1.103 0 0 0 5.5 1a1.1 1.1 0 0 0-1.007.649L.095 11.466a1.087 1.087 0 0 0 .561 1.44zm15.526-4.815h4.273a1.365 1.365 0 0 1 0 2.727h-4.273V8.091zm0-4.909h3.727c.752 0 1.364.612 1.364 1.363 0 .752-.612 1.364-1.364 1.364h-3.727V3.182zM15.091 13h5.364A3.55 3.55 0 0 0 24 9.455a3.54 3.54 0 0 0-1.295-2.738c.468-.6.75-1.353.75-2.172A3.55 3.55 0 0 0 19.909 1h-4.818A1.09 1.09 0 0 0 14 2.091v9.818A1.09 1.09 0 0 0 15.091 13z';

  var trashCan = 'M4.878 22.116A2 2 0 0 0 6.875 24h10.229a2 2 0 0 0 1.995-1.881L20 7H4l.88 15.116zM22 3.5A1.5 1.5 0 0 1 20.5 5h-17a1.5 1.5 0 0 1 0-3h6V1a1 1 0 0 1 1-1h3a1 1 0 0 1 1 1v1h6A1.5 1.5 0 0 1 22 3.5z';

  var twitter = 'M7.548 21.5c9.056 0 14.01-7.31 14.01-13.65 0-.208 0-.414-.015-.62A9.88 9.88 0 0 0 24 4.747c-.899.388-1.852.642-2.828.754a4.838 4.838 0 0 0 2.165-2.653c-.967.559-2.024.953-3.127 1.164-1.526-1.58-3.952-1.968-5.916-.944-1.964 1.025-2.98 3.205-2.475 5.32C7.859 8.194 4.17 6.372 1.67 3.375.363 5.567 1.031 8.372 3.195 9.78a4.986 4.986 0 0 1-2.235-.6v.06c0 2.284 1.653 4.25 3.95 4.703a5.042 5.042 0 0 1-2.223.082c.645 1.954 2.494 3.293 4.6 3.332A10.048 10.048 0 0 1 0 19.345a14.21 14.21 0 0 0 7.548 2.151';

  var videoCamera = 'M16 8v8c0 1.1-.9 2-2 2H3c-1.1 0-2-.9-2-2V8c0-1.1.9-2 2-2h11c1.1 0 2 .9 2 2zm6.18-.38l-3.67 3.26a1.5 1.5 0 0 0 0 2.24l3.67 3.26c.32.28.82.04.82-.39V8.01c0-.43-.5-.67-.82-.39z';

  var viewTypeDefault = 'M13.5 24V13.5H24V24H13.5zM0 10.5V0h10.5v10.5H0zm13.5 0V0H24v10.5H13.5zM0 24V13.5h10.5V24H0z';

  var viewTypeDense = 'M17.999 24H24v-6h-6.001v6zm-9-17.999V0h6v6.001H9zM0 6.001V0h6v6.001H0zm17.999 0V0H24v6.001h-6.001zM0 15.001V9h6v6H0zm9 0V9h6v6H9zm8.999 0V9H24v6h-6.001zM0 24v-6h6v6H0zm9 0v-6h6v6H9z';

  var viewTypeList = 'M0 13.502v-3h24v3H0zm0-7.5V3h24v3.002H0zm0 15v-3h24v3H0z';

  var icons = {
    add: add,
    'add-circle': addCircle,
    'add-pin': addPin,
    alert: alert,
    'align-bottom-center': alignBottomCenter,
    'align-bottom-left': alignBottomLeft,
    'align-bottom-right': alignBottomRight,
    'align-bottom': alignBottom,
    'align-middle': alignMiddle,
    'align-top-center': alignTopCenter,
    'align-top-left': alignTopLeft,
    'align-top-right': alignTopRight,
    'align-top': alignTop,
    'angled-pin': angledPin,
    apps: apps,
    'arrow-back': arrowBack,
    'arrow-circle-down': arrowCircleDown,
    'arrow-circle-forward': arrowCircleForward,
    'arrow-circle-up': arrowCircleUp,
    'arrow-down': arrowDown,
    'arrow-forward': arrowForward,
    'arrow-up': arrowUp,
    'arrow-up-right': arrowUpRight,
    bell: bell,
    camera: camera,
    'camera-roll': cameraRoll,
    cancel: cancel,
    'canonical-pin': canonicalPin,
    'color-picker': colorPicker,
    check: check,
    'check-circle': checkCircle,
    'circle-outline': circleOutline,
    clear: clear,
    clock: clock,
    cog: cog,
    compass: compass,
    compose: compose,
    crop: crop,
    dash: dash,
    download: download,
    edit: edit,
    ellipsis: ellipsis,
    'ellipsis-circle-outline': ellipsisCircleOutline,
    envelope: envelope,
    eye: eye,
    facebook: facebook,
    'face-happy': faceHappy,
    'face-sad': faceSad,
    'face-smiley': faceSmiley,
    'fill-opaque': fillOpaque,
    'fill-transparent': fillTransparent,
    filter: filter,
    flag: flag,
    flashlight: flashlight,
    flipHorizontal: flipHorizontal,
    flipVertical: flipVertical,
    gif: gif,
    globe: globe,
    'globe-checked': globeChecked,
    gmail: gmail,
    'google-plus': googlePlus,
    'graph-bar': graphBar,
    handle: handle,
    'hand-pointing': handPointing,
    heart: heart,
    'heart-broken': heartBroken,
    impressum: impressum,
    knoop: knoop,
    lightbulb: lightbulb,
    link: link,
    location: location,
    lock: lock,
    'logo-large': logoLarge,
    'logo-small': logoSmall,
    logout: logout,
    'margins-large': marginsLarge,
    'margins-medium': marginsMedium,
    'margins-small': marginsSmall,
    maximize: maximize,
    megaphone: megaphone,
    menu: menu,
    minimize: minimize,
    move: move,
    mute: mute,
    'overlay-text': overlayText,
    pause: pause,
    people: people,
    person: person,
    'person-add': personAdd,
    pin: pin,
    'pin-hide': pinHide,
    pinterest: pinterest,
    play: play,
    'question-mark': questionMark,
    remove: remove,
    'reorder-images': reorderImages,
    report: report,
    rotate: rotate,
    search: search,
    security: security,
    'shopping-bag': shoppingBag,
    smiley: smiley,
    'smiley-outline': smileyOutline,
    send: send,
    share: share,
    sound: sound,
    speech: speech,
    'speech-ellipsis': speechEllipsis,
    star: star,
    'switch-account': switchAccount,
    tag: tag,
    terms: terms,
    'text-align-left': textAlignLeft,
    'text-align-center': textAlignCenter,
    'text-align-right': textAlignRight,
    'text-all-caps': textAllCaps,
    'text-extra-small': textExtraSmall,
    'text-large': textLarge,
    'text-line-height': textLineHeight,
    'text-medium': textMedium,
    'text-sentence-case': textSentenceCase,
    'text-size': textSize,
    'text-small': textSmall,
    'text-spacing': textSpacing,
    'trash-can': trashCan,
    twitter: twitter,
    'video-camera': videoCamera,
    'view-type-default': viewTypeDefault,
    'view-type-dense': viewTypeDense,
    'view-type-list': viewTypeList
  };

  var IconNames = Object.keys(icons);

  function Icon(props) {
    var accessibilityLabel = props.accessibilityLabel,
        _props$color = props.color,
        color = _props$color === undefined ? 'gray' : _props$color,
        dangerouslySetSvgPath = props.dangerouslySetSvgPath,
        icon = props.icon,
        inline = props.inline,
        _props$size = props.size,
        size = _props$size === undefined ? 16 : _props$size;


    var cs = classnames(styles$1.icon, colors[color], defineProperty({}, styles$1.iconBlock, !inline));

    var path = icon && icons[icon] ||
    /* eslint-disable-next-line no-underscore-dangle */
    dangerouslySetSvgPath && dangerouslySetSvgPath.__path || undefined;

    var ariaHidden = accessibilityLabel === '' ? true : null;

    return React.createElement(
      'svg',
      {
        className: cs,
        height: size,
        width: size,
        viewBox: '0 0 24 24',
        'aria-hidden': ariaHidden,
        'aria-label': accessibilityLabel,
        role: 'img'
      },
      React.createElement('path', { d: path })
    );
  }

  Icon.icons = IconNames;

  Icon.propTypes = {
    accessibilityLabel: PropTypes.string.isRequired,
    color: PropTypes.oneOf(['blue', 'darkGray', 'eggplant', 'gray', 'green', 'lightGray', 'maroon', 'midnight', 'navy', 'olive', 'orange', 'orchid', 'pine', 'purple', 'red', 'watermelon', 'white']),
    dangerouslySetSvgPath: PropTypes.shape({
      __path: PropTypes.string
    }),
    icon: PropTypes.oneOf(IconNames),
    inline: PropTypes.bool,
    size: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
  };

  var styles$2 = { "img": "hCL kVc L4E MIw", "scaled-img": "PC4 XiG", "contain": "Jwr PC4 XiG", "cover": "zIH PC4 XiG" };

  var shouldScaleImage = function shouldScaleImage(fit) {
    return fit === 'cover' || fit === 'contain';
  };

  var Image = function (_React$PureComponent) {
    inherits(Image, _React$PureComponent);

    function Image() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Image);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Image.__proto__ || Object.getPrototypeOf(Image)).call.apply(_ref, [this].concat(args))), _this), _this.handleLoad = function () {
        if (_this.props.onLoad) {
          _this.props.onLoad();
        }
      }, _this.handleError = function () {
        if (_this.props.onError) {
          _this.props.onError();
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Image, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        if (shouldScaleImage(this.props.fit)) {
          this.loadImage();
        }
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps) {
        var _props = this.props,
            fit = _props.fit,
            src = _props.src;

        if (shouldScaleImage(fit) && prevProps.src !== src) {
          this.loadImage();
        }
      }
    }, {
      key: 'loadImage',
      value: function loadImage() {
        if (typeof window !== 'undefined') {
          var image = new window.Image();
          image.onload = this.handleLoad;
          image.onerror = this.handleError;
          image.src = this.props.src;
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var _props2 = this.props,
            alt = _props2.alt,
            color = _props2.color,
            children = _props2.children,
            fit = _props2.fit,
            naturalHeight = _props2.naturalHeight,
            naturalWidth = _props2.naturalWidth,
            sizes = _props2.sizes,
            src = _props2.src,
            srcSet = _props2.srcSet;


        var isScaledImage = shouldScaleImage(fit);
        var childContent = children ? React.createElement(
          Box,
          { position: 'absolute', top: true, left: true, bottom: true, right: true, overflow: 'hidden' },
          children
        ) : null;

        return isScaledImage ? React.createElement(
          'div',
          {
            'aria-label': alt,
            className: styles$2[fit],
            style: {
              backgroundColor: color,
              backgroundImage: 'url(\'' + src + '\')'
            },
            role: 'img'
          },
          childContent
        ) : React.createElement(
          Box,
          {
            position: 'relative',
            dangerouslySetInlineStyle: {
              __style: {
                backgroundColor: color,
                paddingBottom: naturalHeight / naturalWidth * 100 + '%'
              }
            }
          },
          React.createElement('img', {
            alt: alt,
            className: styles$2.img,
            onError: this.handleError,
            onLoad: this.handleLoad,
            sizes: sizes,
            src: src,
            srcSet: srcSet
          }),
          childContent
        );
      }
    }]);
    return Image;
  }(React.PureComponent);

  Image.propTypes = {
    alt: PropTypes.string.isRequired,
    children: PropTypes.node,
    color: PropTypes.string,
    fit: PropTypes.oneOf(['contain', 'cover', 'none']),
    naturalHeight: PropTypes.number.isRequired,
    naturalWidth: PropTypes.number.isRequired,
    onError: PropTypes.func,
    onLoad: PropTypes.func,
    sizes: PropTypes.string,
    src: PropTypes.string.isRequired,
    srcSet: PropTypes.string
  };
  Image.defaultProps = {
    color: 'transparent',
    fit: 'none'
  };

  var styles$3 = { "Mask": "Pj7 sLG XiG", "willChangeTransform": "m1e", "square": "sjM gL3", "rounded": "ZKv mix", "circle": "pJI INd", "wash": "KPc MIw ojN Rym p6V QLY" };

  function Mask(props) {
    var children = props.children,
        _props$shape = props.shape,
        shape = _props$shape === undefined ? 'square' : _props$shape,
        width = props.width,
        height = props.height,
        _props$willChangeTran = props.willChangeTransform,
        willChangeTransform = _props$willChangeTran === undefined ? true : _props$willChangeTran,
        _props$wash = props.wash,
        wash = _props$wash === undefined ? false : _props$wash;

    return React.createElement(
      'div',
      {
        className: classnames(styles$3.Mask, styles$3[shape], defineProperty({}, styles$3.willChangeTransform, willChangeTransform)),
        style: { width: width, height: height }
      },
      children,
      wash && React.createElement('div', { className: styles$3.wash })
    );
  }

  Mask.propTypes = {
    children: PropTypes.node,
    height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    shape: PropTypes.oneOf(['circle', 'rounded', 'square']),
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    willChangeTransform: PropTypes.bool,
    wash: PropTypes.bool
  };

  var typography = { "antialiased": "dyH", "sansSerif": "iFc", "letterSpacing": "SMy", "leadingShort": "hK1", "leadingTall": "fqb", "fontWeightNormal": "swG", "fontWeightBold": "mWe", "fontStyleRegular": "VEk", "fontStyleItalic": "SVm", "underline": "R7a", "noUnderline": "xQ4", "breakWord": "IZT", "truncate": "z-6", "alignLeft": "DrD", "alignRight": "J0X", "alignCenter": "tg7", "textJustify": "vdG" };

  var Square = function Square(props) {
    return React.createElement(
      Box,
      _extends({}, props, { position: 'relative' }),
      React.createElement(Box, {
        dangerouslySetInlineStyle: { __style: { paddingBottom: '100%' } },
        position: 'relative'
      }),
      React.createElement(
        Box,
        { position: 'absolute', top: true, left: true, bottom: true, right: true },
        props.children
      )
    );
  };

  var DefaultAvatar = function DefaultAvatar(_ref) {
    var name = _ref.name;

    var firstInitial = name ? [].concat(toConsumableArray(name))[0].toUpperCase() : '';
    return React.createElement(
      Square,
      { color: 'gray', shape: 'circle' },
      firstInitial && React.createElement(
        'svg',
        {
          width: '100%',
          viewBox: '-50 -50 100 100',
          version: '1.1',
          preserveAspectRatio: 'xMidYMid meet',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        React.createElement(
          'title',
          null,
          name
        ),
        React.createElement(
          'text',
          {
            fontSize: '50px',
            fill: '#fff',
            dy: '0.35em',
            textAnchor: 'middle',
            className: [typography.antialiased, typography.sansSerif, typography.leadingSmall, typography.fontWeightBold].join(' ')
          },
          firstInitial
        )
      )
    );
  };

  var sizes = {
    sm: 24,
    md: 40,
    lg: 72
  };

  var Avatar = function (_React$PureComponent) {
    inherits(Avatar, _React$PureComponent);

    function Avatar() {
      var _ref2;

      var _temp, _this, _ret;

      classCallCheck(this, Avatar);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref2 = Avatar.__proto__ || Object.getPrototypeOf(Avatar)).call.apply(_ref2, [this].concat(args))), _this), _this.state = {
        isImageLoaded: true
      }, _this.handleImageError = function () {
        return _this.setState({ isImageLoaded: false });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Avatar, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            name = _props.name,
            outline = _props.outline,
            size = _props.size,
            src = _props.src,
            verified = _props.verified,
            _props$icon = _props.icon,
            icon = _props$icon === undefined ? 'check-circle' : _props$icon;
        var isImageLoaded = this.state.isImageLoaded;

        var width = size ? sizes[size] : '100%';
        var height = size ? sizes[size] : '';

        return React.createElement(
          Box,
          _extends({
            color: 'white'
          }, outline ? {
            dangerouslySetInlineStyle: {
              __style: {
                boxShadow: '0 0 0 2px #fff'
              }
            }
          } : {}, {
            width: width,
            height: height,
            position: 'relative',
            shape: 'circle'
          }),
          src && isImageLoaded ? React.createElement(
            Mask,
            { shape: 'circle', wash: true },
            React.createElement(Image, {
              alt: name,
              color: '#EFEFEF',
              naturalHeight: 1,
              naturalWidth: 1,
              src: src,
              onError: this.handleImageError
            })
          ) : React.createElement(DefaultAvatar, { name: name }),
          verified && React.createElement(
            Box,
            {
              position: 'absolute',
              width: '20%',
              height: '20%',
              minWidth: 8,
              minHeight: 8,
              dangerouslySetInlineStyle: {
                __style: {
                  bottom: '4%',
                  right: '4%'
                }
              }
            },
            React.createElement(
              Box,
              {
                color: 'white',
                width: '100%',
                height: '100%',
                shape: 'circle',
                dangerouslySetInlineStyle: {
                  __style: {
                    boxShadow: '0 0 0 2px #fff'
                  }
                }
              },
              React.createElement(Icon, { color: 'red', icon: icon, accessibilityLabel: '', size: '100%' })
            )
          )
        );
      }
    }]);
    return Avatar;
  }(React.PureComponent);

  Avatar.propTypes = {
    name: PropTypes.string.isRequired,
    outline: PropTypes.bool,
    src: PropTypes.string,
    size: PropTypes.oneOf(['sm', 'md', 'lg']),
    verified: PropTypes.bool
  };

  var styles$4 = { "Badge": "bI_ dyH iFc SMy mWe mi- undefined KhY", "middle": "buY", "top": "DP5" };

  function Badge(props) {
    var _props$position = props.position,
        position = _props$position === undefined ? 'middle' : _props$position,
        text = props.text;

    var cs = classnames(styles$4.Badge, styles$4[position]);

    return React.createElement(
      'span',
      { className: cs },
      text
    );
  }

  Badge.propTypes = {
    position: PropTypes.oneOf(['middle', 'top']),
    text: PropTypes.string.isRequired
  };

  var styles$5 = { "button": "RCK Hsu", "solid": "GmH adn", "enabled": "hNT iyn BG7", "sm": "DZT I56", "md": "Vxj aZc", "lg": "F10 xD4", "block": "gn8 L4E kVc", "inline": "NTm KhY", "disabled": "OWt gpV", "gray": "a_A gpV", "red": "Il7 Jrn", "blue": "sKP rTt", "transparent": "qQ7 YbY", "white": "bmw qJc" };

  var styles$6 = { "Text": "tBJ dyH iFc SMy", "fontSize1": "_yT", "fontSize2": "MF7", "fontSize3": "yTZ", "fontSize4": "_S5", "fontSize5": "SNs", "smFontSize1": "ynV", "smFontSize2": "yYI", "smFontSize3": "YPV", "smFontSize4": "r-l", "smFontSize5": "yu4", "mdFontSize1": "ZX8", "mdFontSize2": "Kat", "mdFontSize3": "Reg", "mdFontSize4": "iHx", "mdFontSize5": "BVY", "lgFontSize1": "tzu", "lgFontSize2": "jOo", "lgFontSize3": "s27", "lgFontSize4": "Ue2", "lgFontSize5": "gps" };

  var SIZE_SCALE = {
    xs: 1,
    sm: 2,
    md: 3,
    lg: 4,
    xl: 5
  };

  function Text(_ref) {
    var _ref$align = _ref.align,
        align = _ref$align === undefined ? 'left' : _ref$align,
        _ref$bold = _ref.bold,
        bold = _ref$bold === undefined ? false : _ref$bold,
        children = _ref.children,
        _ref$color = _ref.color,
        color = _ref$color === undefined ? 'darkGray' : _ref$color,
        _ref$inline = _ref.inline,
        inline = _ref$inline === undefined ? false : _ref$inline,
        _ref$italic = _ref.italic,
        italic = _ref$italic === undefined ? false : _ref$italic,
        _ref$overflow = _ref.overflow,
        overflow = _ref$overflow === undefined ? 'breakWord' : _ref$overflow,
        _ref$size = _ref.size,
        size = _ref$size === undefined ? 'md' : _ref$size,
        smSize = _ref.smSize,
        mdSize = _ref.mdSize,
        lgSize = _ref.lgSize,
        leading = _ref.leading,
        _ref$truncate = _ref.truncate,
        truncate = _ref$truncate === undefined ? false : _ref$truncate,
        _ref$__dangerouslyInc = _ref.__dangerouslyIncreaseLineHeight,
        __dangerouslyIncreaseLineHeight = _ref$__dangerouslyInc === undefined ? false : _ref$__dangerouslyInc;

    var scale = SIZE_SCALE[size];
    var smScale = SIZE_SCALE[smSize];
    var mdScale = SIZE_SCALE[mdSize];
    var lgScale = SIZE_SCALE[lgSize];

    var cs = classnames(styles$6.Text, styles$6['fontSize' + scale], lgSize && styles$6['lgFontSize' + lgScale], mdSize && styles$6['mdFontSize' + mdScale], smSize && styles$6['smFontSize' + smScale], color === 'blue' && colors.blue, color === 'darkGray' && colors.darkGray, color === 'eggplant' && colors.eggplant, color === 'gray' && colors.gray, color === 'green' && colors.green, color === 'lightGray' && colors.lightGray, color === 'maroon' && colors.maroon, color === 'midnight' && colors.midnight, color === 'navy' && colors.navy, color === 'olive' && colors.olive, color === 'orange' && colors.orange, color === 'orchid' && colors.orchid, color === 'pine' && colors.pine, color === 'purple' && colors.purple, color === 'red' && colors.red, color === 'watermelon' && colors.watermelon, color === 'white' && colors.white, leading === 'short' && typography.leadingShort, (leading === 'tall' || __dangerouslyIncreaseLineHeight) && typography.leadingTall, align === 'center' && typography.alignCenter, align === 'justify' && typography.alignJustify, align === 'left' && typography.alignLeft, align === 'right' && typography.alignRight, overflow === 'breakWord' && typography.breakWord, italic && typography.fontStyleItalic, !italic && typography.fontStyleNormal, bold && typography.fontWeightBold, !bold && typography.fontWeightNormal, truncate && typography.truncate);
    var Tag = inline ? 'span' : 'div';

    return React.createElement(
      Tag,
      _extends({
        className: cs
      }, truncate && typeof children === 'string' ? { title: children } : null),
      children
    );
  }

  Text.propTypes = {
    __dangerouslyIncreaseLineHeight: PropTypes.bool,
    align: PropTypes.oneOf(['left', 'right', 'center', 'justify']),
    bold: PropTypes.bool,
    children: PropTypes.node,
    color: PropTypes.oneOf(['green', 'pine', 'olive', 'blue', 'navy', 'midnight', 'purple', 'orchid', 'eggplant', 'maroon', 'watermelon', 'orange', 'darkGray', 'gray', 'lightGray', 'red', 'white']),
    inline: PropTypes.bool,
    italic: PropTypes.bool,
    leading: PropTypes.oneOf(['tall', 'short']),
    lgSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
    mdSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
    overflow: PropTypes.oneOf(['normal', 'breakWord']),
    size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
    smSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
    truncate: PropTypes.bool
  };

  function Button(props) {
    var _classnames;

    var accessibilityExpanded = props.accessibilityExpanded,
        accessibilityHaspopup = props.accessibilityHaspopup,
        accessibilityLabel = props.accessibilityLabel,
        _props$color = props.color,
        color = _props$color === undefined ? 'gray' : _props$color,
        _props$disabled = props.disabled,
        disabled = _props$disabled === undefined ? false : _props$disabled,
        _props$inline = props.inline,
        inline = _props$inline === undefined ? false : _props$inline,
        name = props.name,
        onClick = props.onClick,
        _props$size = props.size,
        size = _props$size === undefined ? 'md' : _props$size,
        text = props.text,
        _props$type = props.type,
        type = _props$type === undefined ? 'button' : _props$type;


    var textColor = {
      blue: 'white',
      gray: 'darkGray',
      red: 'white',
      transparent: 'white',
      white: 'darkGray'
    };

    var classes = classnames(styles$5.button, (_classnames = {}, defineProperty(_classnames, styles$5.sm, size === 'sm'), defineProperty(_classnames, styles$5.md, size === 'md'), defineProperty(_classnames, styles$5.lg, size === 'lg'), defineProperty(_classnames, styles$5.solid, color !== 'transparent'), defineProperty(_classnames, styles$5[color], !disabled), defineProperty(_classnames, styles$5.disabled, disabled), defineProperty(_classnames, styles$5.enabled, !disabled), defineProperty(_classnames, styles$5.inline, inline), defineProperty(_classnames, styles$5.block, !inline), defineProperty(_classnames, borderStyles.radiusLarge, !inline), defineProperty(_classnames, borderStyles.radiusSmall, inline), _classnames));

    /* eslint-disable react/button-has-type */
    return React.createElement(
      'button',
      {
        'aria-expanded': accessibilityExpanded,
        'aria-haspopup': accessibilityHaspopup,
        'aria-label': accessibilityLabel,
        className: classes,
        disabled: disabled,
        name: name,
        onClick: function (_onClick) {
          function onClick(_x) {
            return _onClick.apply(this, arguments);
          }

          onClick.toString = function () {
            return _onClick.toString();
          };

          return onClick;
        }(function (event) {
          return onClick && onClick({ event: event });
        }),
        type: type
      },
      React.createElement(
        Text,
        {
          align: 'center',
          bold: true,
          color: disabled ? 'gray' : textColor[color],
          overflow: 'normal',
          size: size
        },
        text
      )
    );
    /* eslint-enable react/button-has-type */
  }

  Button.propTypes = {
    accessibilityExpanded: PropTypes.bool,
    accessibilityHaspopup: PropTypes.bool,
    accessibilityLabel: PropTypes.string,
    color: PropTypes.oneOf(['blue', 'gray', 'red', 'transparent', 'white']),
    disabled: PropTypes.bool,
    inline: PropTypes.bool,
    name: PropTypes.string,
    onClick: PropTypes.func,
    size: PropTypes.oneOf(['sm', 'md', 'lg']),
    text: PropTypes.string.isRequired,
    type: PropTypes.oneOf(['button', 'submit'])
  };

  var styles$7 = { "card": "X-y MIw mix QLY p6V ojN Rym jr-", "hover": "ocv", "animateIn": "mCQ" };

  var Card = function (_React$Component) {
    inherits(Card, _React$Component);

    function Card() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Card);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Card.__proto__ || Object.getPrototypeOf(Card)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        hovered: false
      }, _this.handleMouseEnter = function (event) {
        var onMouseEnter = _this.props.onMouseEnter;

        _this.setState({ hovered: true }, onMouseEnter && function () {
          return onMouseEnter({ event: event });
        });
      }, _this.handleMouseLeave = function (event) {
        var onMouseLeave = _this.props.onMouseLeave;

        _this.setState({ hovered: false }, onMouseLeave && function () {
          return onMouseLeave({ event: event });
        });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Card, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            active = _props.active,
            children = _props.children,
            image = _props.image;
        var hovered = this.state.hovered;


        var classes = classnames(styles$7.card, defineProperty({}, styles$7.hover, active || active == null && hovered));

        return React.createElement(
          Box,
          {
            onMouseEnter: this.handleMouseEnter,
            onMouseLeave: this.handleMouseLeave,
            position: 'relative'
          },
          image && React.createElement(
            Box,
            { marginBottom: 1 },
            image
          ),
          React.createElement(
            Box,
            null,
            children
          ),
          React.createElement('div', { className: classes })
        );
      }
    }]);
    return Card;
  }(React.Component);

  Card.propTypes = {
    active: PropTypes.bool,
    children: PropTypes.node,
    image: PropTypes.node,
    onMouseEnter: PropTypes.func,
    onMouseLeave: PropTypes.func
  };

  var styles$8 = { "border": "Lur", "borderError": "fS4", "borderDark": "Z9l", "check": "QRd kVc Hsu _O1 gjz mQ8", "checkEnabled": "qP6 BG7", "checkFocused": "Kji C1J", "checkSm": "Tp1", "checkMd": "i3-", "input": "cb7 MIw e43", "inputEnabled": "F7p BG7", "inputSm": "fat", "inputMd": "O2s" };

  var Checkbox = function (_React$Component) {
    inherits(Checkbox, _React$Component);

    function Checkbox() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Checkbox);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Checkbox.__proto__ || Object.getPrototypeOf(Checkbox)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        focused: false
      }, _this.handleChange = function (event) {
        var checked = event.target.checked;

        _this.props.onChange({ event: event, checked: checked });
      }, _this.handleClick = function (event) {
        var onClick = _this.props.onClick;

        if (onClick) {
          var _checked = event.currentTarget.checked;

          onClick({ event: event, checked: _checked });
        }
      }, _this.handleBlur = function () {
        return _this.setState({ focused: false });
      }, _this.handleFocus = function () {
        return _this.setState({ focused: true });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Checkbox, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        if (this.props.indeterminate) {
          this.setIndeterminate(!!this.props.indeterminate);
        }
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(previousProps) {
        if (previousProps.indeterminate !== this.props.indeterminate) {
          this.setIndeterminate(!!this.props.indeterminate);
        }
      }
    }, {
      key: 'setIndeterminate',
      value: function setIndeterminate(indeterminate) {
        if (this.input) {
          this.input.indeterminate = indeterminate;
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var _classnames,
            _this2 = this,
            _classnames2;

        var _props = this.props,
            checked = _props.checked,
            disabled = _props.disabled,
            hasError = _props.hasError,
            id = _props.id,
            indeterminate = _props.indeterminate,
            name = _props.name,
            size = _props.size;


        var borderStyle = styles$8.border;
        if (!disabled && (checked || indeterminate)) {
          borderStyle = styles$8.borderDark;
        } else if (hasError) {
          borderStyle = styles$8.borderError;
        }

        return React.createElement(
          Box,
          { position: 'relative' },
          React.createElement('input', {
            checked: checked,
            className: classnames(styles$8.input, (_classnames = {}, defineProperty(_classnames, styles$8.inputEnabled, !disabled), defineProperty(_classnames, styles$8.indeterminate, indeterminate), defineProperty(_classnames, styles$8.inputSm, size === 'sm'), defineProperty(_classnames, styles$8.inputMd, size === 'md'), _classnames)),
            disabled: disabled,
            id: id,
            name: name,
            onBlur: this.handleBlur,
            onChange: this.handleChange,
            onClick: this.handleClick,
            onFocus: this.handleFocus,
            ref: function ref(el) {
              _this2.input = el;
            },
            type: 'checkbox'
          }),
          React.createElement(
            'div',
            {
              className: classnames(borderStyle, styles$8.check,
              // eslint-disable-next-line no-nested-ternary
              disabled ? checked || indeterminate ? colors.grayBg : colors.lightGrayBg : checked || indeterminate ? colors.darkGrayBg : colors.whiteBg, (_classnames2 = {}, defineProperty(_classnames2, styles$8.checkEnabled, !disabled), defineProperty(_classnames2, styles$8.checkFocused, this.state.focused), defineProperty(_classnames2, styles$8.checkMd, size === 'md'), defineProperty(_classnames2, styles$8.checkSm, size === 'sm'), _classnames2))
            },
            (checked || indeterminate) && React.createElement(Icon, {
              accessibilityLabel: '',
              color: 'white',
              icon: indeterminate ? 'dash' : 'check',
              size: size === 'sm' ? 8 : 12
            })
          )
        );
      }
    }]);
    return Checkbox;
  }(React.Component);

  Checkbox.propTypes = {
    checked: PropTypes.bool,
    disabled: PropTypes.bool,
    hasError: PropTypes.bool,
    id: PropTypes.string.isRequired,
    indeterminate: PropTypes.bool,
    name: PropTypes.string,
    onChange: PropTypes.func.isRequired,
    onClick: PropTypes.func,
    size: PropTypes.oneOf(['sm', 'md'])
  };
  Checkbox.defaultProps = {
    checked: false,
    disabled: false,
    hasError: false,
    indeterminate: false,
    size: 'md'
  };

  var Collection = function (_React$PureComponent) {
    inherits(Collection, _React$PureComponent);

    function Collection() {
      classCallCheck(this, Collection);
      return possibleConstructorReturn(this, (Collection.__proto__ || Object.getPrototypeOf(Collection)).apply(this, arguments));
    }

    createClass(Collection, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            Item = _props.Item,
            layout$$1 = _props.layout,
            _props$viewportTop = _props.viewportTop,
            viewportTop = _props$viewportTop === undefined ? 0 : _props$viewportTop,
            _props$viewportLeft = _props.viewportLeft,
            viewportLeft = _props$viewportLeft === undefined ? 0 : _props$viewportLeft;

        // Calculate the full dimensions of the item layer

        var width = Math.max.apply(Math, toConsumableArray(layout$$1.map(function (item) {
          return item.left + item.width;
        })));
        var height = Math.max.apply(Math, toConsumableArray(layout$$1.map(function (item) {
          return item.top + item.height;
        })));

        // Default the viewport to being the full width of the content layer
        var _props2 = this.props,
            _props2$viewportWidth = _props2.viewportWidth,
            viewportWidth = _props2$viewportWidth === undefined ? width : _props2$viewportWidth,
            _props2$viewportHeigh = _props2.viewportHeight,
            viewportHeight = _props2$viewportHeigh === undefined ? height : _props2$viewportHeigh;

        // Calculates which items from the item layer to render in the viewport
        // layer.

        var items = layout$$1.reduce(function (acc, position, idx) {
          if (position.top + position.height > viewportTop && position.top < viewportHeight + viewportTop && position.left < viewportWidth + viewportLeft && position.left + position.width > viewportLeft) {
            acc.push(_extends({ idx: idx }, position));
          }
          return acc;
        }, []);

        return React.createElement(
          'div',
          { className: layout.relative, style: { width: width, height: height } },
          items.map(function (_ref) {
            var idx = _ref.idx,
                style = objectWithoutProperties(_ref, ['idx']);
            return React.createElement(
              'div',
              { key: idx, className: layout.absolute, style: style },
              React.createElement(Item, { idx: idx })
            );
          })
        );
      }
    }]);
    return Collection;
  }(React.PureComponent);

  Collection.propTypes = {
    // eslint-disable-next-line react/forbid-prop-types
    Item: PropTypes.any,
    layout: PropTypes.arrayOf(PropTypes.exact({
      top: PropTypes.number.isRequired,
      left: PropTypes.number.isRequired,
      width: PropTypes.number.isRequired,
      height: PropTypes.number.isRequired
    }).isRequired),
    viewportHeight: PropTypes.number,
    viewportLeft: PropTypes.number,
    viewportTop: PropTypes.number,
    viewportWidth: PropTypes.number
  };
  Collection.defaultProps = {
    layout: [],
    viewportLeft: 0,
    viewportTop: 0
  };

  /*

  This function just implements the design constraints for asymetrical columns in
  a very simple way. It's not perfect, but it's very predictible. If you do
  anything, improve it so that it takes these constraints and generates them
  for n > 4.

  1 + n columns:
    first column is 50/50
    can't have 3 columns in a row be 50/50

  */
  var UP = [0.75, 0.25];
  var DOWN = [0.25, 0.75];
  var MID = [0.5, 0.5];
  var columnLayout = function columnLayout(numOfColumns) {
    switch (numOfColumns) {
      case 1:
        return [[MID], [UP], [DOWN]];
      case 2:
        return [[UP, MID], [DOWN, MID], [MID, UP], [MID, DOWN]];
      case 4:
        return [[MID, UP, MID, MID], [MID, DOWN, MID, MID], [MID, MID, UP, MID], [MID, MID, DOWN, MID], [MID, UP, MID, DOWN], [MID, DOWN, MID, UP]];
      case 3:
      default:
        return [[MID, UP, MID], [MID, DOWN, MID], [MID, MID, UP], [MID, MID, DOWN]];
    }
  };

  var paddingAll = function paddingAll(gutter, positions) {
    return positions.map(function (_ref) {
      var top = _ref.top,
          left = _ref.left,
          width = _ref.width,
          height = _ref.height;
      return {
        top: top,
        left: left,
        width: width - gutter,
        height: height - gutter
      };
    });
  };

  var mindex = function mindex(arr) {
    return arr.reduce(function (minIndex, item, i) {
      return item < arr[minIndex] ? i : minIndex;
    }, 0);
  };

  var columnsForCollageWithCover = function columnsForCollageWithCover(numOfColumns) {
    return numOfColumns === 4 ? 2 : 1;
  };

  function getCollageLayout(_ref2) {
    var gutter = _ref2.gutter,
        cover = _ref2.cover,
        numCols = _ref2.columns,
        h = _ref2.height,
        w = _ref2.width,
        layoutKey = _ref2.layoutKey;

    var positions = [];
    var width = w + gutter;
    var height = h + gutter;

    // If there's a cover image, we'll add that later. It should be a little
    // less than half the width of the collage. We do this now (and not later
    // when we add the cover image) because of `columnLayout`'s constraints
    // needing the exact number of columns that are displayed.
    var gridCols = cover ? columnsForCollageWithCover(numCols) : numCols;

    // Selects the layout that we're going to use for the grid
    var columns = columnLayout(gridCols);
    var layoutIdx = layoutKey % columns.length;
    var layout = columns[layoutIdx];

    // This does a really simple version of our masonry layout. Why replicate
    // that here? a.) fewer dependencies and b.) we need the algorithm to
    // roughly preserve the order of the collages from when they were ordered
    // by Masonry.
    var colHeights = new Array(gridCols).fill(0);
    var colCounts = new Array(gridCols).fill(0);

    // We iterate over every position that we think we could _potentially_ have
    // so that we can fill them with empty sections if need be.
    for (var i = 0; i < 2 * gridCols; i += 1) {
      var col = mindex(colHeights);
      var colIdx = colCounts[col];
      var itemHeight = layout[col][colIdx] * height;

      positions.push({
        top: colHeights[col],
        left: col * (width / numCols),
        width: width / numCols,
        height: itemHeight
      });

      colHeights[col] += itemHeight;
      colCounts[col] += 1;
    }

    // If we have a cover image, figure out how big it is, then move all the
    // existing columns over.
    if (cover) {
      var coverImageWidth = Math.ceil(numCols / 2) * (width / numCols);
      positions = positions.map(function (position) {
        return _extends({}, position, {
          left: coverImageWidth + position.left
        });
      });
      positions.unshift({ top: 0, left: 0, width: coverImageWidth, height: height });
    }

    // This adds the space between any items that we have. It's nice to do
    // this as a separate pass after everything else, because the math earlier
    // becomes easier and it's less brittle to change.
    if (gutter) {
      positions = paddingAll(gutter, positions);
    }

    return positions;
  }

  function Collage(props) {
    var columns = props.columns,
        cover = props.cover,
        gutter = props.gutter,
        height = props.height,
        layoutKey = props.layoutKey,
        renderImage = props.renderImage,
        width = props.width;

    var positions = getCollageLayout({
      columns: columns,
      cover: !!cover,
      width: width,
      height: height,
      gutter: gutter || 0,
      layoutKey: layoutKey || 0
    });
    return React.createElement(Collection, {
      Item: function Item(_ref3) {
        var index = _ref3.idx;
        return renderImage({
          index: index,
          width: positions[index].width,
          height: positions[index].height
        });
      },
      layout: positions
    });
  }

  Collage.propTypes = {
    columns: PropTypes.oneOf([2, 3, 4]).isRequired,
    cover: PropTypes.bool,
    gutter: PropTypes.number,
    height: PropTypes.number.isRequired,
    layoutKey: PropTypes.number,
    renderImage: PropTypes.func.isRequired,
    width: PropTypes.number.isRequired
  };

  var styles$9 = { "deprecatedColumn": "xKQ", "xsCol0": "NON", "xsCol1": "Fu1 wA7", "xsCol2": "ozo sxy", "xsCol3": "TPW xEW", "xsCol4": "Wvj MRE", "xsCol5": "xVb tYG", "xsCol6": "X2R UHc", "xsCol7": "r7z ojd", "xsCol8": "qAQ PX-", "xsCol9": "wAa Qfr", "xsCol10": "gd8 vdP", "xsCol11": "lhx kaP", "xsCol12": "YoG L4E", "smCol0": "Mwx", "smCol1": "hyE Djc", "smCol2": "j44 tar", "smCol3": "s7A QS3", "smCol4": "SOC V_L", "smCol5": "UO- kh1", "smCol6": "PaW Fue", "smCol7": "mD- cgB", "smCol8": "FSP DkM", "smCol9": "tVU AXh", "smCol10": "OlN UtM", "smCol11": "EEW Wyy", "smCol12": "Hqt dXC", "mdCol0": "is6", "mdCol1": "YAl U8q", "mdCol2": "N5L shx", "mdCol3": "owy EGm", "mdCol4": "Znf XMp", "mdCol5": "BLm H2Q", "mdCol6": "f1g HHc", "mdCol7": "LOE JWr", "mdCol8": "UU3 h5B", "mdCol9": "XyD Eeb", "mdCol10": "I4T TIo", "mdCol11": "F9- rPE", "mdCol12": "m4U QwK", "lgCol0": "Sze", "lgCol1": "t_l VSa", "lgCol2": "TIZ aml", "lgCol3": "qWI huk", "lgCol4": "oY2 Vnj", "lgCol5": "_bH KgZ", "lgCol6": "kwW c2A", "lgCol7": "BiY IGd", "lgCol8": "kl_ hMf", "lgCol9": "uVz swh", "lgCol10": "jgd Hs0", "lgCol11": "UZP YXE", "lgCol12": "MFv XTp" };

  function Column(props) {
    var children = props.children;

    var cs = classnames((props.xs !== undefined || props.sm !== undefined || props.md !== undefined || props.lg !== undefined) && styles$9.deprecatedColumn, props.xs && styles$9['xsCol' + props.xs], props.sm && styles$9['smCol' + props.sm], props.md && styles$9['mdCol' + props.md], props.lg && styles$9['lgCol' + props.lg], props.span != null && styles$9['xsCol' + props.span], props.smSpan != null && styles$9['smCol' + props.smSpan], props.mdSpan != null && styles$9['mdCol' + props.mdSpan], props.lgSpan != null && styles$9['lgCol' + props.lgSpan]);
    return React.createElement(
      'div',
      { className: cs },
      children
    );
  }

  Column.propTypes = {
    children: PropTypes.node,
    xs: PropTypes.number,
    sm: PropTypes.number,
    md: PropTypes.number,
    lg: PropTypes.number,
    span: PropTypes.number,
    smSpan: PropTypes.number,
    mdSpan: PropTypes.number,
    lgSpan: PropTypes.number
  };

  function Container(props) {
    var children = props.children;

    return React.createElement(
      Box,
      { justifyContent: 'center', display: 'flex' },
      React.createElement(
        Box,
        { maxWidth: 800, width: '100%' },
        children
      )
    );
  }

  Container.propTypes = {
    children: PropTypes.node
  };

  var styles$a = { "divider": "DJ9 kVc uNu e43" };

  function Divider() {
    return React.createElement('hr', { className: styles$a.divider });
  }

  function Caret(props) {
    var direction = props.direction;

    var path = void 0;
    switch (direction) {
      case 'up':
        path = 'M0 0 L12 12 L24 0';
        break;
      case 'right':
        path = 'M24 0 L12 12 L24 24';
        break;
      case 'down':
        path = 'M0 24 L12 12 L24 24';
        break;
      case 'left':
        path = 'M0 0 L12 12 L0 24';
        break;
      default:
    }

    return React.createElement(
      'svg',
      { width: '24', height: '24' },
      React.createElement('path', { d: path })
    );
  }

  Caret.propTypes = {
    direction: PropTypes.oneOf(['up', 'right', 'down', 'left'])
  };

  var styles$b = { "container": "YDx MIw", "contents": "fll kVc Hsu mix", "maxDimensions": "DHH", "minDimensions": "kFh", "innerContents": "ygj _O1 XbT mix", "caret": "BR9 MIw" };

  /* Needed until this Flow issue is fixed: https://github.com/facebook/flow/issues/380 */
  /* eslint quote-props: 0 */
  var SPACES_INDEX_MAP = {
    '0': 'up',
    '1': 'right',
    '2': 'down',
    '3': 'left'
  };

  var DIR_INDEX_MAP = {
    up: 0,
    right: 1,
    down: 2,
    left: 3
  };

  var MARGIN = 24;
  var CARET_HEIGHT = 24;
  var CARET_OFFSET_FROM_SIDE = 24;
  var BORDER_RADIUS = 8;

  /* eslint-disable react/no-unused-prop-types */

  /* eslint-enable react/no-unused-prop-types */

  /**
   * Determines the main direction the flyout opens
   */
  function getMainDir(flyoutSize, idealDirection, triggerRect, windowSize) {
    // Calculates the available space if we were to place the flyout in the 4 main directions
    // to determine which 'quadrant' to position the flyout inside of
    var up = triggerRect.top - flyoutSize.height - CARET_HEIGHT;
    var right = windowSize.width - flyoutSize.width - CARET_HEIGHT - triggerRect.right;
    var down = windowSize.height - flyoutSize.height - CARET_HEIGHT - triggerRect.bottom;
    var left = triggerRect.left - flyoutSize.width - CARET_HEIGHT;

    // overrides available space when the trigger is close to the edge of the screen
    // trigger is too close to top/bottom of screen for left & right flyouts
    if (triggerRect.top < BORDER_RADIUS || windowSize.height - triggerRect.bottom < BORDER_RADIUS) {
      left = 0;
      right = 0;
    }

    // trigger is too close to the left/right of screen for up & down flyouts
    if (triggerRect.left < BORDER_RADIUS || windowSize.width - triggerRect.right < BORDER_RADIUS) {
      up = 0;
      down = 0;
    }

    var spaces = [up, right, down, left];

    // Identify best direction of available spaces
    var max = Math.max.apply(Math, spaces);

    // Chose the main direction for the flyout based on available spaces & user preference
    var mainDir = void 0;
    if (idealDirection && spaces[DIR_INDEX_MAP[idealDirection]] > 0) {
      // user pref
      mainDir = idealDirection;
    } else {
      // If no direction pref, chose the direction in which there is the most space available
      mainDir = SPACES_INDEX_MAP[spaces.indexOf(max)];
    }
    return mainDir;
  }

  /**
   * Determines the sub direction of how the flyout is positioned within the main dir
   */
  function getSubDir(flyoutSize, mainDir, triggerRect, windowSize) {
    // Now that we have the main direction, chose from 3 caret placements for that direction
    var offset = void 0;
    var triggerMid = void 0;
    var windowSpaceAvailable = void 0;

    if (mainDir === 'right' || mainDir === 'left') {
      offset = flyoutSize.height / 2;
      triggerMid = triggerRect.top + (triggerRect.bottom - triggerRect.top) / 2;
      windowSpaceAvailable = windowSize.height;
    } else {
      // (mainDir === 'up' || mainDir === 'down')
      offset = flyoutSize.width / 2;
      triggerMid = triggerRect.left + (triggerRect.right - triggerRect.left) / 2;
      windowSpaceAvailable = windowSize.width;
    }

    var aboveOrLeft = triggerMid - offset - MARGIN;
    var belowOrRight = windowSpaceAvailable - triggerMid - offset - MARGIN;
    var subDir = void 0;
    if (aboveOrLeft > 0 && belowOrRight > 0) {
      // caret should go in middle b/c it can
      subDir = 'middle';
    } else if (belowOrRight > 0) {
      // caret should go at top for left/right and left for up/down
      subDir = mainDir === 'left' || mainDir === 'right' ? 'up' : 'left';
    } else {
      // caret should go at bottom for left/right and right for up/down
      subDir = mainDir === 'left' || mainDir === 'right' ? 'down' : 'right';
    }
    return subDir;
  }

  /**
   * Calculates the amount the flyout & caret need to shift over to align with designs
   */
  function calcEdgeShifts(subDir, triggerRect, windowSize) {
    // Target values for flyout and caret shifts
    var flyoutVerticalShift = CARET_OFFSET_FROM_SIDE - (triggerRect.height - CARET_HEIGHT) / 2;
    var flyoutHorizontalShift = CARET_OFFSET_FROM_SIDE - (triggerRect.width - CARET_HEIGHT) / 2;
    var caretVerticalShift = CARET_HEIGHT;
    var caretHorizontalShift = CARET_HEIGHT;

    // Covers edge case where trigger is in a corner and we need to adjust the offset of the caret
    // to something smaller than normal in order
    var isCloseVertically = triggerRect.top - flyoutVerticalShift < 0 || triggerRect.bottom + flyoutVerticalShift > windowSize.height;
    var isCloseHorizontally = triggerRect.left - flyoutHorizontalShift < 0 || triggerRect.right + flyoutHorizontalShift > windowSize.width;
    if (isCloseVertically) {
      flyoutVerticalShift = BORDER_RADIUS - (triggerRect.height - CARET_HEIGHT) / 2;
      caretVerticalShift = BORDER_RADIUS;
    }
    if (isCloseHorizontally) {
      flyoutHorizontalShift = BORDER_RADIUS - (triggerRect.width - CARET_HEIGHT) / 2;
      caretHorizontalShift = BORDER_RADIUS;
    }

    return {
      flyout: {
        x: flyoutHorizontalShift,
        y: flyoutVerticalShift
      },
      caret: {
        x: caretHorizontalShift,
        y: caretVerticalShift
      }
    };
  }

  /**
   * Calculates flyout and caret offsets for styling
   */
  function adjustOffsets(base, edgeShift, flyoutSize, mainDir, subDir, triggerRect) {
    var flyoutLeft = base.left;
    var flyoutTop = base.top;

    var caretTop = mainDir === 'down' ? -CARET_HEIGHT : null;
    var caretRight = mainDir === 'left' ? -CARET_HEIGHT : null;
    var caretBottom = null;
    var caretLeft = mainDir === 'right' ? -CARET_HEIGHT : null;

    if (subDir === 'up') {
      flyoutTop = base.top - edgeShift.flyout.y;
      caretTop = edgeShift.caret.y;
    } else if (subDir === 'down') {
      flyoutTop = base.top - flyoutSize.height + triggerRect.height + edgeShift.flyout.y;
      caretBottom = edgeShift.caret.y;
    } else if (subDir === 'left') {
      flyoutLeft = base.left - edgeShift.flyout.x;
      caretLeft = edgeShift.caret.x;
    } else if (subDir === 'right') {
      flyoutLeft = base.left - flyoutSize.width + triggerRect.width + edgeShift.flyout.x;
      caretRight = edgeShift.caret.x;
    } else if (subDir === 'middle') {
      if (mainDir === 'left' || mainDir === 'right') {
        var triggerMid = flyoutTop + triggerRect.height / 2;
        flyoutTop = triggerMid - flyoutSize.height / 2;
        caretTop = (flyoutSize.height - CARET_HEIGHT) / 2;
      }
      if (mainDir === 'up' || mainDir === 'down') {
        var _triggerMid = flyoutLeft + triggerRect.width / 2;
        flyoutLeft = _triggerMid - flyoutSize.width / 2;
        caretLeft = (flyoutSize.width - CARET_HEIGHT) / 2;
      }
    }

    return {
      flyoutOffset: {
        top: flyoutTop,
        left: flyoutLeft
      },
      caretOffset: {
        top: caretTop,
        right: caretRight,
        bottom: caretBottom,
        left: caretLeft
      }
    };
  }

  /* Calculates baseline top and left offset for flyout */
  function baseOffsets(relativeOffset, flyoutSize, mainDir, triggerRect, windowSize) {
    var HALF_CARET = CARET_HEIGHT / 2;
    // TOP OFFSET
    var top = void 0;
    if (mainDir === 'down') {
      top = windowSize.scrollY + triggerRect.bottom + HALF_CARET;
    } else if (mainDir === 'up') {
      top = windowSize.scrollY + (triggerRect.top - flyoutSize.height - HALF_CARET);
    } else {
      // left and right
      top = windowSize.scrollY + triggerRect.top;
    }

    // LEFT OFFSET
    var left = void 0;
    if (mainDir === 'left') {
      left = windowSize.scrollX + (triggerRect.left - flyoutSize.width - HALF_CARET);
    } else if (mainDir === 'right') {
      left = windowSize.scrollX + triggerRect.right + HALF_CARET;
    } else {
      // down and up
      left = windowSize.scrollX + triggerRect.left;
    }

    // Adjusts for the relative parent container
    top -= relativeOffset.y;
    left -= relativeOffset.x;
    return { top: top, left: left };
  }

  var Contents = function (_React$Component) {
    inherits(Contents, _React$Component);

    function Contents() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Contents);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Contents.__proto__ || Object.getPrototypeOf(Contents)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        flyoutOffset: {
          top: undefined,
          right: undefined,
          bottom: undefined,
          left: undefined
        },
        caretOffset: {
          top: undefined,
          right: undefined,
          bottom: undefined,
          left: undefined
        },
        mainDir: null
      }, _this.flyout = React.createRef(), _this.setFlyoutPosition = function (props) {
        var idealDirection = props.idealDirection,
            positionRelativeToAnchor = props.positionRelativeToAnchor,
            relativeOffset = props.relativeOffset,
            triggerRect = props.triggerRect,
            width = props.width;

        // Scroll not needed for relative elements
        // We can't use window.scrollX / window.scrollY since it's not supported by IE11

        var scrollX = positionRelativeToAnchor ? 0 : window.pageXOffset || document.documentElement && document.documentElement.scrollLeft || 0;
        var scrollY = positionRelativeToAnchor ? 0 : window.pageYOffset || document.documentElement && document.documentElement.scrollTop || 0;

        var windowSize = {
          height: window.innerHeight,
          width: window.innerWidth,
          scrollX: scrollX,
          scrollY: scrollY
        };

        var flyoutSize = {
          height: _this.flyout.current ? _this.flyout.current.clientHeight : 0,
          width: width || (_this.flyout.current ? _this.flyout.current.clientWidth : 0)
        };

        // First choose one of 4 main direction
        var mainDir = getMainDir(flyoutSize, idealDirection, triggerRect, windowSize);

        // Now that we have the main direction, chose from 3 caret placements for that direction
        var subDir = getSubDir(flyoutSize, mainDir, triggerRect, windowSize);

        // Gets the base offset that positions the flyout based on the main direction only
        var base = baseOffsets(relativeOffset, flyoutSize, mainDir, triggerRect, windowSize);

        // Gets the edge shifts for the flyout
        var edgeShifts = calcEdgeShifts(subDir, triggerRect, windowSize);

        // Adjusts for the subdirection of the caret

        var _adjustOffsets = adjustOffsets(base, edgeShifts, flyoutSize, mainDir, subDir, triggerRect),
            flyoutOffset = _adjustOffsets.flyoutOffset,
            caretOffset = _adjustOffsets.caretOffset;

        _this.setState({
          caretOffset: caretOffset,
          flyoutOffset: flyoutOffset,
          mainDir: mainDir
        });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Contents, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _this2 = this;

        this.setFlyoutPosition(this.props);
        setTimeout(function () {
          if (_this2.props.shouldFocus && _this2.flyout.current) {
            _this2.flyout.current.focus();
          }
        });
        window.addEventListener('resize', this.props.onResize);
        window.addEventListener('keydown', this.props.onKeyDown);
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        this.setFlyoutPosition(nextProps);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        window.removeEventListener('resize', this.props.onResize);
        window.removeEventListener('keydown', this.props.onKeyDown);
      }

      /**
       * Determines the main direciton, sub direction, and corresponding offsets needed
       * to correctly position the offset
       */

    }, {
      key: 'render',
      value: function render() {
        var _props = this.props,
            bgColor = _props.bgColor,
            caret = _props.caret,
            children = _props.children,
            width = _props.width;
        var _state = this.state,
            caretOffset = _state.caretOffset,
            flyoutOffset = _state.flyoutOffset,
            mainDir = _state.mainDir;

        // Needed to prevent UI thrashing

        var visibility = mainDir === null ? 'hidden' : 'visible';
        var background = bgColor + 'Bg';
        var stroke = bgColor === 'white' ? '#efefef' : null;
        var borderColor = bgColor === 'white' ? 'lightGray' : bgColor;

        return React.createElement(
          'div',
          {
            className: styles$b.container,
            style: _extends({ stroke: stroke, visibility: visibility }, flyoutOffset)
          },
          React.createElement(
            'div',
            {
              className: classnames(colors[background], colors[borderColor], styles$b.contents, styles$b.maxDimensions, width !== null && styles$b.minDimensions),
              ref: this.flyout,
              tabIndex: -1
            },
            React.createElement(
              'div',
              {
                className: classnames(styles$b.innerContents, styles$b.maxDimensions, width !== null && styles$b.minDimensions),
                style: { width: width }
              },
              children
            ),
            caret && React.createElement(
              'div',
              {
                className: classnames(colors[bgColor], styles$b.caret),
                style: _extends({}, caretOffset)
              },
              React.createElement(Caret, { direction: mainDir })
            )
          )
        );
      }
    }]);
    return Contents;
  }(React.Component);

  Contents.propTypes = {
    bgColor: PropTypes.oneOf(['blue', 'darkGray', 'orange', 'white']),
    caret: PropTypes.bool,
    children: PropTypes.node,
    idealDirection: PropTypes.oneOf(['up', 'right', 'down', 'left']),
    onKeyDown: PropTypes.func.isRequired,
    onResize: PropTypes.func.isRequired,
    relativeOffset: PropTypes.exact({
      x: PropTypes.number,
      y: PropTypes.number
    }),
    positionRelativeToAnchor: PropTypes.bool,
    shouldFocus: PropTypes.bool,
    triggerRect: PropTypes.exact({
      bottom: PropTypes.number,
      height: PropTypes.number,
      left: PropTypes.number,
      right: PropTypes.number,
      top: PropTypes.number,
      width: PropTypes.number
    }),
    width: PropTypes.number
  };
  Contents.defaultProps = {
    caret: true
  };

  var OutsideEventBehavior = function (_React$Component) {
    inherits(OutsideEventBehavior, _React$Component);

    function OutsideEventBehavior() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, OutsideEventBehavior);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = OutsideEventBehavior.__proto__ || Object.getPrototypeOf(OutsideEventBehavior)).call.apply(_ref, [this].concat(args))), _this), _this.handleClickEvent = function (event) {
        // eslint-disable-next-line react/no-find-dom-node
        var el = reactDom.findDOMNode(_this);
        if (!_this.props.onClick || !el || event.target instanceof Node && el.contains(event.target)) {
          return;
        }
        _this.props.onClick(event);
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(OutsideEventBehavior, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        document.addEventListener('click', this.handleClickEvent, {
          capture: true
        });
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        document.removeEventListener('click', this.handleClickEvent, {
          capture: true
        });
      }
    }, {
      key: 'render',
      value: function render() {
        return this.props.children;
      }
    }]);
    return OutsideEventBehavior;
  }(React.Component);

  var SIZE_WIDTH_MAP = {
    xs: 185,
    sm: 230,
    md: 284,
    lg: 320,
    xl: 375
  };

  var ESCAPE_KEY_CODE = 27;

  var Controller = function (_React$Component) {
    inherits(Controller, _React$Component);

    function Controller() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Controller);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Controller.__proto__ || Object.getPrototypeOf(Controller)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        relativeOffset: {
          x: 0,
          y: 0
        },
        triggerBoundingRect: {
          bottom: 0,
          height: 0,
          left: 0,
          right: 0,
          top: 0,
          width: 0
        }
      }, _this.handleKeyDown = function (event) {
        var onDismiss = _this.props.onDismiss;

        if (event.keyCode === ESCAPE_KEY_CODE) {
          onDismiss();
        }
      }, _this.handlePageClick = function (event) {
        var _this$props = _this.props,
            anchor = _this$props.anchor,
            onDismiss = _this$props.onDismiss;

        if (event.target instanceof Node && !anchor.contains(event.target)) {
          onDismiss();
        }
      }, _this.handleResize = function () {
        _this.updateTriggerRect(_this.props);
      }, _this.updateTriggerRect = function (props) {
        var anchor = props.anchor,
            positionRelativeToAnchor = props.positionRelativeToAnchor;

        var triggerBoundingRect = void 0;
        var relativeOffset = void 0;
        if (anchor) {
          triggerBoundingRect = anchor.getBoundingClientRect();

          // Needed for correct positioning within Contents.js
          relativeOffset = {
            x: positionRelativeToAnchor ? triggerBoundingRect.left - anchor.offsetLeft : 0,
            y: positionRelativeToAnchor ? triggerBoundingRect.top - anchor.offsetTop : 0
          };
        }

        _this.setState({ relativeOffset: relativeOffset, triggerBoundingRect: triggerBoundingRect });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Controller, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.updateTriggerRect(this.props);
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        this.updateTriggerRect(nextProps);
      }
    }, {
      key: 'render',
      value: function render() {
        var _props = this.props,
            bgColor = _props.bgColor,
            caret = _props.caret,
            children = _props.children,
            idealDirection = _props.idealDirection,
            positionRelativeToAnchor = _props.positionRelativeToAnchor,
            shouldFocus = _props.shouldFocus,
            size = _props.size;
        var _state = this.state,
            relativeOffset = _state.relativeOffset,
            triggerBoundingRect = _state.triggerBoundingRect;


        var width = typeof size === 'string' ? SIZE_WIDTH_MAP[size] : size;

        return React.createElement(
          OutsideEventBehavior,
          { onClick: this.handlePageClick },
          React.createElement(
            Contents,
            {
              bgColor: bgColor,
              caret: caret,
              idealDirection: idealDirection,
              onKeyDown: this.handleKeyDown,
              onResize: this.handleResize,
              positionRelativeToAnchor: positionRelativeToAnchor,
              relativeOffset: relativeOffset,
              shouldFocus: shouldFocus,
              triggerRect: triggerBoundingRect,
              width: width
            },
            children
          )
        );
      }
    }]);
    return Controller;
  }(React.Component);

  Controller.defaultProps = {
    // Default size only applies when size is omitted,
    // if passed as null it will remain null
    size: 'sm'
  };


  Controller.propTypes = {
    anchor: PropTypes.shape({
      contains: PropTypes.func,
      getBoundingClientRect: PropTypes.func
    }),
    bgColor: PropTypes.oneOf(['blue', 'darkGray', 'orange', 'white']),
    children: PropTypes.node,
    idealDirection: PropTypes.oneOf(['up', 'right', 'down', 'left']),
    onDismiss: PropTypes.func.isRequired,
    positionRelativeToAnchor: PropTypes.bool,
    shouldFocus: PropTypes.bool,
    size: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl'])] // default: sm
    )
  };

  function Flyout(props) {
    var anchor = props.anchor,
        children = props.children,
        idealDirection = props.idealDirection,
        onDismiss = props.onDismiss,
        _props$positionRelati = props.positionRelativeToAnchor,
        positionRelativeToAnchor = _props$positionRelati === undefined ? true : _props$positionRelati,
        _props$color = props.color,
        color = _props$color === undefined ? 'white' : _props$color,
        _props$shouldFocus = props.shouldFocus,
        shouldFocus = _props$shouldFocus === undefined ? true : _props$shouldFocus,
        size = props.size;


    if (!anchor) {
      return null;
    }

    return React.createElement(
      Controller,
      {
        anchor: anchor,
        bgColor: color,
        idealDirection: idealDirection,
        onDismiss: onDismiss,
        positionRelativeToAnchor: positionRelativeToAnchor,
        shouldFocus: shouldFocus,
        size: size
      },
      children
    );
  }

  Flyout.propTypes = {
    anchor: PropTypes.shape({
      contains: PropTypes.func,
      getBoundingClientRect: PropTypes.func
    }),
    children: PropTypes.node,
    idealDirection: PropTypes.oneOf(['up', 'right', 'down', 'left']),
    onDismiss: PropTypes.func.isRequired,
    positionRelativeToAnchor: PropTypes.bool,
    color: PropTypes.oneOf(['blue', 'orange', 'white', 'darkGray']),
    size: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl'])] // default: sm
    )
  };

  var styles$c = { "wash": "mLe MIw QLY Rym p6V ojN" };

  function zip(a, b) {
    return a.map(function (item, idx) {
      return [item, b[idx]];
    });
  }

  var BORDER_WIDTH = 2;

  var AVATAR_SIZES = {
    sm: 24,
    md: 40,
    lg: 72
  };

  var avatarLayout = function avatarLayout(n, size) {
    switch (n) {
      case 0:
      case 1:
        return [{ top: 0, left: 0, width: size, height: size, textLayout: 'center' }];
      case 2:
        return [{
          top: 0,
          left: 0,
          width: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
          height: size,
          textLayout: 'center'
        }, {
          top: 0,
          left: 'calc(50% + ' + BORDER_WIDTH / 2 + 'px)',
          width: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
          height: size,
          textLayout: 'center'
        }];
      default:
        return [{
          top: 0,
          left: 0,
          width: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
          height: size,
          textLayout: 'center'
        }, {
          top: 0,
          left: 'calc(50% + ' + BORDER_WIDTH / 2 + 'px)',
          width: 'calc(50%)',
          height: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
          textLayout: 'topLeft'
        }, {
          top: 'calc(50% + ' + BORDER_WIDTH / 2 + 'px)',
          left: 'calc(50% + ' + BORDER_WIDTH / 2 + 'px)',
          width: 'calc(50%)',
          height: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
          textLayout: 'bottomLeft'
        }];
    }
  };

  var degToRad = function degToRad(deg) {
    return deg * (Math.PI / 180);
  };

  var DefaultAvatar$1 = function DefaultAvatar(props) {
    var size = props.size,
        name = props.name,
        textLayout = props.textLayout;


    var quarterPadding = 'calc(' + Math.sin(degToRad(45)) + ' * (' + size + ') / 2)';

    var initial = React.createElement(
      'svg',
      {
        width: '100%',
        viewBox: '-50 -50 100 100',
        version: '1.1',
        preserveAspectRatio: 'xMidYMid meet',
        xmlns: 'http://www.w3.org/2000/svg'
      },
      React.createElement(
        'title',
        null,
        name
      ),
      React.createElement(
        'text',
        {
          fontSize: '50px',
          fill: '#fff',
          dominantBaseline: 'central',
          textAnchor: 'middle',
          className: [typography.antialiased, typography.sansSerif, typography.leadingSmall, typography.fontWeightBold].join(' ')
        },
        name ? [].concat(toConsumableArray(name))[0].toUpperCase() : ''
      )
    );
    switch (textLayout) {
      case 'bottomLeft':
        return React.createElement(
          Box,
          {
            'aria-label': name,
            color: 'gray',
            height: '100%',
            display: 'flex',
            alignItems: 'end',
            dangerouslySetInlineStyle: {
              __style: {
                paddingBottom: quarterPadding,
                paddingRight: quarterPadding
              }
            }
          },
          initial
        );
      case 'topLeft':
        return React.createElement(
          Box,
          {
            'aria-label': name,
            color: 'gray',
            height: '100%',
            display: 'flex',
            alignItems: 'start',
            dangerouslySetInlineStyle: {
              __style: {
                paddingTop: quarterPadding,
                paddingRight: quarterPadding
              }
            }
          },
          initial
        );
      default:
        return React.createElement(
          Box,
          {
            'aria-label': name,
            color: 'gray',
            height: '100%',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center'
          },
          initial
        );
    }
  };

  function GroupAvatar(props) {
    var collaborators = props.collaborators,
        outline = props.outline,
        size = props.size;

    var avatarWidth = size ? AVATAR_SIZES[size] : '100%';
    var avatarHeight = size ? AVATAR_SIZES[size] : '';
    var positions = avatarLayout(collaborators.length, avatarWidth);
    return React.createElement(
      Box,
      {
        color: 'white',
        overflow: 'hidden',
        shape: 'circle',
        width: avatarWidth,
        height: avatarHeight,
        position: 'relative',
        dangerouslySetInlineStyle: {
          __style: _extends({}, outline ? { boxShadow: '0 0 0 2px #fff' } : {}, {
            // willChange: transform fixes a strange behavior where the border of the children
            // are not properly trimmed even though overflow: hidden is set
            willChange: 'transform'
          })
        }
      },
      React.createElement(Box, { dangerouslySetInlineStyle: { __style: { paddingBottom: '100%' } } }),
      zip(positions, collaborators).map(function (_ref, idx) {
        var _ref2 = slicedToArray(_ref, 2),
            position = _ref2[0],
            _ref2$ = _ref2[1],
            collaborator = _ref2$ === undefined ? { name: '', src: undefined } : _ref2$;

        var width = position.width,
            height = position.height,
            top = position.top,
            left = position.left,
            textLayout = position.textLayout;
        var name = collaborator.name,
            src = collaborator.src;

        return React.createElement(
          Box,
          {
            key: idx,
            position: 'absolute',
            width: width,
            height: height,
            dangerouslySetInlineStyle: { __style: { top: top, left: left } }
          },
          src ? React.createElement(Image, {
            alt: name,
            color: '#EFEFEF',
            src: src,
            naturalWidth: 1,
            naturalHeight: 1,
            fit: 'cover'
          }) : React.createElement(DefaultAvatar$1, {
            name: name,
            textLayout: textLayout,
            size: height
          }),
          React.createElement('div', { className: styles$c.wash })
        );
      })
    );
  }

  GroupAvatar.propTypes = {
    collaborators: PropTypes.arrayOf(PropTypes.exact({
      name: PropTypes.string.isRequired,
      src: PropTypes.string
    })).isRequired,
    outline: PropTypes.bool,
    size: PropTypes.oneOf(['sm', 'md', 'lg'])
  };

  var styles$d = { "Heading": "lH1 dyH iFc SMy", "fontSize1": "kON", "fontSize2": "ut5", "fontSize3": "ky3", "fontSize4": "E1P", "fontSize5": "MAG", "smFontSize1": "uhp", "smFontSize2": "AU0", "smFontSize3": "I-R", "smFontSize4": "KW_", "smFontSize5": "ghA", "mdFontSize1": "Z6c", "mdFontSize2": "E5p", "mdFontSize3": "O3a", "mdFontSize4": "Sps", "mdFontSize5": "l1g", "lgFontSize1": "j0V", "lgFontSize2": "nsr", "lgFontSize3": "kHV", "lgFontSize4": "DqY", "lgFontSize5": "Ky8" };

  var defaultHeadingLevels = {
    xs: 5,
    sm: 4,
    md: 3,
    lg: 2,
    xl: 1
  };

  var SIZE_SCALE$1 = {
    xs: 1,
    sm: 2,
    md: 3,
    lg: 4,
    xl: 5
  };

  function Heading(props) {
    var accessibilityLevel = props.accessibilityLevel,
        children = props.children,
        _props$color = props.color,
        color = _props$color === undefined ? 'darkGray' : _props$color,
        _props$id = props.id,
        id = _props$id === undefined ? null : _props$id,
        lgSize = props.lgSize,
        mdSize = props.mdSize,
        _props$overflow = props.overflow,
        overflow = _props$overflow === undefined ? 'breakWord' : _props$overflow,
        _props$size = props.size,
        size = _props$size === undefined ? 'md' : _props$size,
        smSize = props.smSize,
        _props$truncate = props.truncate,
        truncate = _props$truncate === undefined ? false : _props$truncate;


    var cs = classnames(styles$d.Heading, styles$d['fontSize' + SIZE_SCALE$1[size]], smSize && styles$d['smFontSize' + SIZE_SCALE$1[smSize]], mdSize && styles$d['mdFontSize' + SIZE_SCALE$1[mdSize]], lgSize && styles$d['lgFontSize' + SIZE_SCALE$1[lgSize]], colors[color], overflow === 'breakWord' && typography.breakWord, truncate && typography.truncate);

    var headingLevel = accessibilityLevel || defaultHeadingLevels[size];
    return React.createElement('h' + headingLevel, _extends({
      className: cs,
      id: id
    }, truncate && typeof children === 'string' ? { title: children } : null), children);
  }

  Heading.propTypes = {
    accessibilityLevel: PropTypes.oneOf([1, 2, 3, 4, 5, 6]),
    children: PropTypes.node,
    color: PropTypes.oneOf(['blue', 'darkGray', 'eggplant', 'gray', 'green', 'lightGray', 'maroon', 'midnight', 'navy', 'olive', 'orange', 'orchid', 'pine', 'purple', 'red', 'watermelon', 'white']),
    id: PropTypes.string,
    overflow: PropTypes.oneOf(['normal', 'breakWord']),
    size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
    smSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
    mdSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
    lgSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
    truncate: PropTypes.bool
  };

  var styles$e = { "button": "rYa kVc adn yQo BG7" };

  var styles$f = { "pog": "x8f INd _O1 gjz mQ8", "focused": "Xsi C1J", "transparent": "OGJ YbY", "transparentDarkGray": "lEC prG", "hovered": "bPW", "white": "NSs qJc", "active": "s4m", "lightGray": "WhU gpV", "gray": "JhO gfP" };

  var SIZE_NAME_TO_PIXEL = {
    xs: 24,
    sm: 32,
    md: 40,
    lg: 48,
    xl: 56
  };

  var defaultIconButtonIconColors = {
    transparent: 'gray',
    gray: 'white',
    lightGray: 'gray',
    white: 'gray',
    transparentDarkGray: 'white'
  };

  function Pog(props) {
    var _classnames;

    var _props$active = props.active,
        active = _props$active === undefined ? false : _props$active,
        _props$bgColor = props.bgColor,
        bgColor = _props$bgColor === undefined ? 'transparent' : _props$bgColor,
        _props$focused = props.focused,
        focused = _props$focused === undefined ? false : _props$focused,
        _props$hovered = props.hovered,
        hovered = _props$hovered === undefined ? false : _props$hovered,
        _props$iconColor = props.iconColor,
        iconColor = _props$iconColor === undefined ? defaultIconButtonIconColors[bgColor] : _props$iconColor,
        icon = props.icon,
        _props$size = props.size,
        size = _props$size === undefined ? 'md' : _props$size;


    var iconSize = SIZE_NAME_TO_PIXEL[size] / 2;

    var inlineStyle = {
      height: SIZE_NAME_TO_PIXEL[size],
      width: SIZE_NAME_TO_PIXEL[size]
    };

    var classes = classnames(styles$f.pog, styles$f[bgColor], (_classnames = {}, defineProperty(_classnames, styles$f.active, active), defineProperty(_classnames, styles$f.focused, focused), defineProperty(_classnames, styles$f.hovered, hovered && !focused && !active), _classnames));

    return React.createElement(
      'div',
      { className: classes, style: inlineStyle },
      React.createElement(
        Box,
        { shape: 'circle' },
        React.createElement(Icon, {
          accessibilityLabel: '',
          color: iconColor,
          icon: icon,
          size: iconSize
        })
      )
    );
  }

  Pog.propTypes = {
    active: PropTypes.bool,
    bgColor: PropTypes.oneOf(['transparent', 'transparentDarkGray', 'gray', 'lightGray', 'white']),
    focused: PropTypes.bool,
    hovered: PropTypes.bool,
    iconColor: PropTypes.oneOf(['gray', 'darkGray', 'red', 'blue', 'white']),
    icon: PropTypes.oneOf(Object.keys(icons)).isRequired,
    size: PropTypes.oneOf(Object.keys(SIZE_NAME_TO_PIXEL))
  };

  var IconButton = function (_React$Component) {
    inherits(IconButton, _React$Component);

    function IconButton() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, IconButton);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = IconButton.__proto__ || Object.getPrototypeOf(IconButton)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        active: false,
        focused: false,
        hovered: false
      }, _this.handleBlur = function () {
        return _this.setState({ focused: false });
      }, _this.handleFocus = function () {
        return _this.setState({ focused: true });
      }, _this.handleMouseDown = function () {
        return _this.setState({ active: true });
      }, _this.handleMouseEnter = function () {
        return _this.setState({ hovered: true });
      }, _this.handleMouseLeave = function () {
        return _this.setState({ active: false, hovered: false });
      }, _this.handleMouseUp = function () {
        return _this.setState({ active: false });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(IconButton, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            accessibilityExpanded = _props.accessibilityExpanded,
            accessibilityHaspopup = _props.accessibilityHaspopup,
            accessibilityLabel = _props.accessibilityLabel,
            bgColor = _props.bgColor,
            iconColor = _props.iconColor,
            icon = _props.icon,
            size = _props.size,
            onClick = _props.onClick;
        var _state = this.state,
            active = _state.active,
            focused = _state.focused,
            hovered = _state.hovered;


        return React.createElement(
          'button',
          {
            'aria-expanded': accessibilityExpanded,
            'aria-haspopup': accessibilityHaspopup,
            'aria-label': accessibilityLabel,
            className: styles$e.button,
            onBlur: this.handleBlur,
            onClick: function (_onClick) {
              function onClick(_x) {
                return _onClick.apply(this, arguments);
              }

              onClick.toString = function () {
                return _onClick.toString();
              };

              return onClick;
            }(function (event) {
              return onClick && onClick({ event: event });
            }),
            onFocus: this.handleFocus,
            onMouseDown: this.handleMouseDown,
            onMouseEnter: this.handleMouseEnter,
            onMouseLeave: this.handleMouseLeave,
            onMouseUp: this.handleMouseUp,
            type: 'button'
          },
          React.createElement(Pog, {
            active: active,
            bgColor: bgColor,
            focused: focused,
            hovered: hovered,
            iconColor: iconColor,
            icon: icon,
            size: size
          })
        );
      }
    }]);
    return IconButton;
  }(React.Component);

  IconButton.propTypes = {
    accessibilityExpanded: PropTypes.bool,
    accessibilityHaspopup: PropTypes.bool,
    accessibilityLabel: PropTypes.string.isRequired,
    bgColor: PropTypes.oneOf(['transparent', 'transparentDarkGray', 'gray', 'lightGray', 'white']),
    icon: PropTypes.oneOf(Object.keys(icons)).isRequired,
    iconColor: PropTypes.oneOf(['gray', 'darkGray', 'red', 'blue', 'white']),
    onClick: PropTypes.func,
    size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl'])
  };

  var styles$g = { "label": "PPe kVc BG7" };

  function Label(props) {
    var children = props.children,
        htmlFor = props.htmlFor;


    return React.createElement(
      'label',
      { className: styles$g.label, htmlFor: htmlFor },
      children
    );
  }

  Label.propTypes = {
    children: PropTypes.node,
    htmlFor: PropTypes.string.isRequired
  };

  var Layer = function (_React$Component) {
    inherits(Layer, _React$Component);

    function Layer(props) {
      classCallCheck(this, Layer);

      var _this = possibleConstructorReturn(this, (Layer.__proto__ || Object.getPrototypeOf(Layer)).call(this, props));

      _this.state = {
        mounted: false
      };

      if (typeof document !== 'undefined' && document.createElement) {
        _this.el = document.createElement('div');
      } else {
        // eslint-disable-next-line no-console
        console.warn('Using Layer without document present. Children will not be rendered.');
      }
      return _this;
    }

    createClass(Layer, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        if (typeof document !== 'undefined' && document.body) {
          document.body.appendChild(this.el);
          this.setState({ mounted: true });
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (document.body) {
          document.body.removeChild(this.el);
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var children = this.props.children;

        return this.state.mounted && reactDom.createPortal(children, this.el);
      }
    }]);
    return Layer;
  }(React.Component);

  /*
    Much of the math and understanding about this component comes from @vjeaux's
    excellent blog post on image resizing.

    http://blog.vjeux.com/2013/image/css-container-and-cover.html

    I highly recommend you read that first before continuing on reading.
  */

  var aspectRatio = function aspectRatio(width, height) {
    return width / height;
  };

  function Letterbox(_ref) {
    var children = _ref.children,
        contentAspectRatio = _ref.contentAspectRatio,
        height = _ref.height,
        width = _ref.width;

    var viewportAspectRatio = aspectRatio(width, height);

    var contentHeight = void 0;
    var contentWidth = void 0;

    if (contentAspectRatio < viewportAspectRatio) {
      contentWidth = width;
      contentHeight = width / contentAspectRatio;
    } else {
      contentWidth = height * contentAspectRatio;
      contentHeight = height;
    }

    var offsetTop = (contentHeight - height) / -2;
    var offsetLeft = (contentWidth - width) / -2;

    return React.createElement(
      Mask,
      { width: width, height: height },
      React.createElement(
        'div',
        { style: { marginTop: offsetTop, marginLeft: offsetLeft } },
        React.createElement(
          Mask,
          { width: contentWidth, height: contentHeight },
          children
        )
      )
    );
  }

  Letterbox.propTypes = {
    children: PropTypes.node,
    contentAspectRatio: PropTypes.number.isRequired,
    height: PropTypes.number.isRequired,
    width: PropTypes.number.isRequired
  };

  var styles$h = { "link": "Wk9 xQ4", "accessibleFocusStyle": "WMU iyn", "block": "ljY kVc" };

  var TAB_KEY_CODE = 9;

  var Link = function (_React$Component) {
    inherits(Link, _React$Component);

    function Link() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Link);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Link.__proto__ || Object.getPrototypeOf(Link)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        enableFocusStyles: true
      }, _this.handleClick = function (event) {
        var _this$props = _this.props,
            href = _this$props.href,
            onClick = _this$props.onClick;

        if (onClick && href) {
          onClick({ event: event });
        }
      }, _this.handleMouseDown = function () {
        var _this$props2 = _this.props,
            href = _this$props2.href,
            target = _this$props2.target;

        if (target === 'blank' && href) {
          _this.setState({ enableFocusStyles: false });
        }
      }, _this.handleKeyUp = function (event) {
        var _this$props3 = _this.props,
            href = _this$props3.href,
            target = _this$props3.target;

        if (target === 'blank' && event.keyCode === TAB_KEY_CODE && href) {
          _this.setState({ enableFocusStyles: true });
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Link, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            children = _props.children,
            _props$inline = _props.inline,
            inline = _props$inline === undefined ? false : _props$inline,
            _props$target = _props.target,
            target = _props$target === undefined ? null : _props$target,
            href = _props.href;

        var rel = target === 'blank' ? 'noopener noreferrer' : null;
        var linkTarget = target ? '_' + target : null;

        return React.createElement(
          'a',
          {
            className: classnames(styles$h.link, this.state.enableFocusStyles ? styles$h.accessibleFocusStyle : '', inline ? '' : styles$h.block),
            href: href,
            onMouseDown: this.handleMouseDown,
            onKeyUp: this.handleKeyUp,
            onClick: this.handleClick,
            rel: rel,
            target: linkTarget
          },
          children
        );
      }
    }]);
    return Link;
  }(React.Component);

  Link.propTypes = {
    children: PropTypes.node.isRequired,
    href: PropTypes.string.isRequired,
    inline: PropTypes.bool,
    onClick: PropTypes.func,
    target: PropTypes.oneOf([null, 'self', 'blank'])
  };

  /**
   * debounce prevents a particular function from being called until after a given
   * cooldown period (default 100ms). Every time the function is called, it resets
   * the cooldown.
   */

  function debounce(fn) {
    var threshhold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

    var deferTimer = null;

    var debounced = function debounced() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (deferTimer) {
        clearTimeout(deferTimer);
      }

      deferTimer = setTimeout(function () {
        deferTimer = null;
        fn.apply(undefined, toConsumableArray(args));
      }, threshhold);
    };

    debounced.clearTimeout = function () {
      if (deferTimer) {
        clearTimeout(deferTimer);
      }
    };

    return debounced;
  }

  /**
   * FetchItems is a logic component that renders no content itself. Its job
   * is to manage when the given fetchMore method should be called based on
   * the given scroll/size props.
   *
   * While no element is actually passed to FetchItems, it is intended to be used
   * in conjunction with a large scroll container that uses async fetching to
   * load and render additional data. Based on the height of this container and
   * its current scroll position, FetchItems is responsible for triggering future
   * fetch calls.
   */

  var FetchItems = function (_React$PureComponent) {
    inherits(FetchItems, _React$PureComponent);

    function FetchItems() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, FetchItems);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FetchItems.__proto__ || Object.getPrototypeOf(FetchItems)).call.apply(_ref, [this].concat(args))), _this), _this.check = function () {
        var _this$props = _this.props,
            containerHeight = _this$props.containerHeight,
            isAtEnd = _this$props.isAtEnd,
            isFetching = _this$props.isFetching,
            fetchMore = _this$props.fetchMore,
            scrollHeight = _this$props.scrollHeight,
            scrollTop = _this$props.scrollTop;


        if (isAtEnd || isFetching || !fetchMore) {
          return;
        }
        var scrollBuffer = containerHeight * 3;

        if (scrollTop + scrollBuffer > scrollHeight) {
          fetchMore();
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(FetchItems, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        setTimeout(this.check);
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        this.check();
      }
    }, {
      key: 'render',
      value: function render() {
        return null;
      }
    }]);
    return FetchItems;
  }(React.PureComponent);

  FetchItems.propTypes = {
    containerHeight: PropTypes.number.isRequired,
    isAtEnd: PropTypes.bool,
    isFetching: PropTypes.bool.isRequired,
    fetchMore: PropTypes.func,
    scrollHeight: PropTypes.number.isRequired,
    scrollTop: PropTypes.number.isRequired
  };

  var styles$i = { "Masonry": "vbI XiG", "Masonry__Item": "Yl- MIw", "Masonry__Item__Mounted": "Hb7" };

  /**
   * ScrollContainer is a pass-through component that simply sets up an onScroll
   * handler on the given scrollContainer element (or the element that is
   * returned as result of calling the scrollContainer method). This allows for
   * the event listener subscription of the scrollContainer to be managed inside
   * the React lifecycle without adding bloat to Masonry or other onScroll
   * subscribers.
   *
   * Note that this Component renders its children without creating any
   * additional content. Also note that, while the component is built to manage
   * onScroll inside of the React lifecycle, it doesn't change onScroll events
   * or the API at all, so it could easily be adapted to other event types.
   */

  function getScrollContainer(scrollContainer) {
    return typeof scrollContainer === 'function' ? scrollContainer() : scrollContainer;
  }

  var ScrollContainer = function (_React$Component) {
    inherits(ScrollContainer, _React$Component);

    function ScrollContainer() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, ScrollContainer);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ScrollContainer.__proto__ || Object.getPrototypeOf(ScrollContainer)).call.apply(_ref, [this].concat(args))), _this), _this.getScrollContainerRef = function () {
        return _this.scrollContainer;
      }, _this.handleScroll = function (event) {
        _this.props.onScroll(event);
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(ScrollContainer, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var scrollContainer = getScrollContainer(this.props.scrollContainer);
        if (scrollContainer) {
          this.updateScrollContainer(scrollContainer);
        }
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        var nextScrollContainer = getScrollContainer(this.props.scrollContainer);
        if (nextScrollContainer && nextScrollContainer !== this.scrollContainer) {
          this.updateScrollContainer(nextScrollContainer);
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (this.scrollContainer) {
          this.scrollContainer.removeEventListener('scroll', this.handleScroll);
        }
      }
    }, {
      key: 'updateScrollContainer',
      value: function updateScrollContainer(scrollContainer) {
        if (this.scrollContainer) {
          // cleanup existing scroll container if it exists
          this.scrollContainer.removeEventListener('scroll', this.handleScroll);
        }
        this.scrollContainer = scrollContainer;
        this.scrollContainer.addEventListener('scroll', this.handleScroll);
      }
    }, {
      key: 'render',
      value: function render() {
        return React.Children.only(this.props.children);
      }
    }]);
    return ScrollContainer;
  }(React.Component);

  ScrollContainer.propTypes = {
    children: PropTypes.node.isRequired,
    onScroll: PropTypes.func.isRequired,
    scrollContainer: PropTypes.oneOfType([PropTypes.object, PropTypes.func]).isRequired
  };

  /**
   * throttle limits the number of times a function can be called to a
   * given threshhold (100ms by default). The function is always called
   * on the leading and trailing edge.
   */

  function throttle(fn) {
    var threshhold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

    var last = void 0;
    var deferTimer = void 0;
    var throttled = function throttled() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var now = Date.now();
      if (last !== undefined && now - last < threshhold) {
        clearTimeout(deferTimer);
        deferTimer = setTimeout(function () {
          last = now;
          fn.apply(undefined, toConsumableArray(args));
        }, threshhold - (now - last));
      } else {
        last = now;
        fn.apply(undefined, toConsumableArray(args));
      }
    };

    throttled.clearTimeout = function () {
      if (deferTimer) {
        clearTimeout(deferTimer);
      }
    };

    return throttled;
  }

  var MeasurementStore = function () {
    function MeasurementStore() {
      classCallCheck(this, MeasurementStore);
      this.map = new WeakMap();
    }

    createClass(MeasurementStore, [{
      key: 'get',
      value: function get$$1(key) {
        return this.map.get(key);
      }
    }, {
      key: 'has',
      value: function has(key) {
        return this.map.has(key);
      }
    }, {
      key: 'set',
      value: function set$$1(key, value) {
        this.map.set(key, value);
      }
    }, {
      key: 'reset',
      value: function reset() {
        this.map = new WeakMap();
      }
    }]);
    return MeasurementStore;
  }();

  /**
   * Measuring scroll positions, element heights, etc is different between
   * different browsers and the window object vs other DOM nodes. These
   * utils abstract away these differences.
   */

  function getElementHeight(element) {
    return element === window ? window.innerHeight : element.clientHeight;
  }

  function getWindowScrollPos() {
    if (window.scrollY !== undefined) {
      // Modern browser
      return window.scrollY;
    }
    if (document.documentElement && document.documentElement.scrollTop !== undefined) {
      // IE support.
      return document.documentElement.scrollTop;
    }
    return 0;
  }

  function getRelativeScrollTop(element) {
    return element === window ? getWindowScrollPos() : element.scrollTop - element.getBoundingClientRect().top;
  }

  function getScrollHeight(element) {
    return element === window && document.documentElement ? document.documentElement.scrollHeight : element.scrollHeight;
  }

  function getScrollPos(element) {
    return element === window ? getWindowScrollPos() : element.scrollTop;
  }

  var DefaultLayoutSymbol = Symbol('default');
  var UniformRowLayoutSymbol = Symbol('uniformRow');

  var mindex$1 = function mindex(arr) {
    var idx = 0;
    for (var i = 0; i < arr.length; i += 1) {
      if (arr[i] < arr[idx]) {
        idx = i;
      }
    }
    return idx;
  };

  var offscreen = function offscreen(width) {
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
    return {
      top: -9999,
      left: -9999,
      width: width,
      height: height
    };
  };

  var defaultLayout = (function (_ref) {
    var cache = _ref.cache,
        _ref$columnWidth = _ref.columnWidth,
        columnWidth = _ref$columnWidth === undefined ? 236 : _ref$columnWidth,
        _ref$gutter = _ref.gutter,
        gutter = _ref$gutter === undefined ? 14 : _ref$gutter,
        _ref$minCols = _ref.minCols,
        minCols = _ref$minCols === undefined ? 2 : _ref$minCols,
        width = _ref.width;
    return function (items) {
      if (width == null) {
        return items.map(function () {
          return offscreen(columnWidth);
        });
      }

      var columnWidthAndGutter = columnWidth + gutter;
      var columnCount = Math.max(Math.floor((width + gutter) / columnWidthAndGutter), minCols);
      // the total height of each column
      var heights = new Array(columnCount).fill(0);
      var centerOffset = Math.max(Math.floor((width - columnWidthAndGutter * columnCount + gutter) / 2), 0);

      return items.reduce(function (acc, item) {
        var positions = acc;
        var height = cache.get(item);
        var position = void 0;

        if (height == null) {
          position = offscreen(columnWidth);
        } else {
          var heightAndGutter = height + gutter;
          var col = mindex$1(heights);
          var _top = heights[col];
          var _left = col * columnWidthAndGutter + centerOffset;

          heights[col] += heightAndGutter;
          position = { top: _top, left: _left, width: columnWidth, height: height };
        }
        positions.push(position);
        return positions;
      }, []);
    };
  });

  var offscreen$1 = function offscreen(width) {
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
    return {
      top: -9999,
      left: -9999,
      width: width,
      height: height
    };
  };

  var uniformRowLayout = (function (_ref) {
    var cache = _ref.cache,
        _ref$columnWidth = _ref.columnWidth,
        columnWidth = _ref$columnWidth === undefined ? 236 : _ref$columnWidth,
        _ref$gutter = _ref.gutter,
        gutter = _ref$gutter === undefined ? 14 : _ref$gutter,
        width = _ref.width,
        _ref$minCols = _ref.minCols,
        minCols = _ref$minCols === undefined ? 3 : _ref$minCols;
    return function (items) {
      if (width == null) {
        return items.map(function () {
          return offscreen$1(columnWidth);
        });
      }

      var columnWidthAndGutter = columnWidth + gutter;
      var columnCount = Math.max(Math.floor((width + gutter) / columnWidthAndGutter), minCols);

      var positions = [];
      var heights = [];

      for (var i = 0; i < items.length; i += 1) {
        var position = void 0;
        var _height = cache.get(items[i]);

        if (_height == null) {
          position = offscreen$1(columnWidth);
        } else {
          var column = i % columnCount;
          var row = Math.floor(i / columnCount);

          if (column === 0 || _height > heights[row]) {
            heights[row] = _height;
          }

          var _top = row > 0 ? heights.slice(0, row).reduce(function (sum, y) {
            return sum + y + gutter;
          }, 0) : 0;

          position = {
            top: _top,
            left: column * columnWidthAndGutter,
            width: columnWidth,
            height: _height
          };
        }
        positions.push(position);
      }
      return positions;
    };
  });

  var mindex$2 = function mindex(arr) {
    var idx = 0;
    for (var i = 0; i < arr.length; i += 1) {
      if (arr[i] < arr[idx]) {
        idx = i;
      }
    }
    return idx;
  };

  var fullWidthLayout = (function (_ref) {
    var _ref$gutter = _ref.gutter,
        gutter = _ref$gutter === undefined ? 0 : _ref$gutter,
        cache = _ref.cache,
        _ref$minCols = _ref.minCols,
        minCols = _ref$minCols === undefined ? 2 : _ref$minCols,
        _ref$idealColumnWidth = _ref.idealColumnWidth,
        idealColumnWidth = _ref$idealColumnWidth === undefined ? 240 : _ref$idealColumnWidth,
        width = _ref.width;

    if (width == null) {
      return function (items) {
        return items.map(function () {
          return {
            top: Infinity,
            left: Infinity,
            width: Infinity,
            height: Infinity
          };
        });
      };
    }

    // "This is kind of crazy!" - you
    // Yes, indeed. The "guessing" here is meant to replicate the pass that the
    // original implementation takes with CSS.
    var colguess = Math.floor(width / idealColumnWidth);
    var columnCount = Math.max(Math.floor((width - colguess * gutter) / idealColumnWidth), minCols);
    var columnWidth = Math.floor(width / columnCount);

    return function (items) {
      // the total height of each column
      var heights = new Array(columnCount).fill(0);

      return items.reduce(function (acc, item) {
        var positions = acc;
        var height = cache.get(item);
        var position = void 0;

        if (height == null) {
          position = {
            top: Infinity,
            left: Infinity,
            width: columnWidth,
            height: Infinity
          };
        } else {
          var col = mindex$2(heights);
          var _top = heights[col];
          var _left = col * columnWidth + gutter / 2;

          heights[col] += height;
          position = {
            top: _top,
            left: _left,
            width: columnWidth - gutter,
            height: height
          };
        }

        positions.push(position);
        return positions;
      }, []);
    };
  });

  var MasonryLayout = function MasonryLayout() {
    classCallCheck(this, MasonryLayout);
  };

  var UniformRowLayout = function UniformRowLayout() {
    classCallCheck(this, UniformRowLayout);
  };

  var RESIZE_DEBOUNCE = 300;
  // Multiplied against container height.
  // The amount of extra buffer space for populating visible items.
  var VIRTUAL_BUFFER_FACTOR = 0.7;

  var layoutNumberToCssDimension = function layoutNumberToCssDimension(n) {
    return n !== Infinity ? n : undefined;
  };

  /**
   * NOTE: This is to be replaced by MasonryInfiniteBeta when it is ready
   * NOTE: Please do not modify this or make sure changes in here are also
   *       replicated in MasonryBeta.
   */

  var Masonry = function (_React$Component) {
    inherits(Masonry, _React$Component);
    createClass(Masonry, null, [{
      key: 'createMeasurementStore',
      value: function createMeasurementStore() {
        // $FlowFixMe: new errors found from flow 0.96 upgrade
        return new MeasurementStore();
      }

      /**
       * Delays resize handling in case the scroll container is still being resized.
       */

    }]);

    function Masonry(props) {
      classCallCheck(this, Masonry);

      var _this = possibleConstructorReturn(this, (Masonry.__proto__ || Object.getPrototypeOf(Masonry)).call(this, props));

      _this.handleResize = debounce(function () {
        if (_this.gridWrapper) {
          _this.setState({ width: _this.gridWrapper.clientWidth });
        }
      }, RESIZE_DEBOUNCE);
      _this.updateScrollPosition = throttle(function () {
        if (!_this.scrollContainer) {
          return;
        }
        var scrollContainer = _this.scrollContainer.getScrollContainerRef();

        if (!scrollContainer) {
          return;
        }

        _this.setState({
          scrollTop: getScrollPos(scrollContainer)
        });
      });
      _this.measureContainerAsync = debounce(function () {
        _this.measureContainer();
      }, 0);

      _this.setGridWrapperRef = function (ref) {
        _this.gridWrapper = ref;
      };

      _this.setScrollContainerRef = function (ref) {
        _this.scrollContainer = ref;
      };

      _this.fetchMore = function () {
        var loadItems = _this.props.loadItems;

        if (loadItems && typeof loadItems === 'function') {
          _this.setState({
            isFetching: true
          }, function () {
            return loadItems({ from: _this.props.items.length });
          });
        }
      };

      _this.renderMasonryComponent = function (itemData, idx, position) {
        var _this$props = _this.props,
            Component = _this$props.comp,
            virtualize = _this$props.virtualize,
            virtualBoundsTop = _this$props.virtualBoundsTop,
            virtualBoundsBottom = _this$props.virtualBoundsBottom;
        var top = position.top,
            left = position.left,
            width = position.width,
            height = position.height;


        var isVisible = void 0;
        if (_this.props.scrollContainer) {
          var virtualBuffer = _this.containerHeight * VIRTUAL_BUFFER_FACTOR;
          var offsetScrollPos = _this.state.scrollTop - _this.containerOffset;
          var viewportTop = virtualBoundsTop ? offsetScrollPos - virtualBoundsTop : offsetScrollPos - virtualBuffer;
          var viewportBottom = virtualBoundsBottom ? offsetScrollPos + _this.containerHeight + virtualBoundsBottom : offsetScrollPos + _this.containerHeight + virtualBuffer;

          isVisible = !(position.top + position.height < viewportTop || position.top > viewportBottom);
        } else {
          // if no scroll container is passed in, items should always be visible
          isVisible = true;
        }

        var itemComponent = React.createElement(
          'div',
          {
            key: 'item-' + idx,
            className: [styles$i.Masonry__Item, styles$i.Masonry__Item__Mounted].join(' '),
            'data-grid-item': true,
            style: {
              top: 0,
              left: 0,
              transform: 'translateX(' + left + 'px) translateY(' + top + 'px)',
              WebkitTransform: 'translateX(' + left + 'px) translateY(' + top + 'px)',
              width: layoutNumberToCssDimension(width),
              height: layoutNumberToCssDimension(height)
            }
          },
          React.createElement(Component, { data: itemData, itemIdx: idx, isMeasuring: false })
        );

        return virtualize ? isVisible && itemComponent || null : itemComponent;
      };

      _this.containerHeight = 0;
      _this.containerOffset = 0;

      _this.state = {
        hasPendingMeasurements: props.items.some(function (item) {
          return !!item && !props.measurementStore.has(item);
        }),
        isFetching: false,
        // eslint-disable-next-line react/no-unused-state
        items: props.items,
        scrollTop: 0,
        width: undefined
      };
      return _this;
    }

    /**
     * Adds hooks after the component mounts.
     */


    createClass(Masonry, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _this2 = this;

        window.addEventListener('resize', this.handleResize);

        this.measureContainer();

        var scrollTop = this.state.scrollTop;

        if (this.scrollContainer != null) {
          var _scrollContainer = this.scrollContainer.getScrollContainerRef();
          if (_scrollContainer) {
            scrollTop = getScrollPos(_scrollContainer);
          }
        }

        this.setState(function (prevState) {
          return {
            scrollTop: scrollTop,
            width: _this2.gridWrapper ? _this2.gridWrapper.clientWidth : prevState.width
          };
        });
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps, prevState) {
        var _this3 = this;

        var _props = this.props,
            items = _props.items,
            measurementStore = _props.measurementStore;


        this.measureContainerAsync();

        if (prevState.width != null && this.state.width !== prevState.width) {
          measurementStore.reset();
        }
        // calculate whether we still have pending measurements
        var hasPendingMeasurements = items.some(function (item) {
          return !!item && !measurementStore.has(item);
        });
        if (hasPendingMeasurements || hasPendingMeasurements !== this.state.hasPendingMeasurements || prevState.width == null) {
          this.insertAnimationFrame = requestAnimationFrame(function () {
            _this3.setState({
              hasPendingMeasurements: hasPendingMeasurements
            });
          });
        }
      }

      /**
       * Remove listeners when unmounting.
       */

    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (this.insertAnimationFrame) {
          cancelAnimationFrame(this.insertAnimationFrame);
        }

        // Make sure async methods are cancelled.
        this.measureContainerAsync.clearTimeout();
        this.handleResize.clearTimeout();
        this.updateScrollPosition.clearTimeout();

        window.removeEventListener('resize', this.handleResize);
      }
    }, {
      key: 'measureContainer',
      value: function measureContainer() {
        if (this.scrollContainer != null) {
          var _scrollContainer2 = this.scrollContainer;

          var scrollContainerRef = _scrollContainer2.getScrollContainerRef();
          if (scrollContainerRef) {
            this.containerHeight = getElementHeight(scrollContainerRef);
            var el = this.gridWrapper;
            if (el instanceof HTMLElement) {
              var relativeScrollTop = getRelativeScrollTop(scrollContainerRef);
              this.containerOffset = el.getBoundingClientRect().top + relativeScrollTop;
            }
          }
        }
      }

      /**
       * Clear measurements/positions and force a reflow of the entire grid.
       * Only use this if absolutely necessary - ex: We need to reflow items if the
       * number of columns we would display should change after a resize.
       */

    }, {
      key: 'reflow',
      value: function reflow() {
        this.props.measurementStore.reset();
        this.measureContainer();
        this.forceUpdate();
      }
    }, {
      key: 'render',
      value: function render() {
        var _this4 = this;

        var _props2 = this.props,
            columnWidth = _props2.columnWidth,
            Component = _props2.comp,
            flexible = _props2.flexible,
            gutter = _props2.gutterWidth,
            measurementStore = _props2.measurementStore,
            items = _props2.items,
            minCols = _props2.minCols;
        var _state = this.state,
            hasPendingMeasurements = _state.hasPendingMeasurements,
            width = _state.width;


        var layout = void 0;
        if (flexible && width !== null) {
          layout = fullWidthLayout({
            gutter: gutter,
            cache: measurementStore,
            minCols: minCols,
            idealColumnWidth: columnWidth,
            width: width
          });
        } else if (this.props.layout === UniformRowLayoutSymbol || this.props.layout instanceof UniformRowLayout) {
          layout = uniformRowLayout({
            cache: measurementStore,
            columnWidth: columnWidth,
            gutter: gutter,
            minCols: minCols,
            width: width
          });
        } else {
          layout = defaultLayout({
            cache: measurementStore,
            columnWidth: columnWidth,
            gutter: gutter,
            minCols: minCols,
            width: width
          });
        }

        var gridBody = void 0;
        if (width == null && hasPendingMeasurements) {
          // When hyrdating from a server render, we don't have the width of the grid
          // and the measurement store is empty
          gridBody = React.createElement(
            'div',
            {
              className: styles$i.Masonry,
              style: { height: 0, width: '100%' },
              ref: this.setGridWrapperRef
            },
            items.filter(function (item) {
              return item;
            }).map(function (item, i) {
              return React.createElement(
                'div',
                { // keep this in sync with renderMasonryComponent
                  className: 'static',
                  'data-grid-item': true,
                  key: i,
                  style: {
                    top: 0,
                    left: 0,
                    transform: 'translateX(0px) translateY(0px)',
                    WebkitTransform: 'translateX(0px) translateY(0px)',
                    width: flexible ? undefined : layoutNumberToCssDimension(columnWidth) // we can't set a width for server rendered flexible items
                  },
                  ref: function ref(el) {
                    if (el && !flexible) {
                      // only measure flexible items on client
                      measurementStore.set(item, el.clientHeight);
                    }
                  }
                },
                React.createElement(Component, { data: item, itemIdx: i, isMeasuring: false })
              );
            })
          );
        } else if (width == null) {
          // When the width is empty (usually after a re-mount) render an empty
          // div to collect the width for layout
          gridBody = React.createElement('div', { style: { width: '100%' }, ref: this.setGridWrapperRef });
        } else {
          // Full layout is possible
          var itemsToRender = items.filter(function (item) {
            return item && measurementStore.has(item);
          });
          var itemsToMeasure = items.filter(function (item) {
            return item && !measurementStore.has(item);
          }).slice(0, minCols);

          var positions = layout(itemsToRender);
          var measuringPositions = layout(itemsToMeasure);
          // Math.max() === -Infinity when there are no positions
          var height = positions.length ? Math.max.apply(Math, toConsumableArray(positions.map(function (pos) {
            return pos.top + pos.height;
          }))) : 0;
          gridBody = React.createElement(
            'div',
            { style: { width: '100%' }, ref: this.setGridWrapperRef },
            React.createElement(
              'div',
              { className: styles$i.Masonry, style: { height: height, width: width } },
              itemsToRender.map(function (item, i) {
                return _this4.renderMasonryComponent(item, i, positions[i]);
              })
            ),
            React.createElement(
              'div',
              { className: styles$i.Masonry, style: { width: width } },
              itemsToMeasure.map(function (data, i) {
                // itemsToMeasure is always the length of minCols, so i will always be 0..minCols.length
                // we normalize the index here relative to the item list as a whole so that itemIdx is correct
                // and so that React doesnt reuse the measurement nodes
                var measurementIndex = itemsToRender.length + i;
                var position = measuringPositions[i];
                return React.createElement(
                  'div',
                  {
                    key: 'measuring-' + measurementIndex,
                    style: {
                      visibility: 'hidden',
                      position: 'absolute',
                      top: layoutNumberToCssDimension(position.top),
                      left: layoutNumberToCssDimension(position.left),
                      width: layoutNumberToCssDimension(position.width),
                      height: layoutNumberToCssDimension(position.height)
                    },
                    ref: function ref(el) {
                      if (el) {
                        measurementStore.set(data, el.clientHeight);
                      }
                    }
                  },
                  React.createElement(Component, {
                    data: data,
                    itemIdx: measurementIndex,
                    isMeasuring: true
                  })
                );
              })
            ),
            this.scrollContainer && React.createElement(FetchItems, {
              containerHeight: this.containerHeight,
              fetchMore: this.fetchMore,
              isFetching: this.state.isFetching || this.state.hasPendingMeasurements,
              scrollHeight: height,
              scrollTop: this.state.scrollTop
            })
          );
        }

        return this.props.scrollContainer ? React.createElement(
          ScrollContainer,
          {
            ref: this.setScrollContainerRef,
            onScroll: this.updateScrollPosition,
            scrollContainer: this.props.scrollContainer
          },
          gridBody
        ) : gridBody;
      }
    }], [{
      key: 'getDerivedStateFromProps',
      value: function getDerivedStateFromProps(props, state) {
        var items = props.items,
            measurementStore = props.measurementStore;
        // whenever we're receiving new props, determine whether any items need to be measured
        // TODO - we should treat items as immutable

        var hasPendingMeasurements = items.some(function (item) {
          return !measurementStore.has(item);
        });

        // Shallow compare all items, if any change reflow the grid.
        for (var i = 0; i < items.length; i += 1) {
          // We've reached the end of our current props and everything matches.
          // If we hit this case it means we need to insert new items.
          if (state.items[i] === undefined) {
            return {
              hasPendingMeasurements: hasPendingMeasurements,
              items: items,
              isFetching: false
            };
          }

          // Reset grid items when:
          if (
          // An item object ref does not match.
          items[i] !== state.items[i] ||
          // Or less items than we currently have are passed in.
          items.length < state.items.length) {
            return {
              hasPendingMeasurements: hasPendingMeasurements,
              items: items,
              isFetching: false
            };
          }
        }

        // Reset items if new items array is empty.
        if (items.length === 0 && state.items.length > 0) {
          return {
            hasPendingMeasurements: hasPendingMeasurements,
            items: items,
            isFetching: false
          };
        }
        if (hasPendingMeasurements !== state.hasPendingMeasurements) {
          // make sure we always update hasPendingMeasurements
          return {
            hasPendingMeasurements: hasPendingMeasurements,
            items: items
          };
        }

        // Return null to indicate no change to state.
        return null;
      }
    }]);
    return Masonry;
  }(React.Component);

  Masonry.propTypes = {
    /**
     * The preferred/target item width. If `flexible` is set, the item width will
     * grow to fill column space, and shrink to fit if below min columns.
     */
    columnWidth: PropTypes.number,

    /**
     * The component to render.
     */
    /* eslint react/no-unused-prop-types: 0 */
    comp: PropTypes.func.isRequired,

    /**
     * The preferred/target item width. Item width will grow to fill
     * column space, and shrink to fit if below min columns.
     */
    flexible: PropTypes.bool,

    /**
     * The amount of space between each item.
     */
    gutterWidth: PropTypes.number,

    /**
     * An array of all objects to display in the grid.
     */
    items: PropTypes.arrayOf(PropTypes.shape({})).isRequired,

    /**
     * Measurement Store
     */
    measurementStore: PropTypes.instanceOf(MeasurementStore),

    /**
     * Layout system to use for items
     */
    layout: PropTypes.oneOfType([PropTypes.instanceOf(MasonryLayout), PropTypes.instanceOf(UniformRowLayout), PropTypes.symbol]),

    /**
     * A callback which the grid calls when we need to load more items as the user scrolls.
     * The callback should update the state of the items, and pass those in as props
     * to this component.
     */
    loadItems: PropTypes.func,

    /**
     * Minimum number of columns to display.
     */
    minCols: PropTypes.number,

    /**
     * Function that the grid calls to get the scroll container.
     * This is required if the grid is expected to be scrollable.
     */
    scrollContainer: PropTypes.func,

    /**
     * Whether or not to use actual virtualization
     */
    virtualize: PropTypes.bool
  };
  Masonry.defaultProps = {
    columnWidth: 236,
    // $FlowFixMe: new errors found from flow 0.96 upgrade
    measurementStore: new MeasurementStore(),
    minCols: 3,
    layout: DefaultLayoutSymbol,
    loadItems: function loadItems() {},
    virtualize: false
  };

  var RESIZE_DEBOUNCE$1 = 300;
  // Multiplied against container height.
  // The amount of extra buffer space for populating visible items.
  var VIRTUAL_BUFFER_FACTOR$1 = 0.7;

  var layoutNumberToCssDimension$1 = function layoutNumberToCssDimension(n) {
    return n !== Infinity ? n : undefined;
  };

  function layoutClass(_ref, _ref2) {
    var columnWidth = _ref.columnWidth,
        flexible = _ref.flexible,
        gutter = _ref.gutterWidth,
        layout = _ref.layout,
        measurementStore = _ref.measurementStore,
        minCols = _ref.minCols;
    var width = _ref2.width;

    if (flexible && width !== null) {
      return fullWidthLayout({
        gutter: gutter,
        cache: measurementStore,
        minCols: minCols,
        idealColumnWidth: columnWidth,
        width: width
      });
    }
    if (layout === UniformRowLayoutSymbol || layout instanceof UniformRowLayout) {
      return uniformRowLayout({
        cache: measurementStore,
        columnWidth: columnWidth,
        gutter: gutter,
        minCols: minCols,
        width: width
      });
    }
    return defaultLayout({
      cache: measurementStore,
      columnWidth: columnWidth,
      gutter: gutter,
      minCols: minCols,
      width: width
    });
  }

  function statesForRendering(props, state) {
    var measurementStore = props.measurementStore,
        minCols = props.minCols;
    var items = state.items;

    // Full layout is possible

    var itemsToRender = items.filter(function (item) {
      return item && measurementStore.has(item);
    });

    var layout = layoutClass(props, state);
    var renderPositions = layout(itemsToRender);
    // Math.max() === -Infinity when there are no renderPositions
    var height = renderPositions.length ? Math.max.apply(Math, toConsumableArray(renderPositions.map(function (pos) {
      return pos.top + pos.height;
    }))) : 0;

    // $FlowIssue https://github.com/facebook/flow/issues/6151
    var itemsToMeasure = items.filter(function (item) {
      return item && !measurementStore.has(item);
    }).slice(0, minCols);
    var measuringPositions = layout(itemsToMeasure);

    return {
      height: height,
      itemsToRender: itemsToRender,
      itemsToMeasure: itemsToMeasure,
      measuringPositions: measuringPositions,
      renderPositions: renderPositions
    };
  }

  /**
   * The will be the new MasonryBeta that will not have any fetching concerns.
   *
   * For now, it differs with Masonry only by not having any fetching logic.
   *
   * It is in beta until it can be battle tested.
   */

  var MasonryBeta = function (_React$Component) {
    inherits(MasonryBeta, _React$Component);

    function MasonryBeta(props) {
      classCallCheck(this, MasonryBeta);

      var _this = possibleConstructorReturn(this, (MasonryBeta.__proto__ || Object.getPrototypeOf(MasonryBeta)).call(this, props));

      _this.handleResize = debounce(function () {
        if (_this.gridWrapper) {
          _this.setState({ width: _this.gridWrapper.clientWidth });
        }
      }, RESIZE_DEBOUNCE$1);
      _this.updateScrollPosition = throttle(function () {
        if (!_this.scrollContainer) {
          return;
        }
        var scrollContainer = _this.scrollContainer.getScrollContainerRef();

        if (!scrollContainer) {
          return;
        }

        _this.setState({
          scrollTop: getScrollPos(scrollContainer)
        });

        _this.handleVirtualizationWindowUpdate();
      });
      _this.measureContainerAsync = debounce(function () {
        _this.measureContainer();
      }, 0);

      _this.setGridWrapperRef = function (ref) {
        _this.gridWrapper = ref;
      };

      _this.setScrollContainerRef = function (ref) {
        _this.scrollContainer = ref;
      };

      _this.handleVirtualizationWindowUpdate = function () {
        var _this$state = _this.state,
            height = _this$state.height,
            width = _this$state.width;

        if (typeof _this.props.onVirtualizationWindowUpdate === 'function' && _this.containerHeight) {
          var _viewport = {
            top: _this.state.scrollTop,
            left: 0,
            height: _this.containerHeight,
            width: width || 0
          };
          var _content = {
            top: _this.containerOffset,
            left: 0,
            height: height,
            width: width || 0
          };

          _this.props.onVirtualizationWindowUpdate(_content, _viewport);
        }
      };

      _this.handleOnAutoMeasuringUpdate = function (state) {
        if (_this.props.onAutoMeasuringUpdate) {
          _this.props.onAutoMeasuringUpdate(state);
        }
      };

      _this.renderMasonryComponent = function (itemData, idx, position) {
        var _this$props = _this.props,
            Component = _this$props.comp,
            virtualize = _this$props.virtualize,
            virtualBoundsTop = _this$props.virtualBoundsTop,
            virtualBoundsBottom = _this$props.virtualBoundsBottom;
        var top = position.top,
            left = position.left,
            width = position.width,
            height = position.height;


        var isVisible = void 0;
        if (_this.props.scrollContainer) {
          var virtualBuffer = _this.containerHeight * VIRTUAL_BUFFER_FACTOR$1;
          var offsetScrollPos = _this.state.scrollTop - _this.containerOffset;
          var viewportTop = virtualBoundsTop ? offsetScrollPos - virtualBoundsTop : offsetScrollPos - virtualBuffer;
          var viewportBottom = virtualBoundsBottom ? offsetScrollPos + _this.containerHeight + virtualBoundsBottom : offsetScrollPos + _this.containerHeight + virtualBuffer;

          isVisible = !(position.top + position.height < viewportTop || position.top > viewportBottom);
        } else {
          // if no scroll container is passed in, items should always be visible
          isVisible = true;
        }

        var itemComponent = React.createElement(
          'div',
          {
            key: 'item-' + idx,
            className: [styles$i.Masonry__Item, styles$i.Masonry__Item__Mounted].join(' '),
            'data-grid-item': true,
            style: {
              top: 0,
              left: 0,
              transform: 'translateX(' + left + 'px) translateY(' + top + 'px)',
              WebkitTransform: 'translateX(' + left + 'px) translateY(' + top + 'px)',
              width: layoutNumberToCssDimension$1(width),
              height: layoutNumberToCssDimension$1(height)
            }
          },
          React.createElement(Component, { data: itemData, itemIdx: idx, isMeasuring: false })
        );

        return virtualize ? isVisible && itemComponent || null : itemComponent;
      };

      _this.containerHeight = 0;
      _this.containerOffset = 0;

      _this.state = {
        hasPendingMeasurements: props.items.some(function (item) {
          return !!item && !props.measurementStore.has(item);
        }),
        height: 0,
        itemsToRender: [],
        itemsToMeasure: [],
        // eslint-disable-next-line react/no-unused-state
        items: props.items,
        measuringPositions: [],
        renderPositions: [],
        scrollTop: 0,
        width: undefined
      };
      return _this;
    }

    /**
     * Adds hooks after the component mounts.
     */

    /**
     * Delays resize handling in case the scroll container is still being resized.
     */


    createClass(MasonryBeta, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _this2 = this;

        window.addEventListener('resize', this.handleResize);

        this.measureContainer();

        var scrollTop = this.state.scrollTop;

        if (this.scrollContainer != null) {
          var _scrollContainer = this.scrollContainer.getScrollContainerRef();
          if (_scrollContainer) {
            scrollTop = getScrollPos(_scrollContainer);
          }
        }

        this.setState(function (prevState) {
          var width = _this2.gridWrapper ? _this2.gridWrapper.clientWidth : prevState.width;
          var stateWithWidth = _extends({}, _this2.state, { width: width });
          return _extends({
            scrollTop: scrollTop,
            width: width
          }, statesForRendering(_this2.props, stateWithWidth));
        });

        // need to make sure parent component has the correct pending measurement value
        this.handleOnAutoMeasuringUpdate(this.state.hasPendingMeasurements ? 'measuring' : 'idle');
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps, prevState) {
        var _this3 = this;

        var _props = this.props,
            items = _props.items,
            measurementStore = _props.measurementStore;


        this.measureContainerAsync();

        if (prevState.width != null && this.state.width !== prevState.width) {
          measurementStore.reset();
        }
        // calculate whether we still have pending measurements
        var hasPendingMeasurements = items.some(function (item) {
          return !!item && !measurementStore.has(item);
        });

        if (hasPendingMeasurements && !prevState.hasPendingMeasurements) {
          this.handleOnAutoMeasuringUpdate('measuring');
        } else if (!hasPendingMeasurements && prevState.hasPendingMeasurements) {
          this.handleOnAutoMeasuringUpdate('idle');
        }
        this.handleVirtualizationWindowUpdate();

        if (hasPendingMeasurements || hasPendingMeasurements !== this.state.hasPendingMeasurements || prevState.width == null) {
          this.insertAnimationFrame = requestAnimationFrame(function () {
            var renderingStates = statesForRendering(_this3.props, _this3.state);
            _this3.setState(_extends({
              hasPendingMeasurements: hasPendingMeasurements
            }, renderingStates));
          });
        } else if (hasPendingMeasurements || prevState.items !== items) {
          this.insertAnimationFrame = requestAnimationFrame(function () {
            var renderingStates = statesForRendering(_this3.props, _this3.state);
            _this3.setState(_extends({}, renderingStates));
          });
        }
      }

      /**
       * Remove listeners when unmounting.
       */

    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (this.insertAnimationFrame) {
          cancelAnimationFrame(this.insertAnimationFrame);
        }

        // Make sure async methods are cancelled.
        this.measureContainerAsync.clearTimeout();
        this.handleResize.clearTimeout();
        this.updateScrollPosition.clearTimeout();

        window.removeEventListener('resize', this.handleResize);
      }
    }, {
      key: 'measureContainer',
      value: function measureContainer() {
        if (this.scrollContainer != null) {
          var _scrollContainer2 = this.scrollContainer;

          var scrollContainerRef = _scrollContainer2.getScrollContainerRef();
          if (scrollContainerRef) {
            this.containerHeight = getElementHeight(scrollContainerRef);
            var el = this.gridWrapper;
            if (el instanceof HTMLElement) {
              var relativeScrollTop = getRelativeScrollTop(scrollContainerRef);
              this.containerOffset = el.getBoundingClientRect().top + relativeScrollTop;
            }
          }
        }
      }

      /**
       * Clear measurements/positions and force a reflow of the entire grid.
       * Only use this if absolutely necessary - ex: We need to reflow items if the
       * number of columns we would display should change after a resize.
       */

    }, {
      key: 'reflow',
      value: function reflow() {
        this.props.measurementStore.reset();
        this.measureContainer();
        this.handleVirtualizationWindowUpdate();
        this.forceUpdate();
      }
    }, {
      key: 'render',
      value: function render() {
        var _this4 = this;

        var _props2 = this.props,
            columnWidth = _props2.columnWidth,
            Component = _props2.comp,
            flexible = _props2.flexible,
            measurementStore = _props2.measurementStore,
            items = _props2.items;
        var _state = this.state,
            hasPendingMeasurements = _state.hasPendingMeasurements,
            height = _state.height,
            itemsToMeasure = _state.itemsToMeasure,
            itemsToRender = _state.itemsToRender,
            measuringPositions = _state.measuringPositions,
            renderPositions = _state.renderPositions,
            width = _state.width;

        var gridBody = void 0;
        if (width == null && hasPendingMeasurements) {
          // When hyrdating from a server render, we don't have the width of the grid
          // and the measurement store is empty
          gridBody = React.createElement(
            'div',
            {
              className: styles$i.Masonry,
              style: { height: 0, width: '100%' },
              ref: this.setGridWrapperRef
            },
            items.filter(function (item) {
              return item;
            }).map(function (item, i) {
              return React.createElement(
                'div',
                { // keep this in sync with renderMasonryComponent
                  className: 'static',
                  'data-grid-item': true,
                  key: i,
                  style: {
                    top: 0,
                    left: 0,
                    transform: 'translateX(0px) translateY(0px)',
                    WebkitTransform: 'translateX(0px) translateY(0px)',
                    width: flexible ? undefined : layoutNumberToCssDimension$1(columnWidth) // we can't set a width for server rendered flexible items
                  },
                  ref: function ref(el) {
                    if (el && !flexible) {
                      // only measure flexible items on client
                      measurementStore.set(item, el.clientHeight);
                    }
                  }
                },
                React.createElement(Component, { data: item, itemIdx: i, isMeasuring: false })
              );
            })
          );
        } else if (width == null) {
          // When the width is empty (usually after a re-mount) render an empty
          // div to collect the width for layout
          gridBody = React.createElement('div', { style: { width: '100%' }, ref: this.setGridWrapperRef });
        } else {
          gridBody = React.createElement(
            'div',
            { style: { width: '100%' }, ref: this.setGridWrapperRef },
            React.createElement(
              'div',
              { className: styles$i.Masonry, style: { height: height, width: width } },
              itemsToRender.map(function (item, i) {
                return (
                  // $FlowFixMe this is the right definition, it an Array<T>
                  _this4.renderMasonryComponent(item, i, renderPositions[i])
                );
              })
            ),
            React.createElement(
              'div',
              { className: styles$i.Masonry, style: { width: width } },
              itemsToMeasure.map(function (data, i) {
                // itemsToMeasure is always the length of minCols, so i will always be 0..minCols.length
                // we normalize the index here relative to the item list as a whole so that itemIdx is correct
                // and so that React doesnt reuse the measurement nodes
                var measurementIndex = itemsToRender.length + i;
                var position = measuringPositions[i];
                return React.createElement(
                  'div',
                  {
                    key: 'measuring-' + measurementIndex,
                    style: {
                      visibility: 'hidden',
                      position: 'absolute',
                      top: layoutNumberToCssDimension$1(position.top),
                      left: layoutNumberToCssDimension$1(position.left),
                      width: layoutNumberToCssDimension$1(position.width),
                      height: layoutNumberToCssDimension$1(position.height)
                    },
                    ref: function ref(el) {
                      if (el) {
                        measurementStore.set(data, el.clientHeight);
                      }
                    }
                  },
                  React.createElement(Component, {
                    data: data,
                    itemIdx: measurementIndex,
                    isMeasuring: true
                  })
                );
              })
            )
          );
        }

        return this.props.scrollContainer ? React.createElement(
          ScrollContainer,
          {
            ref: this.setScrollContainerRef,
            onScroll: this.updateScrollPosition,
            scrollContainer: this.props.scrollContainer
          },
          gridBody
        ) : gridBody;
      }
    }], [{
      key: 'getDerivedStateFromProps',
      value: function getDerivedStateFromProps(props, state) {
        var items = props.items,
            measurementStore = props.measurementStore;
        // whenever we're receiving new props, determine whether any items need to be measured
        // TODO - we should treat items as immutable

        var hasPendingMeasurements = items.some(function (item) {
          return item && !measurementStore.has(item);
        });

        var newState = _extends({}, state, {
          hasPendingMeasurements: hasPendingMeasurements,
          items: items
        });

        // Shallow compare all items, if any change reflow the grid.
        for (var i = 0; i < items.length; i += 1) {
          // We've reached the end of our current props and everything matches.
          // If we hit this case it means we need to insert new items.
          if (state.items[i] === undefined) {
            return _extends({
              hasPendingMeasurements: hasPendingMeasurements,
              items: items
            }, statesForRendering(props, newState));
          }

          // Reset grid items when:
          if (
          // An item object ref does not match.
          items[i] !== state.items[i] ||
          // Or less items than we currently have are passed in.
          items.length < state.items.length) {
            return _extends({
              hasPendingMeasurements: hasPendingMeasurements,
              items: items
            }, statesForRendering(props, newState));
          }
        }

        // Reset items if new items array is empty.
        if (items.length === 0 && state.items.length > 0) {
          return _extends({
            hasPendingMeasurements: hasPendingMeasurements,
            items: items
          }, statesForRendering(props, newState));
        }
        if (hasPendingMeasurements !== state.hasPendingMeasurements) {
          // make sure we always update hasPendingMeasurements
          return _extends({
            hasPendingMeasurements: hasPendingMeasurements,
            items: items
          }, statesForRendering(props, newState));
        }

        // Return null to indicate no change to state.
        return null;
      }
    }]);
    return MasonryBeta;
  }(React.Component);

  MasonryBeta.propTypes = {
    /**
     * The preferred/target item width. If `flexible` is set, the item width will
     * grow to fill column space, and shrink to fit if below min columns.
     */
    columnWidth: PropTypes.number,

    /**
     * The component to render.
     */
    /* eslint react/no-unused-prop-types: 0 */
    comp: PropTypes.func.isRequired,

    /**
     * The preferred/target item width. Item width will grow to fill
     * column space, and shrink to fit if below min columns.
     */
    flexible: PropTypes.bool,

    /**
     * The amount of space between each item.
     */
    gutterWidth: PropTypes.number,

    /**
     * An array of all objects to display in the grid.
     */
    items: PropTypes.arrayOf(PropTypes.shape({})).isRequired,

    /**
     * Measurement Store
     */
    measurementStore: PropTypes.instanceOf(MeasurementStore),

    /**
     * Layout system to use for items
     */
    layout: PropTypes.oneOfType([PropTypes.instanceOf(MasonryLayout), PropTypes.instanceOf(UniformRowLayout), PropTypes.symbol]),

    /**
     * A callback which the grid calls when we need to load more items as the user scrolls.
     * The callback should update the state of the items, and pass those in as props
     * to this component.
     */
    loadItems: PropTypes.func,

    /**
     * Minimum number of columns to display.
     */
    minCols: PropTypes.number,

    /**
     * Function that the grid calls to get the scroll container.
     * This is required if the grid is expected to be scrollable.
     */
    scrollContainer: PropTypes.func,

    /**
     * Whether or not to use actual virtualization
     */
    virtualize: PropTypes.bool
  };
  MasonryBeta.defaultProps = {
    columnWidth: 236,
    // $FlowFixMe: new errors found from flow 0.96 upgrade
    measurementStore: new MeasurementStore(),
    minCols: 3,
    layout: DefaultLayoutSymbol,
    loadItems: function loadItems() {},
    virtualize: false
  };

  /**
   * This MasonryInfiniteBeta is backward compatible with Masonry and
   * serves to help with migrating to a Masrony that doesn't have
   * the scrol fetch concerns.
   *
   * It is in beta so that it can be battle tested.
   *
   */
  var MasonryInfiniteBeta = function (_React$Component) {
    inherits(MasonryInfiniteBeta, _React$Component);
    createClass(MasonryInfiniteBeta, null, [{
      key: 'createMeasurementStore',
      value: function createMeasurementStore() {
        // $FlowFixMe: new errors found from flow 0.96 upgrade
        return new MeasurementStore();
      }
    }]);

    function MasonryInfiniteBeta(props) {
      classCallCheck(this, MasonryInfiniteBeta);

      var _this = possibleConstructorReturn(this, (MasonryInfiniteBeta.__proto__ || Object.getPrototypeOf(MasonryInfiniteBeta)).call(this, props));

      _this.onVirtualizationWindowUpdate = function (content, viewport) {
        var _this$state = _this.state,
            containerHeight = _this$state.containerHeight,
            scrollTop = _this$state.scrollTop,
            scrollHeight = _this$state.scrollHeight;

        if (viewport.height !== containerHeight || viewport.top !== scrollTop || content.height !== scrollHeight) {
          _this.setState({
            containerHeight: viewport.height,
            scrollTop: viewport.top,
            scrollHeight: content.height
          });
        }
      };

      _this.setRef = function (ref) {
        if (ref) {
          _this.gridRef = ref;
        }
      };

      _this.fetchMore = function () {
        var loadItems = _this.props.loadItems;

        if (loadItems && typeof loadItems === 'function') {
          _this.setState({
            isFetching: true
          }, function () {
            return loadItems({ from: _this.props.items.length });
          });
        }
      };

      _this.handleOnAutoMeasuringUpdate = function (state) {
        var hasPendingMeasurements = state === 'measuring';
        if (_this.state.hasPendingMeasurements !== hasPendingMeasurements) {
          _this.setState({ hasPendingMeasurements: hasPendingMeasurements });
        }

        if (typeof _this.props.onAutoMeasuringUpdate === 'function') {
          _this.props.onAutoMeasuringUpdate(state);
        }
      };

      _this.reflow = function () {
        if (_this.gridRef) {
          _this.gridRef.reflow();
        }
      };

      _this.handleResize = function () {
        if (_this.gridRef) {
          _this.gridRef.handleResize();
        }
      };

      _this.state = {
        containerHeight: 0,
        hasPendingMeasurements: false,
        isFetching: false,
        // eslint-disable-next-line react/no-unused-state
        items: props.items,
        scrollTop: 0,
        scrollHeight: 0
      };
      return _this;
    }

    /**
     * Content layer and Viewport layer is as defined in Collection.
     */


    createClass(MasonryInfiniteBeta, [{
      key: 'render',
      value: function render() {
        return this.props.scrollContainer ? React.createElement(
          React.Fragment,
          null,
          React.createElement(FetchItems, {
            containerHeight: this.state.containerHeight,
            fetchMore: this.fetchMore,
            isFetching: this.state.isFetching || this.state.hasPendingMeasurements,
            scrollHeight: this.state.scrollHeight,
            scrollTop: this.state.scrollTop
          }),
          React.createElement(MasonryBeta, _extends({}, this.props, {
            onVirtualizationWindowUpdate: this.onVirtualizationWindowUpdate,
            onAutoMeasuringUpdate: this.handleOnAutoMeasuringUpdate,
            ref: this.setRef
          }))
        ) : React.createElement(MasonryBeta, _extends({}, this.props, { ref: this.setRef }));
      }
    }], [{
      key: 'getDerivedStateFromProps',
      value: function getDerivedStateFromProps(props, state) {
        var items = props.items;

        // assume immutable items

        if (props.items !== state.items) {
          return {
            items: items,
            isFetching: false
          };
        }

        // Return null to indicate no change to state.
        return null;
      }
    }]);
    return MasonryInfiniteBeta;
  }(React.Component);

  MasonryInfiniteBeta.defaultProps = MasonryBeta.defaultProps;

  var NoScrollBehavior = function (_React$Component) {
    inherits(NoScrollBehavior, _React$Component);

    function NoScrollBehavior(props) {
      classCallCheck(this, NoScrollBehavior);

      var _this = possibleConstructorReturn(this, (NoScrollBehavior.__proto__ || Object.getPrototypeOf(NoScrollBehavior)).call(this, props));

      _this.prevOverflow = null;
      return _this;
    }

    createClass(NoScrollBehavior, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        if (typeof window !== 'undefined') {
          this.prevOverflow = window.document.body.style.overflow;
          window.document.body.style.overflow = 'hidden';
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (typeof window !== 'undefined') {
          window.document.body.style.overflow = this.prevOverflow;
        }
      }
    }, {
      key: 'render',
      value: function render() {
        return this.props.children;
      }
    }]);
    return NoScrollBehavior;
  }(React.Component);

  function queryFocusableAll(el) {
    var selector = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'iframe', 'object', 'embed', '[tabindex="-1"]', '[tabindex="0"]', '[contenteditable]', 'audio[controls]', 'video[controls]', 'summary'].join(',');
    return el.querySelectorAll(selector);
  }

  var focusElement = function focusElement(el) {
    if (typeof el.focus === 'function') {
      el.focus();
    }
  };

  var TrapFocusBehavior = function (_React$Component) {
    inherits(TrapFocusBehavior, _React$Component);

    function TrapFocusBehavior() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, TrapFocusBehavior);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TrapFocusBehavior.__proto__ || Object.getPrototypeOf(TrapFocusBehavior)).call.apply(_ref, [this].concat(args))), _this), _this.setElRef = function (el) {
        if (el) {
          _this.el = el;
        }
      }, _this.handleFocus = function (event) {
        if (!_this.el || event.target instanceof Node && _this.el.contains(event.target)) {
          return;
        }

        event.stopPropagation();
        event.preventDefault();
        _this.focusFirstChild();
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(TrapFocusBehavior, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.previouslyFocusedEl = document.activeElement;
        this.focusFirstChild();
        document.addEventListener('focus', this.handleFocus, true);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        document.removeEventListener('focus', this.handleFocus, true);
        if (this.previouslyFocusedEl) {
          focusElement(this.previouslyFocusedEl);
        }
      }
    }, {
      key: 'focusFirstChild',
      value: function focusFirstChild() {
        var el = this.el;

        if (el) {
          focusElement(queryFocusableAll(el)[0]);
        }
      }
    }, {
      key: 'render',
      value: function render() {
        return React.createElement(
          'div',
          { ref: this.setElRef },
          this.props.children
        );
      }
    }]);
    return TrapFocusBehavior;
  }(React.Component);

  var styles$j = { "Backdrop": "W7Y MIw Rym QLY p6V ojN Smz BsF", "container": "Fwt _he Hsu _O1 mQ8 Rym QLY gjz L4E", "wrapper": "ZHw XiG sLG _O1 qJc mix L3z lTs" };

  var SIZE_WIDTH_MAP$1 = {
    sm: 414,
    md: 544,
    lg: 804
  };

  var ESCAPE_KEY_CODE$1 = 27;

  function Backdrop(_ref) {
    var children = _ref.children;

    return React.createElement(
      React.Fragment,
      null,
      React.createElement('div', { className: styles$j.Backdrop }),
      children
    );
  }

  function Header(_ref2) {
    var heading = _ref2.heading,
        role = _ref2.role;

    if (typeof heading !== 'string') {
      return heading;
    }

    if (role === 'dialog') {
      return React.createElement(
        Box,
        {
          dangerouslySetInlineStyle: {
            __style: { paddingLeft: 50, paddingRight: 50 }
          },
          display: 'flex',
          justifyContent: 'center',
          paddingY: 5
        },
        React.createElement(
          Heading,
          { size: 'xs', accessibilityLevel: 1 },
          heading
        )
      );
    }

    return React.createElement(
      Box,
      { display: 'flex', padding: 4 },
      React.createElement(
        Heading,
        { size: 'sm', accessibilityLevel: 1 },
        heading
      )
    );
  }

  var Modal = function (_React$Component) {
    inherits(Modal, _React$Component);

    function Modal() {
      var _ref3;

      var _temp, _this, _ret;

      classCallCheck(this, Modal);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref3 = Modal.__proto__ || Object.getPrototypeOf(Modal)).call.apply(_ref3, [this].concat(args))), _this), _this.handleOutsideClick = function () {
        _this.props.onDismiss();
      }, _this.handleCloseClick = function () {
        _this.props.onDismiss();
      }, _this.handleKeyUp = function (event) {
        if (event.keyCode === ESCAPE_KEY_CODE$1) {
          _this.props.onDismiss();
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Modal, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        window.addEventListener('keyup', this.handleKeyUp);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        window.removeEventListener('keyup', this.handleKeyUp);
      }
    }, {
      key: 'render',
      value: function render() {
        var _props = this.props,
            accessibilityCloseLabel = _props.accessibilityCloseLabel,
            accessibilityModalLabel = _props.accessibilityModalLabel,
            children = _props.children,
            footer = _props.footer,
            heading = _props.heading,
            _props$role = _props.role,
            role = _props$role === undefined ? 'dialog' : _props$role,
            _props$size = _props.size,
            size = _props$size === undefined ? 'sm' : _props$size;


        var width = typeof size === 'string' ? SIZE_WIDTH_MAP$1[size] : size;

        return React.createElement(
          NoScrollBehavior,
          null,
          React.createElement(
            TrapFocusBehavior,
            null,
            React.createElement(
              'div',
              {
                'aria-label': accessibilityModalLabel,
                className: styles$j.container,
                role: role
              },
              React.createElement(
                Backdrop,
                null,
                React.createElement(
                  OutsideEventBehavior,
                  { onClick: this.handleOutsideClick },
                  React.createElement(
                    'div',
                    { className: styles$j.wrapper, tabIndex: -1, style: { width: width } },
                    React.createElement(
                      Box,
                      {
                        flex: 'grow',
                        position: 'relative',
                        display: 'flex',
                        direction: 'column',
                        width: '100%'
                      },
                      React.createElement(
                        Box,
                        { fit: true },
                        React.createElement(Header, { heading: heading, role: role }),
                        role === 'dialog' && React.createElement(
                          React.Fragment,
                          null,
                          React.createElement(
                            Box,
                            { padding: 2, position: 'absolute', top: true, right: true },
                            React.createElement(IconButton, {
                              accessibilityLabel: accessibilityCloseLabel,
                              icon: 'cancel',
                              onClick: this.handleCloseClick
                            })
                          ),
                          React.createElement(Divider, null)
                        )
                      ),
                      React.createElement(
                        Box,
                        { flex: 'grow', overflow: 'auto', position: 'relative' },
                        children
                      ),
                      React.createElement(
                        Box,
                        { fit: true },
                        footer && React.createElement(
                          Box,
                          null,
                          role === 'dialog' && React.createElement(Divider, null),
                          React.createElement(
                            Box,
                            { padding: 4 },
                            footer
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        );
      }
    }]);
    return Modal;
  }(React.Component);

  Modal.propTypes = {
    accessibilityCloseLabel: PropTypes.string.isRequired,
    accessibilityModalLabel: PropTypes.string.isRequired,
    children: PropTypes.node,
    footer: PropTypes.node,
    heading: PropTypes.oneOfType([PropTypes.string, PropTypes.node]).isRequired,
    onDismiss: PropTypes.func,
    role: PropTypes.oneOf(['alertdialog', 'dialog']),
    size: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['sm', 'md', 'lg'])])
  };

  var styles$k = { "innerCircle": "DgX Hsu", "PulseAnimation": "wD9", "outerCircle": "uWM", "AppearAnimation": "B0Z" };

  function Pulsar(_ref) {
    var paused = _ref.paused,
        _ref$size = _ref.size,
        size = _ref$size === undefined ? 135 : _ref$size;

    return React.createElement(
      Box,
      {
        dangerouslySetInlineStyle: {
          __style: {
            animationIterationCount: paused ? 0 : 'infinite',
            outline: 'none',
            boxShadow: 'none'
          }
        },
        display: paused ? 'none' : 'block',
        height: size,
        position: 'relative',
        width: size
      },
      React.createElement(
        'div',
        { className: styles$k.innerCircle },
        React.createElement('div', { className: styles$k.outerCircle })
      )
    );
  }

  Pulsar.propTypes = {
    paused: PropTypes.bool,
    size: PropTypes.number
  };

  var styles$l = { "RadioButton": "ty9 kVc Hsu INd _O1 gjz mQ8", "RadioButtonSm": "Lxa", "RadioButtonMd": "Jum", "RadioButtonIsFocused": "HGa C1J", "RadioButtonWhiteBg": "rv3 qJc", "RadioButtonLightGrayBg": "bbY gpV", "Input": "UCd MIw e43", "InputEnabled": "ac9 BG7", "InputSm": "Kso", "InputMd": "RtT", "Check": "rr2 INd", "CheckEnabled": "c0V BsF", "CheckDisabled": "eXV gfP" };

  var RadioButton = function (_React$Component) {
    inherits(RadioButton, _React$Component);

    function RadioButton() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, RadioButton);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = RadioButton.__proto__ || Object.getPrototypeOf(RadioButton)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        focused: false
      }, _this.handleChange = function (event) {
        var onChange = _this.props.onChange;
        var checked = event.target.checked;

        onChange({ checked: checked, event: event });
      }, _this.handleBlur = function () {
        return _this.setState({ focused: false });
      }, _this.handleFocus = function () {
        return _this.setState({ focused: true });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(RadioButton, [{
      key: 'render',
      value: function render() {
        var _classnames, _classnames2, _classnames3;

        var _props = this.props,
            checked = _props.checked,
            disabled = _props.disabled,
            id = _props.id,
            name = _props.name,
            size = _props.size,
            value = _props.value;
        var focused = this.state.focused;

        return React.createElement(
          'div',
          {
            className: classnames(styles$l.RadioButton, (_classnames = {}, defineProperty(_classnames, styles$l.RadioButtonIsFocused, focused), defineProperty(_classnames, styles$l.RadioButtonSm, size === 'sm'), defineProperty(_classnames, styles$l.RadioButtonMd, size === 'md'), defineProperty(_classnames, styles$l.RadioButtonWhiteBg, !disabled || checked), defineProperty(_classnames, styles$l.RadioButtonLightGrayBg, disabled && !checked), _classnames))
          },
          React.createElement('input', {
            checked: checked,
            className: classnames(styles$l.Input, (_classnames2 = {}, defineProperty(_classnames2, styles$l.InputEnabled, !disabled), defineProperty(_classnames2, styles$l.InputSm, size === 'sm'), defineProperty(_classnames2, styles$l.InputMd, size === 'md'), _classnames2)),
            disabled: disabled,
            id: id,
            name: name,
            onBlur: this.handleBlur,
            onChange: this.handleChange,
            onFocus: this.handleFocus,
            type: 'radio',
            value: value
          }),
          checked && React.createElement('div', {
            className: classnames(styles$l.Check, (_classnames3 = {}, defineProperty(_classnames3, styles$l.CheckSm, size === 'sm'), defineProperty(_classnames3, styles$l.CheckMd, size === 'md'), defineProperty(_classnames3, styles$l.CheckEnabled, !disabled), defineProperty(_classnames3, styles$l.CheckDisabled, disabled), _classnames3))
          })
        );
      }
    }]);
    return RadioButton;
  }(React.Component);

  RadioButton.propTypes = {
    checked: PropTypes.bool,
    disabled: PropTypes.bool,
    id: PropTypes.string.isRequired,
    name: PropTypes.string,
    onChange: PropTypes.func.isRequired,
    value: PropTypes.string.isRequired,
    size: PropTypes.oneOf(['sm', 'md'])
  };
  RadioButton.defaultProps = {
    checked: false,
    disabled: false,
    size: 'md'
  };

  var ScrollFetch = function (_React$PureComponent) {
    inherits(ScrollFetch, _React$PureComponent);

    function ScrollFetch() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, ScrollFetch);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ScrollFetch.__proto__ || Object.getPrototypeOf(ScrollFetch)).call.apply(_ref, [this].concat(args))), _this), _this.updatePosition = throttle(function () {
        _this.setState(_this.getScrollState());
      }), _this.state = {
        containerHeight: 0,
        scrollHeight: 0,
        scrollTop: 0
      }, _this.getScrollHeight = function () {
        var container = _this.props.container;

        if (!container) {
          return 0;
        }
        return getScrollHeight(container);
      }, _temp), possibleConstructorReturn(_this, _ret);
    }
    /**
     * Fetches additional items if needed.
     */


    createClass(ScrollFetch, [{
      key: 'componentDidMount',


      /**
       * Adds scroll listener after the component mounts.
       */
      value: function componentDidMount() {
        var _this2 = this;

        var container = this.props.container;

        if (!container) {
          return;
        }
        setTimeout(function () {
          _this2.setState(_extends({
            containerHeight: getElementHeight(container)
          }, _this2.getScrollState()));
        });
      }

      /**
       * Update scroll buffer and check after the component updates.
       */

    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        // setTimeout so the parent component can calculate renderHeight().
        this.updatePosition();
      }

      /**
       * Returns the scrollable content height.
       */

    }, {
      key: 'getScrollState',
      value: function getScrollState() {
        var _props = this.props,
            container = _props.container,
            renderHeight = _props.renderHeight;

        if (!container) {
          return null;
        }
        var scrollHeight = renderHeight || this.getScrollHeight;

        return {
          scrollHeight: scrollHeight(),
          scrollTop: getScrollPos(container)
        };
      }
    }, {
      key: 'render',
      value: function render() {
        var _state = this.state,
            containerHeight = _state.containerHeight,
            scrollHeight = _state.scrollHeight,
            scrollTop = _state.scrollTop;
        var _props2 = this.props,
            container = _props2.container,
            fetchMore = _props2.fetchMore,
            isAtEnd = _props2.isAtEnd,
            isFetching = _props2.isFetching;


        var props = {
          containerHeight: containerHeight,
          fetchMore: fetchMore,
          isAtEnd: isAtEnd,
          isFetching: isFetching,
          scrollHeight: scrollHeight,
          scrollTop: scrollTop
        };

        if (!container || isAtEnd) {
          return null;
        }
        return React.createElement(
          ScrollContainer,
          {
            onScroll: this.updatePosition,
            scrollContainer: container
          },
          React.createElement(FetchItems, props)
        );
      }
    }]);
    return ScrollFetch;
  }(React.PureComponent);


  ScrollFetch.propTypes = {
    /**
     * The scroll container to use. Defaults to window.
     */
    container: PropTypes.shape({
      addEventListener: PropTypes.func,
      removeEventListener: PropTypes.func
    }),
    renderHeight: PropTypes.func,
    isAtEnd: PropTypes.bool,
    isFetching: PropTypes.bool,
    fetchMore: PropTypes.func
  };

  ScrollFetch.defaultProps = {
    container: typeof window !== 'undefined' ? window : null
  };

  var styles$m = { "input": "ta7 iyn KI_ Hsu aZc pBj tBJ dyH iFc SMy yTZ mWe gpV L4E", "clear": "StA adn BG7 Zr3 hUC XiG" };

  var SearchField = function (_React$Component) {
    inherits(SearchField, _React$Component);

    function SearchField() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, SearchField);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SearchField.__proto__ || Object.getPrototypeOf(SearchField)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        focused: false,
        hovered: false
      }, _this.handleChange = function (event) {
        var onChange = _this.props.onChange;

        onChange({
          value: event.currentTarget.value,
          syntheticEvent: event
        });
      }, _this.handleClear = function (event) {
        var onChange = _this.props.onChange;

        onChange({ value: '', syntheticEvent: event });
      }, _this.handleMouseEnter = function () {
        return _this.setState({ hovered: true });
      }, _this.handleMouseLeave = function () {
        return _this.setState({ hovered: false });
      }, _this.handleFocus = function (event) {
        var onFocus = _this.props.onFocus;

        _this.setState({ focused: true });

        if (onFocus) {
          onFocus({
            value: event.currentTarget.value,
            syntheticEvent: event
          });
        }
      }, _this.handleBlur = function (event) {
        var onBlur = _this.props.onBlur;

        _this.setState({ focused: false });

        if (onBlur) {
          onBlur({ event: event });
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(SearchField, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            accessibilityLabel = _props.accessibilityLabel,
            autoComplete = _props.autoComplete,
            id = _props.id,
            placeholder = _props.placeholder,
            value = _props.value;
        var _state = this.state,
            focused = _state.focused,
            hovered = _state.hovered;

        // This mirrors the built in browser behavior. If there's a value, show the
        // clear button if you're hovering or if you've focused on the field

        var showClear = (focused || hovered) && value && value.length > 0;

        return React.createElement(
          Box,
          {
            display: 'flex',
            position: 'relative',
            alignItems: 'center',
            onMouseEnter: this.handleMouseEnter,
            onMouseLeave: this.handleMouseLeave,
            onFocus: this.handleFocus,
            onBlur: this.handleBlur,
            color: 'white'
          },
          React.createElement(
            Box,
            {
              dangerouslySetInlineStyle: {
                __style: {
                  pointerEvents: 'none',
                  // Added the following lines for Safari support
                  top: '50%',
                  transform: 'translateY(-50%)'
                }
              },
              position: 'absolute',
              left: true,
              paddingX: 4
            },
            React.createElement(Icon, { icon: 'search', accessibilityLabel: '' })
          ),
          React.createElement('input', {
            'aria-label': accessibilityLabel,
            autoComplete: autoComplete,
            className: styles$m.input,
            id: id,
            onChange: this.handleChange,
            placeholder: placeholder,
            role: 'searchbox',
            type: 'search',
            value: value
          }),
          showClear && React.createElement(
            Box,
            { position: 'absolute', right: true, top: true },
            React.createElement(
              'button',
              {
                className: styles$m.clear,
                onClick: this.handleClear,
                tabIndex: -1,
                type: 'button'
              },
              React.createElement(Icon, { icon: 'clear', accessibilityLabel: '' })
            )
          )
        );
      }
    }]);
    return SearchField;
  }(React.Component);

  SearchField.propTypes = {
    accessibilityLabel: PropTypes.string.isRequired,
    autoComplete: PropTypes.oneOf(['on', 'off', 'username', 'name']),
    id: PropTypes.string.isRequired,
    onBlur: PropTypes.func,
    onChange: PropTypes.func.isRequired,
    onFocus: PropTypes.func,
    placeholder: PropTypes.string,
    value: PropTypes.string
  };

  var styles$n = { "SegmentedControl": "l92 Hsu gpV _O1 b8T", "md": "XTe aZc", "lg": "BXc xD4", "item": "ope iyn ujU e43 adn BG7", "itemIsNotSelected": "izI", "itemIsSelected": "zHr qJc" };

  function SegmentedControl(props) {
    var _classnames;

    var items = props.items,
        onChange = props.onChange,
        responsive = props.responsive,
        selectedItemIndex = props.selectedItemIndex,
        _props$size = props.size,
        size = _props$size === undefined ? 'md' : _props$size;

    var buttonWidth = responsive ? undefined : Math.floor(100 / Math.max(1, items.length)) + '%';
    return React.createElement(
      'div',
      {
        className: classnames(styles$n.SegmentedControl, (_classnames = {}, defineProperty(_classnames, styles$n.md, size === 'md'), defineProperty(_classnames, styles$n.lg, size === 'lg'), _classnames)),
        role: 'tablist'
      },
      items.map(function (item, i) {
        var _classnames2;

        var isSelected = i === selectedItemIndex;
        var cs = classnames(styles$n.item, (_classnames2 = {}, defineProperty(_classnames2, styles$n.itemIsNotSelected, !isSelected), defineProperty(_classnames2, styles$n.itemIsSelected, isSelected), _classnames2));
        return React.createElement(
          'button',
          {
            'aria-selected': isSelected,
            className: cs,
            key: i,
            onClick: function onClick(e) {
              return onChange({ event: e, activeIndex: i });
            },
            role: 'tab',
            type: 'button',
            style: { width: buttonWidth }
          },
          typeof item === 'string' ? React.createElement(
            Text,
            {
              bold: true,
              color: isSelected ? 'darkGray' : 'gray',
              align: 'center',
              size: size
            },
            item
          ) : React.createElement(
            Box,
            { display: 'flex', justifyContent: 'center' },
            item
          )
        );
      })
    );
  }

  SegmentedControl.propTypes = {
    items: PropTypes.arrayOf(PropTypes.node).isRequired,
    onChange: PropTypes.func.isRequired,
    responsive: PropTypes.bool,
    selectedItemIndex: PropTypes.number.isRequired,
    size: PropTypes.oneOf(['md', 'lg'])
  };

  function FormErrorMessage(_ref) {
    var id = _ref.id,
        _ref$text = _ref.text,
        text = _ref$text === undefined ? '' : _ref$text;

    return React.createElement(
      Text,
      { color: 'orange' },
      React.createElement(
        'span',
        { id: id + '-error' },
        text
      )
    );
  }

  FormErrorMessage.propTypes = {
    id: PropTypes.string.isRequired,
    text: PropTypes.string
  };

  var styles$o = { "select": "eMC iyn tBJ dyH iFc SMy yTZ pBj BG7 XiG aZc YbY L4E", "normal": "HQE", "errored": "vhe", "enabled": "yur pBj qJc", "disabled": "fAT B9u gpV" };

  var SelectList = function (_React$Component) {
    inherits(SelectList, _React$Component);

    function SelectList() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, SelectList);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SelectList.__proto__ || Object.getPrototypeOf(SelectList)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        focused: false
      }, _this.setSelectListRef = function (ref) {
        _this.select = ref;
      }, _this.handleOnChange = function (event) {
        var _this$props = _this.props,
            onChange = _this$props.onChange,
            value = _this$props.value;

        if (event.target instanceof HTMLSelectElement && value !== event.target.value) {
          onChange({ event: event, value: event.target.value });
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(SelectList, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            disabled = _props.disabled,
            errorMessage = _props.errorMessage,
            id = _props.id,
            name = _props.name,
            options = _props.options,
            placeholder = _props.placeholder,
            value = _props.value;
        var focused = this.state.focused;


        var classes = classnames(styles$o.select, disabled ? styles$o.disabled : styles$o.enabled, errorMessage ? styles$o.errored : styles$o.normal);

        return React.createElement(
          Box,
          null,
          React.createElement(
            Box,
            {
              color: disabled ? 'lightGray' : 'white',
              dangerouslySetInlineStyle: { __style: { borderRadius: 4 } },
              display: 'flex',
              position: 'relative',
              width: '100%'
            },
            React.createElement(
              Box,
              {
                alignItems: 'center',
                bottom: true,
                dangerouslySetInlineStyle: {
                  __style: { paddingRight: 14, paddingTop: 2 }
                },
                display: 'flex',
                position: 'absolute',
                right: true,
                top: true
              },
              React.createElement(Icon, {
                icon: 'arrow-down',
                size: 12,
                color: disabled ? 'gray' : 'darkGray',
                accessibilityLabel: ''
              })
            ),
            React.createElement(
              'select',
              {
                'aria-describedby': errorMessage && focused ? id + '-error' : null,
                'aria-invalid': errorMessage ? 'true' : 'false',
                className: classes,
                disabled: disabled,
                id: id,
                name: name,
                onBlur: this.handleOnChange,
                onChange: this.handleOnChange,
                ref: this.setSelectListRef,
                value: value
              },
              placeholder && !value && React.createElement(
                'option',
                { selected: true, disabled: true, value: true, hidden: true },
                placeholder
              ),
              options.map(function (option) {
                return React.createElement(
                  'option',
                  { key: option.value, value: option.value },
                  option.label
                );
              })
            )
          ),
          errorMessage && React.createElement(
            Box,
            { marginTop: 1 },
            React.createElement(FormErrorMessage, { id: id, text: errorMessage })
          )
        );
      }
    }]);
    return SelectList;
  }(React.Component);

  SelectList.propTypes = {
    disabled: PropTypes.bool,
    errorMessage: PropTypes.string,
    id: PropTypes.string.isRequired,
    name: PropTypes.string,
    onChange: PropTypes.func.isRequired,
    options: PropTypes.arrayOf(PropTypes.exact({
      label: PropTypes.string.isRequired,
      value: PropTypes.string.isRequired
    })),
    placeholder: PropTypes.string,
    value: PropTypes.string
  };
  SelectList.defaultProps = {
    disabled: false,
    options: []
  };

  var styles$p = { "icon": "YHq kVc", "spin": "jfh" };

  var SIZE = 40;

  function Spinner(_ref) {
    var accessibilityLabel = _ref.accessibilityLabel,
        show = _ref.show;

    return show ? React.createElement(
      Box,
      { display: 'flex', justifyContent: 'around', overflow: 'hidden' },
      React.createElement(
        'div',
        { className: styles$p.icon },
        React.createElement(Icon, {
          icon: 'knoop',
          accessibilityLabel: accessibilityLabel,
          size: SIZE
        })
      )
    ) : React.createElement('div', null);
  }

  Spinner.propTypes = {
    show: PropTypes.bool.isRequired,
    accessibilityLabel: PropTypes.string.isRequired
  };

  function Sticky(props) {
    var _props$dangerouslySet = props.dangerouslySetZIndex,
        dangerouslySetZIndex = _props$dangerouslySet === undefined ? { __zIndex: 1 } : _props$dangerouslySet,
        children = props.children;

    var style = {
      top: props.top != null ? props.top : undefined,
      left: props.left != null ? props.left : undefined,
      right: props.right != null ? props.right : undefined,
      bottom: props.bottom != null ? props.bottom : undefined,
      // eslint-disable-next-line no-underscore-dangle
      zIndex: dangerouslySetZIndex.__zIndex
    };
    return React.createElement(
      'div',
      { className: layout.sticky, style: style },
      children
    );
  }

  Sticky.propTypes = {
    children: PropTypes.node,
    dangerouslySetZIndex: PropTypes.exact({
      __zIndex: PropTypes.number
    }),
    top: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    left: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    bottom: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    right: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
  };

  var styles$q = { "switch": "jPl kVc Hsu XiG", "focused": "My7 C1J", "switchDarkGray": "dD6 BsF", "switchGray": "GOX gfP", "switchLightGray": "v-K gpV", "switchWhite": "NYx qJc", "slider": "U7Q Hsu MIw qJc INd", "sliderRight": "taI", "sliderLeft": "RDh", "sliderDark": "GEq", "sliderLight": "fhX", "checkbox": "sAX MIw L4E e43 adn yQo", "checkboxEnabled": "C8A BG7" };

  var Switch = function (_React$Component) {
    inherits(Switch, _React$Component);

    function Switch() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Switch);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Switch.__proto__ || Object.getPrototypeOf(Switch)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        focused: false
      }, _this.handleBlur = function () {
        return _this.setState({ focused: false });
      }, _this.handleFocus = function () {
        return _this.setState({ focused: true });
      }, _this.handleChange = function (event) {
        var onChange = _this.props.onChange;
        var checked = event.target.checked;

        onChange({ event: event, value: checked });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Switch, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            disabled = _props.disabled,
            id = _props.id,
            name = _props.name,
            switched = _props.switched;


        var switchStyles = classnames(styles$q.switch, defineProperty({}, styles$q.focused, this.state.focused),
        // eslint-disable-next-line no-nested-ternary
        disabled ? switched ? styles$q.switchGray : styles$q.switchLightGray : switched ? styles$q.switchDarkGray : styles$q.switchWhite);

        var sliderStyles = classnames(styles$q.slider, switched ? styles$q.sliderRight : styles$q.sliderLeft, switched && !disabled ? styles$q.sliderDark : styles$q.sliderLight);

        var inputStyles = classnames(styles$q.checkbox, defineProperty({}, styles$q.checkboxEnabled, !disabled));

        return React.createElement(
          'div',
          { className: switchStyles },
          React.createElement('input', {
            checked: switched,
            className: inputStyles,
            disabled: disabled,
            id: id,
            name: name,
            onBlur: this.handleBlur,
            onChange: this.handleChange,
            onFocus: this.handleFocus,
            type: 'checkbox'
          }),
          React.createElement('div', { className: sliderStyles })
        );
      }
    }]);
    return Switch;
  }(React.Component);

  Switch.propTypes = {
    disabled: PropTypes.bool,
    id: PropTypes.string.isRequired,
    name: PropTypes.string,
    onChange: PropTypes.func.isRequired,
    switched: PropTypes.bool
  };
  Switch.defaultProps = {
    disabled: false,
    switched: false
  };

  var styles$r = { "Tabs": "FaT _O1", "tab": "Tbq iyn Hsu aZc _O1 qT6 undefined mQ8 adn Lfz e43 BG7", "tabIsNotActive": "f-T YbY B9u", "tabIsActive": "oOE gpV pBj" };

  var Tabs = function (_React$Component) {
    inherits(Tabs, _React$Component);

    function Tabs() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Tabs);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        focusedTabIndex: undefined,
        hoveredTabIndex: undefined
      }, _this.handleTabClick = function (i, e) {
        var onChange = _this.props.onChange;

        onChange({ activeTabIndex: i, event: e });
      }, _this.handleTabFocus = function (i) {
        return _this.setState({ focusedTabIndex: i });
      }, _this.handleTabBlur = function () {
        return _this.setState({ focusedTabIndex: undefined });
      }, _this.handleTabMouseEnter = function (i) {
        return _this.setState({ hoveredTabIndex: i });
      }, _this.handleTabMouseLeave = function () {
        return _this.setState({ hoveredTabIndex: undefined });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Tabs, [{
      key: 'render',
      value: function render() {
        var _this2 = this;

        var _props = this.props,
            tabs = _props.tabs,
            activeTabIndex = _props.activeTabIndex,
            wrap = _props.wrap;
        var _state = this.state,
            focusedTabIndex = _state.focusedTabIndex,
            hoveredTabIndex = _state.hoveredTabIndex;

        return React.createElement(
          'div',
          {
            className: classnames(styles$r.Tabs, wrap && layout.flexWrap),
            role: 'tablist'
          },
          tabs.map(function (_ref2, i) {
            var _classnames;

            var text = _ref2.text,
                href = _ref2.href;

            var isActive = i === activeTabIndex;
            var isHovered = i === hoveredTabIndex;
            var isFocused = i === focusedTabIndex;
            var cs = classnames(styles$r.tab, (_classnames = {}, defineProperty(_classnames, styles$r.tabIsNotActive, !isActive), defineProperty(_classnames, styles$r.tabIsActive, isActive), _classnames));
            return React.createElement(
              'a',
              {
                'aria-selected': isActive,
                className: cs,
                href: href,
                key: '' + i + href,
                onClick: function onClick(e) {
                  return _this2.handleTabClick(i, e);
                },
                onFocus: function onFocus() {
                  return _this2.handleTabFocus(i);
                },
                onBlur: _this2.handleTabBlur,
                onMouseEnter: function onMouseEnter() {
                  return _this2.handleTabMouseEnter(i);
                },
                onMouseLeave: _this2.handleTabMouseLeave,
                role: 'tab'
              },
              React.createElement(
                Text,
                {
                  bold: true,
                  color: isActive || isHovered || isFocused ? 'darkGray' : 'gray',
                  size: 'md'
                },
                text
              )
            );
          })
        );
      }
    }]);
    return Tabs;
  }(React.Component);

  Tabs.propTypes = {
    activeTabIndex: PropTypes.number.isRequired,
    tabs: PropTypes.arrayOf(PropTypes.exact({
      text: PropTypes.node,
      href: PropTypes.string
    })).isRequired,
    onChange: PropTypes.func.isRequired,
    wrap: PropTypes.bool
  };

  var styles$s = { "textArea": "Gnj iyn Hsu tBJ dyH iFc SMy yTZ fqb L4E", "normal": "MDo", "errored": "_1V", "enabled": "Hvf pBj qJc", "disabled": "iCG B9u gpV" };

  var TextArea = function (_React$Component) {
    inherits(TextArea, _React$Component);

    function TextArea() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, TextArea);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TextArea.__proto__ || Object.getPrototypeOf(TextArea)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        focused: false
      }, _this.setTextAreaRef = function (ref) {
        _this.textarea = ref;
      }, _this.handleChange = function (event) {
        var onChange = _this.props.onChange;

        onChange({ event: event, value: event.currentTarget.value });
      }, _this.handleBlur = function (event) {
        var onBlur = _this.props.onBlur;

        if (onBlur) {
          onBlur({ event: event, value: event.currentTarget.value });
        }
      }, _this.handleFocus = function (event) {
        var onFocus = _this.props.onFocus;

        if (onFocus) {
          onFocus({ event: event, value: event.currentTarget.value });
        }
      }, _this.handleKeyDown = function (event) {
        var onKeyDown = _this.props.onKeyDown;

        if (onKeyDown) {
          onKeyDown({ event: event, value: event.currentTarget.value });
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(TextArea, [{
      key: 'render',


      // NOTE: we cannot move to React createRef until we audit uses of callsites
      // that reach into this component and use this instance variable
      value: function render() {
        var _props = this.props,
            disabled = _props.disabled,
            errorMessage = _props.errorMessage,
            hasError = _props.hasError,
            id = _props.id,
            name = _props.name,
            placeholder = _props.placeholder,
            rows = _props.rows,
            value = _props.value;
        var focused = this.state.focused;


        var classes = classnames(styles$s.textArea, disabled ? styles$s.disabled : styles$s.enabled, hasError || errorMessage ? styles$s.errored : styles$s.normal);

        return React.createElement(
          'span',
          null,
          React.createElement('textarea', {
            'aria-describedby': errorMessage && focused ? id + '-error' : null,
            'aria-invalid': errorMessage || hasError ? 'true' : 'false',
            className: classes,
            disabled: disabled,
            id: id,
            name: name,
            onBlur: this.handleBlur,
            onChange: this.handleChange,
            onFocus: this.handleFocus,
            onKeyDown: this.handleKeyDown,
            placeholder: placeholder,
            ref: this.setTextAreaRef,
            rows: rows,
            value: value
          }),
          errorMessage && React.createElement(
            Box,
            { marginTop: 1 },
            React.createElement(FormErrorMessage, { id: id, text: errorMessage })
          )
        );
      }
    }]);
    return TextArea;
  }(React.Component);

  TextArea.propTypes = {
    disabled: PropTypes.bool,
    errorMessage: PropTypes.string,
    hasError: PropTypes.bool,
    id: PropTypes.string.isRequired,
    name: PropTypes.string,
    onBlur: PropTypes.func,
    onChange: PropTypes.func.isRequired,
    onFocus: PropTypes.func,
    onKeyDown: PropTypes.func,
    placeholder: PropTypes.string,
    rows: PropTypes.number,
    value: PropTypes.string
  };
  TextArea.defaultProps = {
    disabled: false,
    hasError: false,
    rows: 3
  };

  var styles$t = { "textField": "wyq iyn Hsu aZc tBJ dyH iFc SMy yTZ L4E", "normal": "fgH", "errored": "vyL", "enabled": "edc pBj qJc", "disabled": "QoC B9u gpV" };

  var TextField = function (_React$Component) {
    inherits(TextField, _React$Component);

    function TextField() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, TextField);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TextField.__proto__ || Object.getPrototypeOf(TextField)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        focused: false
      }, _this.setTextFieldRef = function (ref) {
        _this.textfield = ref;
      }, _this.handleChange = function (event) {
        var onChange = _this.props.onChange;

        onChange({ event: event, value: event.currentTarget.value });
      }, _this.handleBlur = function (event) {
        var onBlur = _this.props.onBlur;

        if (onBlur) {
          onBlur({ event: event, value: event.currentTarget.value });
        }
      }, _this.handleFocus = function (event) {
        var onFocus = _this.props.onFocus;

        if (onFocus) {
          onFocus({ event: event, value: event.currentTarget.value });
        }
      }, _this.handleKeyDown = function (event) {
        var onKeyDown = _this.props.onKeyDown;

        if (onKeyDown) {
          onKeyDown({ event: event, value: event.currentTarget.value });
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(TextField, [{
      key: 'render',


      // NOTE: we cannot move to React createRef until we audit uses of callsites
      // that reach into this component and use this instance variable
      value: function render() {
        var _props = this.props,
            autoComplete = _props.autoComplete,
            disabled = _props.disabled,
            errorMessage = _props.errorMessage,
            hasError = _props.hasError,
            id = _props.id,
            name = _props.name,
            placeholder = _props.placeholder,
            type = _props.type,
            value = _props.value;
        var focused = this.state.focused;


        var classes = classnames(styles$t.textField, disabled ? styles$t.disabled : styles$t.enabled, hasError || errorMessage ? styles$t.errored : styles$t.normal);

        // type='number' doesn't work on ios safari without a pattern
        // https://stackoverflow.com/questions/14447668/input-type-number-is-not-showing-a-number-keypad-on-ios
        var pattern = type === 'number' ? '\\d*' : undefined;

        return React.createElement(
          'span',
          null,
          React.createElement('input', {
            'aria-describedby': errorMessage && focused ? id + '-error' : null,
            'aria-invalid': errorMessage || hasError ? 'true' : 'false',
            autoComplete: autoComplete,
            className: classes,
            disabled: disabled,
            id: id,
            name: name,
            onBlur: this.handleBlur,
            onChange: this.handleChange,
            onFocus: this.handleFocus,
            onKeyDown: this.handleKeyDown,
            pattern: pattern,
            placeholder: placeholder,
            ref: this.setTextFieldRef,
            type: type,
            value: value
          }),
          errorMessage && React.createElement(
            Box,
            { marginTop: 1 },
            React.createElement(FormErrorMessage, { id: id, text: errorMessage })
          )
        );
      }
    }]);
    return TextField;
  }(React.Component);

  TextField.propTypes = {
    autoComplete: PropTypes.oneOf(['current-password', 'new-password', 'on', 'off', 'username']),
    disabled: PropTypes.bool,
    errorMessage: PropTypes.string,
    hasError: PropTypes.bool,
    id: PropTypes.string.isRequired,
    name: PropTypes.string,
    onBlur: PropTypes.func,
    onChange: PropTypes.func.isRequired,
    onFocus: PropTypes.func,
    onKeyDown: PropTypes.func,
    placeholder: PropTypes.string,
    type: PropTypes.oneOf(['date', 'email', 'number', 'password', 'text', 'url']),
    value: PropTypes.string
  };
  TextField.defaultProps = {
    disabled: false,
    hasError: false,
    type: 'text'
  };

  function Toast(props) {
    var _props$color = props.color,
        color = _props$color === undefined ? 'darkGray' : _props$color,
        icon = props.icon,
        thumbnail = props.thumbnail,
        text = props.text;


    var contents = void 0;
    // Confirmation Toasts
    if (text instanceof Array && text.length > 1) {
      contents = React.createElement(
        Box,
        { xs: { display: 'flex' } },
        React.createElement(
          Box,
          { xs: { display: 'flexColumn' }, flex: 'none', justifyContent: 'center' },
          thumbnail ? React.createElement(
            Mask,
            { shape: 'rounded', height: 48, width: 48 },
            thumbnail
          ) : null
        ),
        React.createElement(
          Box,
          {
            xs: { display: 'flexColumn' },
            justifyContent: 'center',
            dangerouslySetInlineStyle: { __style: { paddingLeft: 10 } }
          },
          React.createElement(
            Box,
            {
              dangerouslySetInlineStyle: { __style: { fontWeight: 'normal' } }
            },
            React.createElement(
              Text,
              { color: 'white', size: 'lg' },
              text[0]
            )
          ),
          React.createElement(
            Text,
            { bold: true, color: 'white', size: 'lg' },
            text[1]
          )
        )
      );
    } else {
      // Toasts as Guides
      contents = React.createElement(
        Box,
        {
          xs: { display: 'flex' },
          justifyContent: 'between',
          alignItems: 'center'
        },
        React.createElement(
          Text,
          { bold: true, color: 'white', size: 'lg' },
          text
        ),
        icon && React.createElement(
          Box,
          { dangerouslySetInlineStyle: { __style: { paddingLeft: 24 } } },
          React.createElement(Icon, { accessibilityLabel: '', color: 'white', icon: icon, size: 36 })
        )
      );
    }

    return React.createElement(
      Box,
      { marginBottom: 3, paddingX: 4, maxWidth: 376, width: '100vw' },
      React.createElement(
        Box,
        { color: color, fit: true, paddingX: 8, paddingY: 5, shape: 'pill' },
        contents
      )
    );
  }

  Toast.propTypes = {
    color: PropTypes.oneOf(['darkGray', 'orange']),
    icon: PropTypes.oneOf(['arrow-circle-forward']), // leaving open to additional icons in the future
    text: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]).isRequired,
    thumbnail: PropTypes.node
  };

  var noop = function noop() {};

  var Tooltip = function (_React$Component) {
    inherits(Tooltip, _React$Component);

    function Tooltip() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Tooltip);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        hovered: false
      }, _this.childRef = React.createRef(), _this.handleMouseEnter = function () {
        return _this.setState({ hovered: true });
      }, _this.handleMouseLeave = function () {
        return _this.setState({ hovered: false });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Tooltip, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            children = _props.children,
            inline = _props.inline,
            text = _props.text;
        var hovered = this.state.hovered;
        var anchor = this.childRef.current;


        return React.createElement(
          Box,
          { display: inline ? 'inlineBlock' : 'block' },
          React.createElement(
            Box,
            {
              onMouseEnter: this.handleMouseEnter,
              onMouseLeave: this.handleMouseLeave,
              ref: this.childRef
            },
            children
          ),
          hovered && !!anchor && React.createElement(
            Controller,
            {
              anchor: anchor,
              bgColor: 'darkGray',
              caret: false,
              idealDirection: 'down',
              onDismiss: noop,
              positionRelativeToAnchor: true,
              size: null
            },
            React.createElement(
              Box,
              { maxWidth: 180, paddingY: 1, paddingX: 2, role: 'tooltip' },
              React.createElement(
                Text,
                { color: 'white', size: 'xs' },
                text
              )
            )
          )
        );
      }
    }]);
    return Tooltip;
  }(React.Component);

  var styles$u = { "touchable": "rLK iyn", "fullHeight": "XJa", "fullWidth": "FTD L4E", "square": "Xs7 gL3", "circle": "Fbr INd", "rounded": "GnO mix", "roundedTop": "akr mO6", "roundedRight": "kDD t6-", "roundedBottom": "iBw BqC", "roundedLeft": "IAh ere", "pill": "PHy Lfz", "pointer": "DI9 BG7", "zoomIn": "MNX LIa", "zoomOut": "KPW Smz", "copy": "u-8 q-D", "move": "_qV c8z", "noDrop": "_j4 rEw", "grab": "vYN K8T", "grabbing": "uy2 RMk" };

  var SPACE_CHAR_CODE = 32;
  var ENTER_CHAR_CODE = 13;

  var Touchable = function (_React$Component) {
    inherits(Touchable, _React$Component);

    function Touchable() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Touchable);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Touchable.__proto__ || Object.getPrototypeOf(Touchable)).call.apply(_ref, [this].concat(args))), _this), _this.handleKeyPress = function (event) {
        var onTouch = _this.props.onTouch;
        // Check to see if space or enter were pressed

        if (onTouch && (event.charCode === SPACE_CHAR_CODE || event.charCode === ENTER_CHAR_CODE)) {
          // Prevent the default action to stop scrolling when space is pressed
          event.preventDefault();
          onTouch({ event: event });
        }
      }, _this.handleMouseEnter = function (event) {
        var onMouseEnter = _this.props.onMouseEnter;

        if (onMouseEnter) {
          onMouseEnter({ event: event });
        }
      }, _this.handleMouseLeave = function (event) {
        var onMouseLeave = _this.props.onMouseLeave;

        if (onMouseLeave) {
          onMouseLeave({ event: event });
        }
      }, _this.handleClick = function (event) {
        var onTouch = _this.props.onTouch;

        if (onTouch) {
          onTouch({ event: event });
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Touchable, [{
      key: 'render',
      value: function render() {
        var _classnames;

        var _props = this.props,
            children = _props.children,
            _props$fullWidth = _props.fullWidth,
            fullWidth = _props$fullWidth === undefined ? true : _props$fullWidth,
            fullHeight = _props.fullHeight,
            _props$mouseCursor = _props.mouseCursor,
            mouseCursor = _props$mouseCursor === undefined ? 'pointer' : _props$mouseCursor,
            _props$shape = _props.shape,
            shape = _props$shape === undefined ? 'square' : _props$shape;


        var classes = classnames(styles$u.touchable, styles$u[mouseCursor], styles$u[shape], (_classnames = {}, defineProperty(_classnames, styles$u.fullHeight, fullHeight), defineProperty(_classnames, styles$u.fullWidth, fullWidth), _classnames));

        return React.createElement(
          'div',
          {
            className: classes,
            onClick: this.handleClick,
            onMouseEnter: this.handleMouseEnter,
            onMouseLeave: this.handleMouseLeave,
            onKeyPress: this.handleKeyPress,
            role: 'button',
            tabIndex: '0'
          },
          children
        );
      }
    }]);
    return Touchable;
  }(React.Component);


  Touchable.propTypes = {
    children: PropTypes.node,
    fullHeight: PropTypes.bool,
    fullWidth: PropTypes.bool,
    mouseCursor: PropTypes.oneOf(['copy', 'grab', 'grabbing', 'move', 'noDrop', 'pointer', 'zoomIn', 'zoomOut']),
    onTouch: PropTypes.func,
    onMouseEnter: PropTypes.func,
    onMouseLeave: PropTypes.func,
    shape: PropTypes.oneOf(['square', 'rounded', 'pill', 'circle', 'roundedTop', 'roundedBottom', 'roundedLeft', 'roundedRight'])
  };

  var styles$v = { "video": "hwa kVc MIw L4E", "player": "iCM XiG L4E", "playhead": "QCH _O1 gjz L4E BG7", "controls": "hoF MIw _O1 gjz ojN Rym p6V wYR hA-" };

  var VideoPlayhead = function (_React$PureComponent) {
    inherits(VideoPlayhead, _React$PureComponent);

    function VideoPlayhead() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, VideoPlayhead);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VideoPlayhead.__proto__ || Object.getPrototypeOf(VideoPlayhead)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        seeking: false
      }, _this.setPlayheadRef = function (ref) {
        _this.playhead = ref;
      }, _this.seek = function (clientX) {
        if (_this.playhead) {
          var _this$props = _this.props,
              _duration = _this$props.duration,
              _seek = _this$props.seek;

          var _this$playhead$getBou = _this.playhead.getBoundingClientRect(),
              left = _this$playhead$getBou.left,
              width = _this$playhead$getBou.width;

          var percent = Math.max(0, Math.min((clientX - left) / width, 1));
          var newTime = percent * _duration;
          _seek(newTime);
        }
      }, _this.stopClick = function (event) {
        return event.stopPropagation();
      }, _this.handleMouseDown = function (event) {
        _this.setState({ seeking: true });
        _this.seek(event.clientX);
      }, _this.handleMouseMove = function (event) {
        var seeking = _this.state.seeking;

        if (seeking) {
          _this.seek(event.clientX);
        }
      }, _this.handleMouseUp = function () {
        _this.setState({ seeking: false });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(VideoPlayhead, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            currentTime = _props.currentTime,
            duration = _props.duration;

        var width = Math.floor(currentTime * 10000 / duration) / 100 + '%';
        return React.createElement(
          Box,
          {
            position: 'relative',
            display: 'flex',
            flex: 'grow',
            alignItems: 'center',
            height: 16
          },
          React.createElement(
            'div',
            {
              'aria-valuemax': duration,
              'aria-valuemin': '0',
              'aria-valuenow': currentTime,
              className: styles$v.playhead,
              onClick: this.stopClick,
              onKeyPress: this.stopClick,
              onMouseDown: this.handleMouseDown,
              onMouseMove: this.handleMouseMove,
              onMouseUp: this.handleMouseUp,
              ref: this.setPlayheadRef,
              role: 'progressbar',
              tabIndex: '-1'
            },
            React.createElement(
              Box,
              {
                left: true,
                right: true,
                position: 'absolute',
                color: 'lightGray',
                shape: 'rounded',
                height: 4
              },
              React.createElement(Box, { color: 'white', shape: 'rounded', height: '100%', width: width })
            ),
            React.createElement(
              Box,
              {
                position: 'absolute',
                shape: 'rounded',
                height: 4,
                dangerouslySetInlineStyle: { __style: { left: width } }
              },
              React.createElement(Box, {
                shape: 'circle',
                width: 16,
                height: 16,
                color: 'white',
                marginLeft: -2,
                dangerouslySetInlineStyle: { __style: { marginTop: -6 } }
              })
            )
          )
        );
      }
    }]);
    return VideoPlayhead;
  }(React.PureComponent);

  VideoPlayhead.propTypes = {
    currentTime: PropTypes.number.isRequired,
    duration: PropTypes.number.isRequired,
    seek: PropTypes.func.isRequired
  };

  var fullscreenEnabled = function fullscreenEnabled() {
    return (
      // $FlowIssue - vendor prefix missing from Flow
      document.fullscreenEnabled ||
      // $FlowIssue - vendor prefix missing from Flow
      document.webkitFullscreenEnabled ||
      // $FlowIssue - vendor prefix missing from Flow
      document.mozFullScreenEnabled ||
      // $FlowIssue - vendor prefix missing from Flow
      document.msFullscreenEnabled
    );
  };

  var timeToString = function timeToString(time) {
    var rounded = Math.floor(time || 0);
    var minutes = Math.floor(rounded / 60);
    var seconds = rounded - minutes * 60;
    var minutesStr = minutes < 10 ? '0' + minutes : minutes;
    var secondsStr = seconds < 10 ? '0' + seconds : seconds;
    return minutesStr + ':' + secondsStr;
  };

  var VideoControls = function (_React$Component) {
    inherits(VideoControls, _React$Component);

    function VideoControls() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, VideoControls);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VideoControls.__proto__ || Object.getPrototypeOf(VideoControls)).call.apply(_ref, [this].concat(args))), _this), _this.handleFullscreenChange = function (_ref2) {
        var event = _ref2.event;
        var onFullscreenChange = _this.props.onFullscreenChange;

        event.stopPropagation();
        onFullscreenChange();
      }, _this.handlePlayingChange = function (_ref3) {
        var event = _ref3.event;
        var _this$props = _this.props,
            playing = _this$props.playing,
            onPause = _this$props.onPause,
            onPlay = _this$props.onPlay;

        if (playing) {
          onPause(event);
        } else {
          onPlay(event);
        }
      }, _this.handleVolumeChange = function (_ref4) {
        var event = _ref4.event;
        var onVolumeChange = _this.props.onVolumeChange;

        onVolumeChange(event);
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(VideoControls, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            accessibilityMaximizeLabel = _props.accessibilityMaximizeLabel,
            accessibilityMinimizeLabel = _props.accessibilityMinimizeLabel,
            accessibilityMuteLabel = _props.accessibilityMuteLabel,
            accessibilityPauseLabel = _props.accessibilityPauseLabel,
            accessibilityPlayLabel = _props.accessibilityPlayLabel,
            accessibilityUnmuteLabel = _props.accessibilityUnmuteLabel,
            currentTime = _props.currentTime,
            duration = _props.duration,
            fullscreen = _props.fullscreen,
            playing = _props.playing,
            seek = _props.seek,
            volume = _props.volume;

        var muted = volume === 0;
        var showFullscreenButton = typeof document !== 'undefined' && !!fullscreenEnabled();
        return React.createElement(
          'div',
          { className: styles$v.controls },
          React.createElement(
            Box,
            { padding: 2 },
            React.createElement(
              Touchable,
              { onTouch: this.handlePlayingChange, fullWidth: false },
              React.createElement(Icon, {
                accessibilityLabel: playing ? accessibilityPauseLabel : accessibilityPlayLabel,
                color: 'white',
                icon: playing ? 'pause' : 'play',
                size: 20
              })
            )
          ),
          React.createElement(
            Box,
            { width: 50, padding: 2 },
            React.createElement(
              Text,
              { color: 'white', align: 'right', size: 'xs' },
              timeToString(currentTime)
            )
          ),
          React.createElement(
            Box,
            { padding: 2, flex: 'grow' },
            React.createElement(VideoPlayhead, {
              currentTime: currentTime,
              duration: duration,
              seek: seek
            })
          ),
          React.createElement(
            Box,
            { width: 50, padding: 2 },
            React.createElement(
              Text,
              { color: 'white', align: 'right', size: 'xs' },
              timeToString(duration)
            )
          ),
          React.createElement(
            Box,
            { padding: 2 },
            React.createElement(
              Touchable,
              { onTouch: this.handleVolumeChange, fullWidth: false },
              React.createElement(Icon, {
                accessibilityLabel: muted ? accessibilityUnmuteLabel : accessibilityMuteLabel,
                color: 'white',
                icon: muted ? 'mute' : 'sound',
                size: 20
              })
            )
          ),
          showFullscreenButton && React.createElement(
            Box,
            { padding: 2 },
            React.createElement(
              Touchable,
              { onTouch: this.handleFullscreenChange, fullWidth: false },
              React.createElement(Icon, {
                accessibilityLabel: fullscreen ? accessibilityMinimizeLabel : accessibilityMaximizeLabel,
                color: 'white',
                icon: fullscreen ? 'minimize' : 'maximize',
                size: 20
              })
            )
          )
        );
      }
    }]);
    return VideoControls;
  }(React.Component);

  VideoControls.propTypes = {
    accessibilityMaximizeLabel: PropTypes.string.isRequired,
    accessibilityMinimizeLabel: PropTypes.string.isRequired,
    accessibilityMuteLabel: PropTypes.string.isRequired,
    accessibilityPauseLabel: PropTypes.string.isRequired,
    accessibilityPlayLabel: PropTypes.string.isRequired,
    accessibilityUnmuteLabel: PropTypes.string.isRequired,
    currentTime: PropTypes.number.isRequired,
    duration: PropTypes.number.isRequired,
    fullscreen: PropTypes.bool.isRequired,
    onFullscreenChange: PropTypes.func.isRequired,
    onPause: PropTypes.func.isRequired,
    onPlay: PropTypes.func.isRequired,
    onVolumeChange: PropTypes.func.isRequired,
    playing: PropTypes.bool.isRequired,
    seek: PropTypes.func.isRequired,
    volume: PropTypes.number.isRequired
  };

  // For more information on fullscreen and vendor prefixes see
  // https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API

  var requestFullscreen = function requestFullscreen(element) {
    if (element.requestFullscreen) {
      element.requestFullscreen();
      // $FlowIssue - vendor prefix missing from Flow
    } else if (element.webkitRequestFullscreen) {
      // $FlowIssue - vendor prefix missing from Flow
      element.webkitRequestFullscreen();
      // $FlowIssue - vendor prefix missing from Flow
    } else if (element.mozRequestFullScreen) {
      // $FlowIssue - vendor prefix missing from Flow
      element.mozRequestFullScreen();
      // $FlowIssue - vendor prefix missing from Flow
    } else if (element.msRequestFullscreen) {
      // $FlowIssue - vendor prefix missing from Flow
      element.msRequestFullscreen();
    }
  };

  var exitFullscreen = function exitFullscreen() {
    // $FlowIssue - vendor prefix missing from Flow
    if (document.exitFullscreen) {
      // $FlowIssue - vendor prefix missing from Flow
      document.exitFullscreen();
      // $FlowIssue - vendor prefix missing from Flow
    } else if (document.webkitExitFullscreen) {
      // $FlowIssue - vendor prefix missing from Flow
      document.webkitExitFullscreen();
      // $FlowIssue - vendor prefix missing from Flow
    } else if (document.mozCancelFullScreen) {
      // $FlowIssue - vendor prefix missing from Flow
      document.mozCancelFullScreen();
      // $FlowIssue - vendor prefix missing from Flow
    } else if (document.msExitFullscreen) {
      // $FlowIssue - vendor prefix missing from Flow
      document.msExitFullscreen();
    }
  };

  // Normally document.fullscreen suffices here as a flag, but IE11 does not
  // have a vendor specific version so we must instead use the actual element
  var isFullscreen = function isFullscreen() {
    return (
      // $FlowIssue - vendor prefix missing from Flow
      document.fullscreenElement ||
      // $FlowIssue - vendor prefix missing from Flow
      document.webkitFullscreenElement ||
      // $FlowIssue - vendor prefix missing from Flow
      document.mozFullScreenElement ||
      // $FlowIssue - vendor prefix missing from Flow
      document.msFullscreenElement
    );
  };

  var addFullscreenEventListener = function addFullscreenEventListener(listener) {
    document.addEventListener('fullscreenchange', listener);
    document.addEventListener('webkitfullscreenchange', listener);
    document.addEventListener('mozfullscreenchange', listener);
    document.addEventListener('MSFullscreenChange', listener);
  };

  var removeFullscreenEventListener = function removeFullscreenEventListener(listener) {
    document.removeEventListener('fullscreenchange', listener);
    document.removeEventListener('webkitfullscreenchange', listener);
    document.removeEventListener('mozfullscreenchange', listener);
    document.removeEventListener('MSFullscreenChange', listener);
  };

  var isNewSource = function isNewSource(oldSource, newSource) {
    if ((typeof oldSource === 'undefined' ? 'undefined' : _typeof(oldSource)) !== (typeof newSource === 'undefined' ? 'undefined' : _typeof(newSource))) {
      // If the source type changed from string to Array
      // or vice versa, we have a new source
      return true;
    }
    if (Array.isArray(newSource)) {
      if (oldSource.length !== newSource.length) {
        // If the sources are both an Array, and the lengths
        // do not match we evaluate as a new source
        return true;
      }
      // If the sources are both an Array and the same length,
      // verify every element stayed the same
      return newSource.some(function (source, index) {
        return !Array.isArray(oldSource) || source.type !== oldSource[index].type || source.src !== oldSource[index].src;
      });
    }
    // If the sources are both a string, simply compare
    // the new with the old
    return newSource !== oldSource;
  };

  var Video = function (_React$PureComponent) {
    inherits(Video, _React$PureComponent);

    function Video() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Video);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Video.__proto__ || Object.getPrototypeOf(Video)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        currentTime: 0,
        duration: 0,
        fullscreen: false
      }, _this.setPlayerRef = function (ref) {
        _this.player = ref;
      }, _this.setVideoRef = function (ref) {
        _this.video = ref;
      }, _this.setPlaybackRate = function (playbackRate) {
        if (_this.video) {
          _this.video.playbackRate = playbackRate;
        }
      }, _this.setVolume = function (volume) {
        if (_this.video) {
          _this.video.volume = volume;
        }
      }, _this.load = function () {
        if (_this.video) {
          _this.video.load();
        }
      }, _this.pause = function () {
        if (_this.video) {
          _this.video.pause();
        }
      }, _this.play = function () {
        if (_this.video) {
          _this.video.play();
        }
      }, _this.seek = function (time) {
        if (_this.video) {
          _this.video.currentTime = time;
        }
      }, _this.toggleFullscreen = function () {
        if (isFullscreen()) {
          exitFullscreen();
        } else if (_this.player) {
          requestFullscreen(_this.player);
        }
      }, _this.handleCanPlay = function (event) {
        var onReady = _this.props.onReady;


        if (onReady) {
          onReady({ event: event });
        }
      }, _this.handleDurationChange = function (event) {
        var onDurationChange = _this.props.onDurationChange;

        var duration = _this.video && _this.video.duration || 0;
        _this.setState({ duration: duration });

        if (onDurationChange) {
          onDurationChange({ event: event, duration: duration });
        }
      }, _this.handleEnded = function (event) {
        var onEnded = _this.props.onEnded;


        if (onEnded) {
          onEnded({ event: event });
        }
      }, _this.handleFullscreenChange = function (event) {
        var onFullscreenChange = _this.props.onFullscreenChange;

        var fullscreen = !!isFullscreen();
        _this.setState({ fullscreen: fullscreen });

        if (onFullscreenChange) {
          onFullscreenChange({ event: event, fullscreen: fullscreen });
        }
      }, _this.handlePlay = function (event) {
        var onPlay = _this.props.onPlay;


        if (onPlay) {
          onPlay({ event: event });
        }
      }, _this.handlePause = function (event) {
        var onPause = _this.props.onPause;


        if (onPause) {
          onPause({ event: event });
        }
      }, _this.handleProgress = function (event) {
        var onLoadedChange = _this.props.onLoadedChange;

        var _ref2 = _this.video || {},
            buffered = _ref2.buffered;

        var loaded = buffered && buffered.length > 0 ? buffered.end(buffered.length - 1) : 0;

        if (onLoadedChange) {
          onLoadedChange({ event: event, loaded: loaded });
        }
      }, _this.handleSeek = function (event) {
        var onSeek = _this.props.onSeek;


        if (onSeek) {
          onSeek({ event: event });
        }
      }, _this.handleTimeUpdate = function (event) {
        var onTimeChange = _this.props.onTimeChange;

        var currentTime = _this.video && _this.video.currentTime || 0;
        _this.setState({ currentTime: currentTime });

        if (onTimeChange) {
          onTimeChange({ event: event, time: currentTime });
        }
      }, _this.handleVolumeChange = function (event) {
        var onVolumeChange = _this.props.onVolumeChange;

        var muted = _this.video && _this.video.muted || false;

        if (onVolumeChange) {
          onVolumeChange({ event: event, volume: muted ? 1 : 0 });
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Video, [{
      key: 'componentDidMount',


      /**
       * React lifecycle hooks pertinent to Video
       */

      value: function componentDidMount() {
        var _props = this.props,
            playbackRate = _props.playbackRate,
            playing = _props.playing,
            volume = _props.volume;
        // Set up event listeners to catch backdoors in fullscreen
        // changes such as using the ESC key to exit

        if (typeof document !== 'undefined') {
          addFullscreenEventListener(this.handleFullscreenChange);
        }
        // Load the video to hydrate the DOM after a server render
        this.load();
        // Set the initial volume
        this.setVolume(volume);
        // Set the initial playback rate
        this.setPlaybackRate(playbackRate);
        // Simulate an autoplay effect if the component
        if (playing) {
          this.play();
        }
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps) {
        // If the video source changed, reload the video
        if (isNewSource(prevProps.src, this.props.src)) {
          this.load();
        }
        // If the volume changed, set the new volume
        if (prevProps.volume !== this.props.volume) {
          this.setVolume(this.props.volume);
        }
        // If the playback rate changed, set the new rate
        if (prevProps.playbackRate !== this.props.playbackRate) {
          this.setPlaybackRate(this.props.playbackRate);
        }
        // If the playback changed, play or pause the video
        if (prevProps.playing !== this.props.playing) {
          if (this.props.playing) {
            this.play();
          } else {
            this.pause();
          }
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        removeFullscreenEventListener(this.handleFullscreenChange);
      }

      /**
       * DOM reference housekeeping that is needed for functionality
       */

      // The player element encapsulates the actual video DOM
      // element as well as the controls to bring both fullscreen


      // The actual reference to the video HTML DOM element


      /**
       * Functions that directly interact with the HTML video element
       */

      // Set the video to the desired playback rate: 1 (normal)


      // Set the video to the desired volume: 0 (muted) -> 1 (max)


      // Change the video source and re-load the video


      // Pause the video


      // Play the video


      // Seek the video to the desired time


      // Enter/exit fullscreen video player mode


      /**
       * Handlers for various media events on the video
       */

      // Sent when enough data is available that the media can be played


      // The metadata has loaded or changed, indicating a change in
      // duration of the media


      // Sent when playback completes.


      // Sent when the video is switched to/out-of fullscreen mode


      // Sent when playback of the media starts after having been paused.


      // Sent when playback is paused.


      // Sent periodically to inform interested parties of progress downloading the media


      // Sent when a seek operation completes.


      // The time indicated by the element's currentTime attribute has changed


      // Sent when the audio volume changes

    }, {
      key: 'render',
      value: function render() {
        var _props2 = this.props,
            aspectRatio = _props2.aspectRatio,
            captions = _props2.captions,
            children = _props2.children,
            loop = _props2.loop,
            playing = _props2.playing,
            playsInline = _props2.playsInline,
            poster = _props2.poster,
            preload = _props2.preload,
            src = _props2.src,
            volume = _props2.volume;
        var _state = this.state,
            currentTime = _state.currentTime,
            duration = _state.duration,
            fullscreen = _state.fullscreen;


        var paddingBottom = fullscreen && '0' || 1 / aspectRatio * 100 + '%';

        return React.createElement(
          'div',
          {
            ref: this.setPlayerRef,
            className: styles$v.player,
            style: { paddingBottom: paddingBottom, height: fullscreen ? '100%' : 0 }
          },
          React.createElement(
            'video',
            {
              autoPlay: playing,
              loop: loop,
              muted: volume === 0,
              playsInline: playsInline,
              poster: poster,
              preload: preload,
              src: typeof src === 'string' ? src : undefined,
              ref: this.setVideoRef,
              className: styles$v.video,
              onCanPlay: this.handleCanPlay,
              onDurationChange: this.handleDurationChange,
              onEnded: this.handleEnded,
              onSeeked: this.handleSeek,
              onTimeUpdate: this.handleTimeUpdate,
              onProgress: this.handleProgress
            },
            Array.isArray(src) && src.map(function (source) {
              return React.createElement('source', { key: source.src, src: source.src, type: source.type });
            }),
            React.createElement('track', { kind: 'captions', src: captions })
          ),
          children && React.createElement(
            Box,
            { position: 'absolute', top: true, left: true, bottom: true, right: true, overflow: 'hidden' },
            children
          ),
          this.props.controls && React.createElement(VideoControls, {
            accessibilityMaximizeLabel: this.props.accessibilityMaximizeLabel,
            accessibilityMinimizeLabel: this.props.accessibilityMinimizeLabel,
            accessibilityMuteLabel: this.props.accessibilityMuteLabel,
            accessibilityPauseLabel: this.props.accessibilityPauseLabel,
            accessibilityPlayLabel: this.props.accessibilityPlayLabel,
            accessibilityUnmuteLabel: this.props.accessibilityUnmuteLabel,
            currentTime: currentTime,
            duration: duration,
            fullscreen: fullscreen,
            onPlay: this.handlePlay,
            onPause: this.handlePause,
            onFullscreenChange: this.toggleFullscreen,
            onVolumeChange: this.handleVolumeChange,
            playing: playing,
            seek: this.seek,
            volume: volume
          })
        );
      }
    }]);
    return Video;
  }(React.PureComponent);

  Video.propTypes = {
    accessibilityMaximizeLabel: PropTypes.string,
    accessibilityMinimizeLabel: PropTypes.string,
    accessibilityMuteLabel: PropTypes.string,
    accessibilityPauseLabel: PropTypes.string,
    accessibilityPlayLabel: PropTypes.string,
    accessibilityUnmuteLabel: PropTypes.string,
    aspectRatio: PropTypes.number.isRequired,
    captions: PropTypes.string.isRequired,
    children: PropTypes.node,
    controls: PropTypes.bool,
    loop: PropTypes.bool,
    onDurationChange: PropTypes.func,
    onEnded: PropTypes.func,
    onFullscreenChange: PropTypes.func,
    onLoadedChange: PropTypes.func,
    onPlay: PropTypes.func,
    onPause: PropTypes.func,
    onReady: PropTypes.func,
    onSeek: PropTypes.func,
    onTimeChange: PropTypes.func,
    onVolumeChange: PropTypes.func,
    playbackRate: PropTypes.number,
    playing: PropTypes.bool,
    playsInline: PropTypes.bool,
    poster: PropTypes.string,
    preload: PropTypes.oneOf(['auto', 'metadata', 'none']),
    src: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.shape({
      type: PropTypes.oneOf(['video/m3u8', 'video/mp4', 'video/ogg']).isRequired,
      src: PropTypes.string.isRequired
    }))]).isRequired,
    volume: PropTypes.number
  };
  Video.defaultProps = {
    playbackRate: 1,
    playing: false,
    preload: 'auto',
    volume: 1
  };

  exports.Avatar = Avatar;
  exports.Badge = Badge;
  exports.Box = Box;
  exports.Button = Button;
  exports.Card = Card;
  exports.Checkbox = Checkbox;
  exports.Collage = Collage;
  exports.Collection = Collection;
  exports.Column = Column;
  exports.Container = Container;
  exports.Divider = Divider;
  exports.Flyout = Flyout;
  exports.GroupAvatar = GroupAvatar;
  exports.Heading = Heading;
  exports.Icon = Icon;
  exports.IconButton = IconButton;
  exports.Image = Image;
  exports.Label = Label;
  exports.Layer = Layer;
  exports.Letterbox = Letterbox;
  exports.Link = Link;
  exports.Mask = Mask;
  exports.Masonry = Masonry;
  exports.MasonryBeta = MasonryBeta;
  exports.MasonryInfiniteBeta = MasonryInfiniteBeta;
  exports.MasonryDefaultLayout = MasonryLayout;
  exports.MasonryUniformRowLayout = UniformRowLayout;
  exports.Modal = Modal;
  exports.Pog = Pog;
  exports.Pulsar = Pulsar;
  exports.RadioButton = RadioButton;
  exports.ScrollFetch = ScrollFetch;
  exports.SearchField = SearchField;
  exports.SegmentedControl = SegmentedControl;
  exports.SelectList = SelectList;
  exports.Spinner = Spinner;
  exports.Sticky = Sticky;
  exports.Switch = Switch;
  exports.Tabs = Tabs;
  exports.Text = Text;
  exports.TextArea = TextArea;
  exports.TextField = TextField;
  exports.Toast = Toast;
  exports.Tooltip = Tooltip;
  exports.Touchable = Touchable;
  exports.Video = Video;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VzdGFsdC5qcyIsInNvdXJjZXMiOlsiLi4vc3JjL3N0eWxlLmpzIiwiLi4vc3JjL3RyYW5zZm9ybXMuanMiLCIuLi9zcmMvQm94LmpzIiwiLi4vc3JjL2ljb25zL2luZGV4LmpzIiwiLi4vc3JjL0ljb24uanMiLCIuLi9zcmMvSW1hZ2UuanMiLCIuLi9zcmMvTWFzay5qcyIsIi4uL3NyYy9BdmF0YXIuanMiLCIuLi9zcmMvQmFkZ2UuanMiLCIuLi9zcmMvVGV4dC5qcyIsIi4uL3NyYy9CdXR0b24uanMiLCIuLi9zcmMvQ2FyZC5qcyIsIi4uL3NyYy9DaGVja2JveC5qcyIsIi4uL3NyYy9Db2xsZWN0aW9uLmpzIiwiLi4vc3JjL0NvbGxhZ2UuanMiLCIuLi9zcmMvQ29sdW1uLmpzIiwiLi4vc3JjL0NvbnRhaW5lci5qcyIsIi4uL3NyYy9EaXZpZGVyLmpzIiwiLi4vc3JjL0NhcmV0LmpzIiwiLi4vc3JjL0NvbnRlbnRzLmpzIiwiLi4vc3JjL2JlaGF2aW9ycy9PdXRzaWRlRXZlbnRCZWhhdmlvci5qcyIsIi4uL3NyYy9Db250cm9sbGVyLmpzIiwiLi4vc3JjL0ZseW91dC5qcyIsIi4uL3NyYy9Hcm91cEF2YXRhci5qcyIsIi4uL3NyYy9IZWFkaW5nLmpzIiwiLi4vc3JjL1BvZy5qcyIsIi4uL3NyYy9JY29uQnV0dG9uLmpzIiwiLi4vc3JjL0xhYmVsLmpzIiwiLi4vc3JjL0xheWVyLmpzIiwiLi4vc3JjL0xldHRlcmJveC5qcyIsIi4uL3NyYy9MaW5rLmpzIiwiLi4vc3JjL2RlYm91bmNlLmpzIiwiLi4vc3JjL0ZldGNoSXRlbXMuanMiLCIuLi9zcmMvU2Nyb2xsQ29udGFpbmVyLmpzIiwiLi4vc3JjL3Rocm90dGxlLmpzIiwiLi4vc3JjL01lYXN1cmVtZW50U3RvcmUuanMiLCIuLi9zcmMvc2Nyb2xsVXRpbHMuanMiLCIuLi9zcmMvbGVnYWN5TGF5b3V0U3ltYm9scy5qcyIsIi4uL3NyYy9kZWZhdWx0TGF5b3V0LmpzIiwiLi4vc3JjL3VuaWZvcm1Sb3dMYXlvdXQuanMiLCIuLi9zcmMvZnVsbFdpZHRoTGF5b3V0LmpzIiwiLi4vc3JjL2xheW91dHMvTWFzb25yeUxheW91dC5qcyIsIi4uL3NyYy9sYXlvdXRzL1VuaWZvcm1Sb3dMYXlvdXQuanMiLCIuLi9zcmMvTWFzb25yeS5qcyIsIi4uL3NyYy9NYXNvbnJ5QmV0YS5qcyIsIi4uL3NyYy9NYXNvbnJ5SW5maW5pdGVCZXRhLmpzIiwiLi4vc3JjL2JlaGF2aW9ycy9TdG9wU2Nyb2xsQmVoYXZpb3IuanMiLCIuLi9zcmMvYmVoYXZpb3JzL1RyYXBGb2N1c0JlaGF2aW9yLmpzIiwiLi4vc3JjL01vZGFsLmpzIiwiLi4vc3JjL1B1bHNhci5qcyIsIi4uL3NyYy9SYWRpb0J1dHRvbi5qcyIsIi4uL3NyYy9TY3JvbGxGZXRjaC5qcyIsIi4uL3NyYy9TZWFyY2hGaWVsZC5qcyIsIi4uL3NyYy9TZWdtZW50ZWRDb250cm9sLmpzIiwiLi4vc3JjL0Zvcm1FcnJvck1lc3NhZ2UuanMiLCIuLi9zcmMvU2VsZWN0TGlzdC5qcyIsIi4uL3NyYy9TcGlubmVyLmpzIiwiLi4vc3JjL1N0aWNreS5qcyIsIi4uL3NyYy9Td2l0Y2guanMiLCIuLi9zcmMvVGFicy5qcyIsIi4uL3NyYy9UZXh0QXJlYS5qcyIsIi4uL3NyYy9UZXh0RmllbGQuanMiLCIuLi9zcmMvVG9hc3QuanMiLCIuLi9zcmMvVG9vbHRpcC5qcyIsIi4uL3NyYy9Ub3VjaGFibGUuanMiLCIuLi9zcmMvVmlkZW9QbGF5aGVhZC5qcyIsIi4uL3NyYy9WaWRlb0NvbnRyb2xzLmpzIiwiLi4vc3JjL1ZpZGVvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIEBmbG93ICovXG5cbi8qXG5cblN0eWxlIGlzIGEgbW9ub2lkIHRoYXQgY2FwdHVyZSB0aGUgXCJ0by1iZS1hcHBsaWVkXCIgc3R5bGVzIChpbmxpbmUgYW5kIGNsYXNzZXMpXG5mb3IgYSBCb3guIEl0J3MgYmFzaWNhbGx5IHNldCB0aGF0IGlzIGNsb3NlZCB1bmRlciBhbiBhc3NvY2lhdGl2ZSBiaW5hcnlcbm9wZXJhdGlvbiBhbmQgaGFzIGFuIGlkZW50aXR5IGVsZW1lbnQgc3VjaCB0aGF0IGZvciBhbGwgSEEgSEEgSEEuIFllcywgaXQncyBhXG5tb25vaWQsIHdoaWNoIHNvdW5kcyBzY2FyeSBidXQgaXQncyBub3QgcmVhbGx5IGFuZCBhY3R1YWxseSBzdXBlciB1c2VmdWwuIEFsbFxudGhhdCBtZWFucyBpcyB0aGF0IGJhc2ljYWxseSB5b3UgY2FuIGRvIHR3byB0aGluZ3Mgd2l0aCBpdDpcblxuICAgIDEuIGNvbmNhdChjb25jYXQoYSwgYiksIGMpID09PSBjb25jYXQoYSwgY29uY2F0KGIsIGMpKTtcbiAgICAyLiBjb25jYXQoaWRlbnRpdHkoKSwgYSkgPT09IGNvbmNhdChhLCBpZGVudGl0eSgpKSA9PT0gYTtcblxuV2hhdCB0aGF0IG1lYW5zIGlzIHRoYXQgaXQncyByZWFsbHkgZWFzeSB0byBjb21wb3NlIHN0eWxlcyB0b2dldGhlciBhbmQgdGhlXG5vcmRlciBpbiB3aGljaCB5b3UgZG8gc28gZG9lc24ndCByZWFsbHkgbWF0dGVyLlxuXG4qL1xuXG50eXBlIElubGluZVN0eWxlID0geyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCB2b2lkIH07XG5cbi8vIFRPRE86IFRoaXMgdHlwZSBzaG91bGQgYmUgb3BhcXVlLCBob3dldmVyIHRoZSBCYWJlbCBwYXJzZXIgZG9lc24ndCBzdXBwb3J0XG4vLyAgICAgICB0aGUgb3BhcXVlIHN5bnRheCB5ZXQuXG5leHBvcnQgdHlwZSBTdHlsZSA9IHt8XG4gIGNsYXNzTmFtZTogU2V0PHN0cmluZz4sXG4gIGlubGluZVN0eWxlOiBJbmxpbmVTdHlsZSxcbnx9O1xuXG5leHBvcnQgY29uc3QgaWRlbnRpdHkgPSAoKTogU3R5bGUgPT4gKHtcbiAgY2xhc3NOYW1lOiBuZXcgU2V0KCksXG4gIGlubGluZVN0eWxlOiB7fSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZnJvbUNsYXNzTmFtZSA9ICguLi5jbGFzc05hbWVzOiBBcnJheTxzdHJpbmc+KTogU3R5bGUgPT4gKHtcbiAgY2xhc3NOYW1lOiBuZXcgU2V0KGNsYXNzTmFtZXMpLFxuICBpbmxpbmVTdHlsZToge30sXG59KTtcblxuZXhwb3J0IGNvbnN0IGZyb21JbmxpbmVTdHlsZSA9IChpbmxpbmVTdHlsZTogSW5saW5lU3R5bGUpOiBTdHlsZSA9PiAoe1xuICBjbGFzc05hbWU6IG5ldyBTZXQoKSxcbiAgaW5saW5lU3R5bGUsXG59KTtcblxuZXhwb3J0IGNvbnN0IGNvbmNhdCA9IChzdHlsZXM6IEFycmF5PFN0eWxlPik6IFN0eWxlID0+XG4gIHN0eWxlcy5yZWR1Y2UoXG4gICAgKFxuICAgICAgeyBjbGFzc05hbWU6IGNsYXNzTmFtZUEsIGlubGluZVN0eWxlOiBpbmxpbmVTdHlsZUEgfSxcbiAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVCLCBpbmxpbmVTdHlsZTogaW5saW5lU3R5bGVCIH1cbiAgICApID0+ICh7XG4gICAgICBjbGFzc05hbWU6IG5ldyBTZXQoWy4uLmNsYXNzTmFtZUEsIC4uLmNsYXNzTmFtZUJdKSxcbiAgICAgIGlubGluZVN0eWxlOiB7IC4uLmlubGluZVN0eWxlQSwgLi4uaW5saW5lU3R5bGVCIH0sXG4gICAgfSksXG4gICAgaWRlbnRpdHkoKVxuICApO1xuXG5leHBvcnQgY29uc3QgbWFwQ2xhc3NOYW1lID0gKGZuOiAoeDogc3RyaW5nKSA9PiBzdHJpbmcpID0+ICh7XG4gIGNsYXNzTmFtZSxcbiAgaW5saW5lU3R5bGUsXG59OiBTdHlsZSk6IFN0eWxlID0+ICh7XG4gIGNsYXNzTmFtZTogbmV3IFNldChBcnJheS5mcm9tKGNsYXNzTmFtZSkubWFwKGZuKSksXG4gIGlubGluZVN0eWxlLFxufSk7XG5cbmV4cG9ydCBjb25zdCB0b1Byb3BzID0gKHtcbiAgY2xhc3NOYW1lLFxuICBpbmxpbmVTdHlsZSxcbn06IFN0eWxlKTogeyBjbGFzc05hbWU6IHN0cmluZywgc3R5bGU6IElubGluZVN0eWxlIH0gPT4ge1xuICBjb25zdCBwcm9wcyA9IHt9O1xuXG4gIGlmIChjbGFzc05hbWUuc2l6ZSA+IDApIHtcbiAgICAvLyBTb3J0aW5nIGhlcmUgZW5zdXJlcyB0aGF0IGNsYXNzTmFtZXMgYXJlIGFsd2F5cyBzdGFibGUsIHJlZHVjaW5nIGRpZmZcbiAgICAvLyBjaHVybi4gQm94IHVzdWFsbHkgaGFzIGEgc21hbGwgbnVtYmVyIG9mIHByb3BlcnRpZXMgc28gaXQncyBub3QgYSBwZXJmXG4gICAgLy8gY29uY2Vybi5cbiAgICBwcm9wcy5jbGFzc05hbWUgPSBBcnJheS5mcm9tKGNsYXNzTmFtZSlcbiAgICAgIC5zb3J0KClcbiAgICAgIC5qb2luKCcgJyk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoaW5saW5lU3R5bGUpLmxlbmd0aCA+IDApIHtcbiAgICBwcm9wcy5zdHlsZSA9IGlubGluZVN0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHByb3BzO1xufTtcbiIsIi8vIEBmbG93XG5cbmltcG9ydCB7XG4gIGNvbmNhdCxcbiAgZnJvbUNsYXNzTmFtZSxcbiAgaWRlbnRpdHksXG4gIG1hcENsYXNzTmFtZSxcbiAgdHlwZSBTdHlsZSxcbn0gZnJvbSAnLi9zdHlsZS5qcyc7XG5cbi8qXG5cblRyYW5zZm9ybXNcblxuVGhlc2UgYXJlIGEgY29sbGVjdGlvbiBvZiBhIGZldyBmdW5jdG9ycyB0aGF0IHRha2UgdmFsdWVzIGFuZCByZXR1cm5zIFN0eWxlJ3MuIE9NRywgSSB1c2VkIHRoZSB3b3JkIGZ1bmN0b3IgLSBpdCdzIHJlYWxseSBqdXN0IGEgZmFuY3kgd29yZCBmb3IgZnVuY3Rpb24uXG5cbiovXG5cbnR5cGUgRnVuY3RvciA9IChuOiBudW1iZXIpID0+IFN0eWxlO1xuXG4vLyBBZGRzIGEgY2xhc3NuYW1lIHdoZW4gYSBwcm9wZXJ0eSBpcyBwcmVzZW50LlxuLy9cbi8vICAgICA8Qm94IHRvcCAvPlxuLy9cbmV4cG9ydCBjb25zdCB0b2dnbGUgPSAoLi4uY2xhc3NOYW1lczogQXJyYXk8c3RyaW5nPikgPT4gKHZhbD86IGJvb2xlYW4pID0+XG4gIHZhbCA/IGZyb21DbGFzc05hbWUoLi4uY2xhc3NOYW1lcykgOiBpZGVudGl0eSgpO1xuXG4vLyBNYXBzIHN0cmluZyB2YWx1ZXMgdG8gY2xhc3Nlc1xuLy9cbi8vICAgICA8Qm94IGFsaWduSXRlbXM9XCJjZW50ZXJcIiAvPlxuLy9cbmV4cG9ydCBjb25zdCBtYXBwaW5nID0gKG1hcDogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkgPT4gKHZhbDogc3RyaW5nKSA9PlxuICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCB2YWwpXG4gICAgPyBmcm9tQ2xhc3NOYW1lKG1hcFt2YWxdKVxuICAgIDogaWRlbnRpdHkoKTtcblxuLy8gTWFwcyBhIHJhbmdlIG9mIGludGVnZXJzIHRvIGEgcmFuZ2Ugb2YgY2xhc3NuYW1lc1xuLy9cbi8vICAgICA8Qm94IHBhZGRpbmc9ezF9IC8+XG4vL1xuZXhwb3J0IGNvbnN0IHJhbmdlID0gKHNjYWxlOiBzdHJpbmcpID0+IChuOiBudW1iZXIpID0+XG4gIGZyb21DbGFzc05hbWUoYCR7c2NhbGV9JHtuIDwgMCA/IGBOJHtNYXRoLmFicyhuKX1gIDogbn1gKTtcblxuLy8gTGlrZSBgcmFuZ2VgLCBtYXBzIGEgcmFuZ2Ugb2YgaW50ZWdlcnMgdG8gYSByYW5nZSBvZiBjbGFzc25hbWVzLCBleGNsdWRpbmdcbi8vIHplcm8gdmFsdWVzLlxuLy9cbi8vICAgICA8Qm94IHBhZGRpbmc9ezB9IC8+XG5leHBvcnQgY29uc3QgcmFuZ2VXaXRob3V0WmVybyA9IChzY2FsZTogc3RyaW5nKSA9PiAobjogbnVtYmVyKSA9PlxuICBuID09PSAwID8gaWRlbnRpdHkoKSA6IHJhbmdlKHNjYWxlKShuKTtcblxuLy8gQmluZHMgYSBzdHJpbmcgY2xhc3NuYW1lIHRvIHRoZSB2YWx1ZSBpbiBhbiBvYmplY3QuIFVzZWZ1bCB3aGVuIGludGVyYWN0aW5nXG4vLyB3aXRoIHJhbmdlcyB0aGF0IG5lZWQgdG8gY29tZSBkeW5hbWljYWxseSBmcm9tIGEgc3R5bGUgb2JqZWN0LiBUaGlzIGlzXG4vLyBzaW1pbGFyIHRvIHRoZSBOUE0gcGFja2FnZSAnY2xhc3NuYW1lcy9iaW5kJy5cbmV4cG9ydCBjb25zdCBiaW5kID0gKGZuOiBGdW5jdG9yLCBzY29wZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkgPT4gKFxuICB2YWw6IG51bWJlclxuKSA9PiBtYXBDbGFzc05hbWUobmFtZSA9PiBzY29wZVtuYW1lXSkoZm4odmFsKSk7XG5cbi8vIFRoaXMgdGFrZXMgYSBzZXJpZXMgb2YgdGhlIHByZXZpb3VzbHkgZGVmaW5lZCBmdW5jdG9ycywgcnVucyB0aGVtIGFsbFxuLy8gYWdhaW5zdCBhIHZhbHVlIGFuZCByZXR1cm5zIHRoZSBzZXQgb2YgdGhlaXIgY2xhc3NuYW1lcy5cbmV4cG9ydCBjb25zdCB1bmlvbiA9ICguLi5mbnM6IEFycmF5PEZ1bmN0b3I+KSA9PiAodmFsOiBudW1iZXIpID0+XG4gIGNvbmNhdChmbnMubWFwKGZuID0+IGZuKHZhbCkpKTtcbiIsIi8vIEBmbG93XG5cbi8qXG5cbiMgV2VsY29tZSB0byBCb3ghXG5cblRoaXMgZ3VpZGUgd2lsbCBoZWxwIHlvdSBuYXZpZ2F0ZSBhbmQgdW5kZXJzdGFuZCBpdHMgZGVzaWduLiBUaGlzIGZpbGUgaXMgcm91Z2hseSBvcmdhbml6ZWQgbGlrZTpcblxuICAxLiBGbG93IFR5cGVzXG4gIDIuIFByb3AgdHJhbnNmb3JtZXJzXG4gIDMuIEJveCBpdHNlbGZcbiAgNC4gUHJvcFR5cGVzXG5cbkknbGwgZXhwbGFpbiBlYWNoIHBhcnQgYXMgd2UgZ28gdGhyb3VnaC4gSnVzdCByZW1lbWJlciwgaWYgeW91IHdhbnQgdG8gbWFrZSB1cGRhdGVzLCBQTEVBU0UgUExFQVNFIFBMRUFTRSB1cGRhdGUgdGhlIEZsb3cgVHlwZXMgJiBQcm9wVHlwZXMgKGV2ZW4gdGhvdWdoIHRoZXkgbG9vayBzY2FyeSkuXG5cbiovXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vQm94LmNzcyc7XG5pbXBvcnQgYm9yZGVycyBmcm9tICcuL0JvcmRlcnMuY3NzJztcbmltcG9ydCBjb2xvcnMgZnJvbSAnLi9Db2xvcnMuY3NzJztcbmltcG9ydCBsYXlvdXQgZnJvbSAnLi9MYXlvdXQuY3NzJztcbmltcG9ydCB3aGl0ZXNwYWNlIGZyb20gJy4vYm94V2hpdGVzcGFjZS5jc3MnO1xuaW1wb3J0IHdoaXRlc3BhY2VMZWdhY3kgZnJvbSAnLi9XaGl0ZXNwYWNlLmNzcyc7XG5pbXBvcnQge1xuICBjb25jYXQsXG4gIGZyb21DbGFzc05hbWUsXG4gIGZyb21JbmxpbmVTdHlsZSxcbiAgaWRlbnRpdHksXG4gIG1hcENsYXNzTmFtZSxcbiAgdG9Qcm9wcyxcbn0gZnJvbSAnLi9zdHlsZS5qcyc7XG5pbXBvcnQge1xuICB1bmlvbixcbiAgYmluZCxcbiAgcmFuZ2UsXG4gIHRvZ2dsZSxcbiAgbWFwcGluZyxcbiAgcmFuZ2VXaXRob3V0WmVybyxcbn0gZnJvbSAnLi90cmFuc2Zvcm1zLmpzJztcblxuLypcblxuIyBQcm9UeXBlc1xuXG5Cb3gncyB0eXBlIGRlZmluaXRpb24gaXMgZXhoYXVzdGl2ZS4gV2l0aCB0aGUgZXhjZXB0aW9uIG9mIGBkYW5nZXJvdXNseVNldElubGluZVN0eWxlYCwgdmFsdWVzIHNob3VsZG4ndCBiZSBhbWJpZ2lvdXMuIFRoYXQgbWVhbnMgdGhhdCB3ZSBoYXZlIHRvIHR5cGUgb3V0IHRoaW5ncyBsaWtlIGJvaW50cywgYnV0IHRoYXQncyBhbHNvIHdoZXJlIEJveCdzIG1hZ2ljIGxpZXMuIEFsc28sIGJ5IHB1dHRpbmcgaW4gZXh0cmEgZWZmb3J0IGFyb3VuZCB0eXBlIGRlZmluaXRpb25zIGhlcmUsIHdlIGNhbiBza2lwIGV4dHJhIHJ1bnRpbWUgdHlwZWNoZWNrcyBpbiB0aGUgdHJhbnNmb3JtZXJzIGZvciBwZXJmb3JtYW5jZS5cblxuKi9cblxudHlwZSBOYXRCb2ludCA9IDEgfCAyIHwgMyB8IDQgfCA1IHwgNjtcbnR5cGUgSW50Qm9pbnQgPSAtNiB8IC01IHwgLTQgfCAtMyB8IC0yIHwgLTEgfCBOYXRCb2ludDtcbnR5cGUgRGlzcGxheSA9ICdub25lJyB8ICdmbGV4JyB8ICdibG9jaycgfCAnaW5saW5lQmxvY2snIHwgJ3Zpc3VhbGx5SGlkZGVuJztcbnR5cGUgRGlyZWN0aW9uID0gJ3JvdycgfCAnY29sdW1uJztcbnR5cGUgQ29sdW1uID0gMCB8IDEgfCAyIHwgMyB8IDQgfCA1IHwgNiB8IDcgfCA4IHwgOSB8IDEwIHwgMTEgfCAxMjtcbnR5cGUgUmVzcG9uc2l2ZVByb3BzID0ge1xuICBjb2x1bW4/OiAxIHwgMiB8IDMgfCA0IHwgNSB8IDYgfCA3IHwgOCB8IDkgfCAxMCB8IDExIHwgMTIsXG4gIGRpc3BsYXk/OiBib29sZWFuIHwgJ2ZsZXgnIHwgJ2ZsZXhDb2x1bW4nIHwgJ2lubGluZUJsb2NrJyxcbn07XG50eXBlIE1hcmdpbiA9XG4gIHwgLTEyXG4gIHwgLTExXG4gIHwgLTEwXG4gIHwgLTlcbiAgfCAtOFxuICB8IC03XG4gIHwgLTZcbiAgfCAtNVxuICB8IC00XG4gIHwgLTNcbiAgfCAtMlxuICB8IC0xXG4gIHwgMFxuICB8IDFcbiAgfCAyXG4gIHwgM1xuICB8IDRcbiAgfCA1XG4gIHwgNlxuICB8IDdcbiAgfCA4XG4gIHwgOVxuICB8IDEwXG4gIHwgMTFcbiAgfCAxMjtcbnR5cGUgUGFkZGluZyA9IDAgfCAxIHwgMiB8IDMgfCA0IHwgNSB8IDYgfCA3IHwgOCB8IDkgfCAxMCB8IDExIHwgMTI7XG50eXBlIFByb3BUeXBlID0ge1xuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU/OiB7XG4gICAgX19zdHlsZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCB2b2lkIH0sXG4gIH0sXG5cbiAgeHM/OiBSZXNwb25zaXZlUHJvcHMsXG4gIHNtPzogUmVzcG9uc2l2ZVByb3BzLFxuICBtZD86IFJlc3BvbnNpdmVQcm9wcyxcbiAgbGc/OiBSZXNwb25zaXZlUHJvcHMsXG4gIGRlcHJlY2F0ZWRQYWRkaW5nPzogTmF0Qm9pbnQgfCB7IHg/OiBOYXRCb2ludCwgeT86IE5hdEJvaW50IH0sXG4gIGRlcHJlY2F0ZWRNYXJnaW4/OlxuICAgIHwgSW50Qm9pbnRcbiAgICB8IHtcbiAgICAgICAgdG9wPzogSW50Qm9pbnQsXG4gICAgICAgIHJpZ2h0PzogSW50Qm9pbnQgfCAnYXV0bycsXG4gICAgICAgIGJvdHRvbT86IEludEJvaW50LFxuICAgICAgICBsZWZ0PzogSW50Qm9pbnQgfCAnYXV0bycsXG4gICAgICB9LFxuXG4gIGRpc3BsYXk/OiBEaXNwbGF5LFxuICBjb2x1bW4/OiBDb2x1bW4sXG4gIGRpcmVjdGlvbj86IERpcmVjdGlvbixcbiAgc21EaXNwbGF5PzogRGlzcGxheSxcbiAgc21Db2x1bW4/OiBDb2x1bW4sXG4gIHNtRGlyZWN0aW9uPzogRGlyZWN0aW9uLFxuICBtZERpc3BsYXk/OiBEaXNwbGF5LFxuICBtZENvbHVtbj86IENvbHVtbixcbiAgbWREaXJlY3Rpb24/OiBEaXJlY3Rpb24sXG4gIGxnRGlzcGxheT86IERpc3BsYXksXG4gIGxnQ29sdW1uPzogQ29sdW1uLFxuICBsZ0RpcmVjdGlvbj86IERpcmVjdGlvbixcblxuICBhbGlnbkNvbnRlbnQ/OiAnc3RhcnQnIHwgJ2VuZCcgfCAnY2VudGVyJyB8ICdiZXR3ZWVuJyB8ICdhcm91bmQnIHwgJ3N0cmV0Y2gnLFxuICBhbGlnbkl0ZW1zPzogJ3N0YXJ0JyB8ICdlbmQnIHwgJ2NlbnRlcicgfCAnYmFzZWxpbmUnIHwgJ3N0cmV0Y2gnLFxuICBhbGlnblNlbGY/OiAnYXV0bycgfCAnc3RhcnQnIHwgJ2VuZCcgfCAnY2VudGVyJyB8ICdiYXNlbGluZScgfCAnc3RyZXRjaCcsXG4gIGJvdHRvbT86IGJvb2xlYW4sXG4gIGNvbG9yPzpcbiAgICB8ICdibHVlJ1xuICAgIHwgJ2RhcmtHcmF5J1xuICAgIHwgJ2RhcmtXYXNoJ1xuICAgIHwgJ2VnZ3BsYW50J1xuICAgIHwgJ2dyYXknXG4gICAgfCAnZ3JlZW4nXG4gICAgfCAnbGlnaHRHcmF5J1xuICAgIHwgJ2xpZ2h0V2FzaCdcbiAgICB8ICdtYXJvb24nXG4gICAgfCAnbWlkbmlnaHQnXG4gICAgfCAnbmF2eSdcbiAgICB8ICdvbGl2ZSdcbiAgICB8ICdvcmFuZ2UnXG4gICAgfCAnb3JjaGlkJ1xuICAgIHwgJ3BpbmUnXG4gICAgfCAncHVycGxlJ1xuICAgIHwgJ3JlZCdcbiAgICB8ICd0cmFuc3BhcmVudCdcbiAgICB8ICd0cmFuc3BhcmVudERhcmtHcmF5J1xuICAgIHwgJ3dhdGVybWVsb24nXG4gICAgfCAnd2hpdGUnLFxuICBmaXQ/OiBib29sZWFuLFxuICBmbGV4PzogJ2dyb3cnIHwgJ3NocmluaycgfCAnbm9uZScsXG4gIGhlaWdodD86IG51bWJlciB8IHN0cmluZyxcbiAganVzdGlmeUNvbnRlbnQ/OiAnc3RhcnQnIHwgJ2VuZCcgfCAnY2VudGVyJyB8ICdiZXR3ZWVuJyB8ICdhcm91bmQnLFxuICBsZWZ0PzogYm9vbGVhbixcblxuICBtYXJnaW5TdGFydD86IE1hcmdpbixcbiAgbWFyZ2luRW5kPzogTWFyZ2luLFxuXG4gIG1hcmdpbj86IE1hcmdpbixcbiAgbWFyZ2luVG9wPzogTWFyZ2luLFxuICBtYXJnaW5SaWdodD86IE1hcmdpbixcbiAgbWFyZ2luQm90dG9tPzogTWFyZ2luLFxuICBtYXJnaW5MZWZ0PzogTWFyZ2luLFxuXG4gIHNtTWFyZ2luPzogTWFyZ2luLFxuICBzbU1hcmdpblRvcD86IE1hcmdpbixcbiAgc21NYXJnaW5SaWdodD86IE1hcmdpbixcbiAgc21NYXJnaW5Cb3R0b20/OiBNYXJnaW4sXG4gIHNtTWFyZ2luTGVmdD86IE1hcmdpbixcblxuICBtZE1hcmdpbj86IE1hcmdpbixcbiAgbWRNYXJnaW5Ub3A/OiBNYXJnaW4sXG4gIG1kTWFyZ2luUmlnaHQ/OiBNYXJnaW4sXG4gIG1kTWFyZ2luQm90dG9tPzogTWFyZ2luLFxuICBtZE1hcmdpbkxlZnQ/OiBNYXJnaW4sXG5cbiAgbGdNYXJnaW4/OiBNYXJnaW4sXG4gIGxnTWFyZ2luVG9wPzogTWFyZ2luLFxuICBsZ01hcmdpblJpZ2h0PzogTWFyZ2luLFxuICBsZ01hcmdpbkJvdHRvbT86IE1hcmdpbixcbiAgbGdNYXJnaW5MZWZ0PzogTWFyZ2luLFxuXG4gIG1heEhlaWdodD86IG51bWJlciB8IHN0cmluZyxcbiAgbWF4V2lkdGg/OiBudW1iZXIgfCBzdHJpbmcsXG4gIG1pbkhlaWdodD86IG51bWJlciB8IHN0cmluZyxcbiAgbWluV2lkdGg/OiBudW1iZXIgfCBzdHJpbmcsXG5cbiAgb3ZlcmZsb3c/OiAndmlzaWJsZScgfCAnaGlkZGVuJyB8ICdzY3JvbGwnIHwgJ3Njcm9sbFgnIHwgJ3Njcm9sbFknIHwgJ2F1dG8nLFxuXG4gIHBhZGRpbmc/OiBQYWRkaW5nLFxuICBzbVBhZGRpbmc/OiBQYWRkaW5nLFxuICBtZFBhZGRpbmc/OiBQYWRkaW5nLFxuICBsZ1BhZGRpbmc/OiBQYWRkaW5nLFxuXG4gIHBhZGRpbmdYPzogUGFkZGluZyxcbiAgc21QYWRkaW5nWD86IFBhZGRpbmcsXG4gIG1kUGFkZGluZ1g/OiBQYWRkaW5nLFxuICBsZ1BhZGRpbmdYPzogUGFkZGluZyxcblxuICBwYWRkaW5nWT86IFBhZGRpbmcsXG4gIHNtUGFkZGluZ1k/OiBQYWRkaW5nLFxuICBtZFBhZGRpbmdZPzogUGFkZGluZyxcbiAgbGdQYWRkaW5nWT86IFBhZGRpbmcsXG5cbiAgcG9zaXRpb24/OiAnc3RhdGljJyB8ICdhYnNvbHV0ZScgfCAncmVsYXRpdmUnIHwgJ2ZpeGVkJyxcbiAgcmlnaHQ/OiBib29sZWFuLFxuICBzaGFwZT86XG4gICAgfCAnc3F1YXJlJ1xuICAgIHwgJ3JvdW5kZWQnXG4gICAgfCAncGlsbCdcbiAgICB8ICdjaXJjbGUnXG4gICAgfCAncm91bmRlZFRvcCdcbiAgICB8ICdyb3VuZGVkQm90dG9tJ1xuICAgIHwgJ3JvdW5kZWRMZWZ0J1xuICAgIHwgJ3JvdW5kZWRSaWdodCcsXG4gIHNocmluaz86IGJvb2xlYW4sXG4gIHRvcD86IGJvb2xlYW4sXG4gIHdpZHRoPzogbnVtYmVyIHwgc3RyaW5nLFxuICB3cmFwPzogYm9vbGVhbixcbn07XG5cbi8vIC0tXG5cbi8qXG5cbiMgVHJhbnNmb3JtZXJzXG5cblRoaXMgaXMgd2hlcmUgdGhlIG1lYXQgYW5kIHRoZSBib25lcyBvZiBCb3gncyB0cmFuc2Zvcm1zIGFyZS4gWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgdGhlIERTTCBpbiBgLi90cmFuc2Zvcm1zLmpzYCwgYnV0IGJhc2ljYWxseSB0aGV5IGFyZSBhIHNtYWxsIGRlY2xhcmF0aXZlIHdheSBvZiBzcGVjaWZ5aW5nIGhvdyBhIHByb3BlcnR5IChpLmUuIGBtYXJnaW5Ub3A9ezR9YCkgZ2V0cyB0dXJuZWQgaW50byBhIENTUyBjbGFzcyAoYG1hcmdpblRvcDRgKS5cblxuVGhlcmUncyBhIGxpdHRsZSBwcmVhbWJsZSBoZXJlLCBidXQgaXQgY3VsbWluYXRlcyBpbiBhIGJpZyBvYmplY3QgbWFwcGluZyB0aGUgYWN0dWFsIHByb3BlcnR5IG5hbWVzIHRvIHRoZSB0cmFuc2Zvcm1lciB2YWx1ZXMuXG5cbiovXG5cbmNvbnN0IG1hcmdpblN0YXJ0ID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdtYXJnaW5TdGFydCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1hcmdpbkVuZCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWFyZ2luRW5kJyksIHdoaXRlc3BhY2UpO1xuY29uc3QgbWFyZ2luVG9wID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdtYXJnaW5Ub3AnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBtYXJnaW5SaWdodCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWFyZ2luUmlnaHQnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBtYXJnaW5Cb3R0b20gPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ21hcmdpbkJvdHRvbScpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1hcmdpbkxlZnQgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ21hcmdpbkxlZnQnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBtYXJnaW4gPSB1bmlvbihtYXJnaW5Ub3AsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdCwgbWFyZ2luUmlnaHQpO1xuXG5jb25zdCBzbU1hcmdpblRvcCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnc21NYXJnaW5Ub3AnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBzbU1hcmdpblJpZ2h0ID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdzbU1hcmdpblJpZ2h0JyksIHdoaXRlc3BhY2UpO1xuY29uc3Qgc21NYXJnaW5Cb3R0b20gPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ3NtTWFyZ2luQm90dG9tJyksIHdoaXRlc3BhY2UpO1xuY29uc3Qgc21NYXJnaW5MZWZ0ID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdzbU1hcmdpbkxlZnQnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBzbU1hcmdpbiA9IHVuaW9uKFxuICBzbU1hcmdpblRvcCxcbiAgc21NYXJnaW5Cb3R0b20sXG4gIHNtTWFyZ2luTGVmdCxcbiAgc21NYXJnaW5SaWdodFxuKTtcblxuY29uc3QgbWRNYXJnaW5Ub3AgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ21kTWFyZ2luVG9wJyksIHdoaXRlc3BhY2UpO1xuY29uc3QgbWRNYXJnaW5SaWdodCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWRNYXJnaW5SaWdodCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1kTWFyZ2luQm90dG9tID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdtZE1hcmdpbkJvdHRvbScpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1kTWFyZ2luTGVmdCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWRNYXJnaW5MZWZ0JyksIHdoaXRlc3BhY2UpO1xuY29uc3QgbWRNYXJnaW4gPSB1bmlvbihcbiAgbWRNYXJnaW5Ub3AsXG4gIG1kTWFyZ2luQm90dG9tLFxuICBtZE1hcmdpbkxlZnQsXG4gIG1kTWFyZ2luUmlnaHRcbik7XG5cbmNvbnN0IGxnTWFyZ2luVG9wID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdsZ01hcmdpblRvcCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IGxnTWFyZ2luUmlnaHQgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ2xnTWFyZ2luUmlnaHQnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBsZ01hcmdpbkJvdHRvbSA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbGdNYXJnaW5Cb3R0b20nKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBsZ01hcmdpbkxlZnQgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ2xnTWFyZ2luTGVmdCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IGxnTWFyZ2luID0gdW5pb24oXG4gIGxnTWFyZ2luVG9wLFxuICBsZ01hcmdpbkJvdHRvbSxcbiAgbGdNYXJnaW5MZWZ0LFxuICBsZ01hcmdpblJpZ2h0XG4pO1xuXG5jb25zdCBwYWRkaW5nWCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygncGFkZGluZ1gnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBwYWRkaW5nWSA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygncGFkZGluZ1knKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBwYWRkaW5nID0gdW5pb24ocGFkZGluZ1gsIHBhZGRpbmdZKTtcblxuY29uc3Qgc21QYWRkaW5nWCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnc21QYWRkaW5nWCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IHNtUGFkZGluZ1kgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ3NtUGFkZGluZ1knKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBzbVBhZGRpbmcgPSB1bmlvbihzbVBhZGRpbmdYLCBzbVBhZGRpbmdZKTtcblxuY29uc3QgbWRQYWRkaW5nWCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWRQYWRkaW5nWCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1kUGFkZGluZ1kgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ21kUGFkZGluZ1knKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBtZFBhZGRpbmcgPSB1bmlvbihtZFBhZGRpbmdYLCBtZFBhZGRpbmdZKTtcblxuY29uc3QgbGdQYWRkaW5nWCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbGdQYWRkaW5nWCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IGxnUGFkZGluZ1kgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ2xnUGFkZGluZ1knKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBsZ1BhZGRpbmcgPSB1bmlvbihsZ1BhZGRpbmdYLCBsZ1BhZGRpbmdZKTtcblxuLypcblxuVGhlc2UgZnVuY3Rpb25zIGFyZSBsZWdhY3kuIEknZCBsaWtlIHRvIGdldCByaWQgb2YgbW9zdCBvZiB0aGlzIGZpbGUncyBkZXBlbmRlbmN5IG9uIGltcG9ydGluZyBgLi9zdHlsZS5qc2AgZGlyZWN0bHkgb25jZSB0aGVzZSBhcmUgcmVtb3ZlZC5cblxuKi9cblxuY29uc3QgcHJlZml4ID0gKHByZTogc3RyaW5nKSA9PiBtYXBDbGFzc05hbWUobmFtZSA9PiBgJHtwcmV9JHtuYW1lfWApO1xuY29uc3QgZGlzcGxheSA9IHZhbHVlID0+IHtcbiAgc3dpdGNoICh2YWx1ZSkge1xuICAgIGNhc2UgJ2ZsZXgnOlxuICAgICAgcmV0dXJuIGZyb21DbGFzc05hbWUoJ0Rpc3BsYXlGbGV4JywgJ0RpcmVjdGlvblJvdycpO1xuICAgIGNhc2UgJ2ZsZXhDb2x1bW4nOlxuICAgICAgcmV0dXJuIGZyb21DbGFzc05hbWUoJ0Rpc3BsYXlGbGV4JywgJ0RpcmVjdGlvbkNvbHVtbicpO1xuICAgIGNhc2UgJ2lubGluZUJsb2NrJzpcbiAgICAgIHJldHVybiBmcm9tQ2xhc3NOYW1lKCdEaXNwbGF5SW5saW5lQmxvY2snKTtcbiAgICBjYXNlICd2aXN1YWxseUhpZGRlbic6XG4gICAgICByZXR1cm4gZnJvbUNsYXNzTmFtZSgnRGlzcGxheVZpc3VhbGx5SGlkZGVuJyk7XG4gICAgY2FzZSBmYWxzZTpcbiAgICAgIHJldHVybiBmcm9tQ2xhc3NOYW1lKCdEaXNwbGF5Tm9uZScpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvKiBibG9jayAqL1xuICAgICAgcmV0dXJuIGZyb21DbGFzc05hbWUoJ0Rpc3BsYXlCbG9jaycpO1xuICB9XG59O1xuY29uc3QgY29sdW1uID0gcmFuZ2UoJ0NvbCcpO1xuXG5jb25zdCBmb3JtYXRJbnRCb2ludCA9IHggPT4gKHggPCAwID8gYG4ke01hdGguYWJzKHgpfWAgOiB4LnRvU3RyaW5nKCkpO1xuXG4vKlxuXG5JdCdzIHByZWZlcmFibGUgdG8gcHV0IG5ldyBwcm9wZXJ0aWVzIGludG8gdGhhdCBvYmplY3QgZGlyZWN0bHkganVzdCBzbyBpdCdzIGVhc2llciB0byByZWFkLlxuXG4qL1xuXG5jb25zdCBwcm9wVG9GbiA9IHtcbiAgeHM6IHZhbHVlID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcENsYXNzTmFtZShjID0+IHN0eWxlc1tjXSkoXG4gICAgICBwcmVmaXgoJ3hzJykoXG4gICAgICAgIGNvbmNhdChbXG4gICAgICAgICAgdmFsdWUuY29sdW1uID8gY29sdW1uKHZhbHVlLmNvbHVtbikgOiBpZGVudGl0eSgpLFxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS5kaXNwbGF5ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBkaXNwbGF5KHZhbHVlLmRpc3BsYXkpXG4gICAgICAgICAgICA6IGlkZW50aXR5KCksXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfSxcbiAgc206IHZhbHVlID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcENsYXNzTmFtZShjID0+IHN0eWxlc1tjXSkoXG4gICAgICBwcmVmaXgoJ3NtJykoXG4gICAgICAgIGNvbmNhdChbXG4gICAgICAgICAgdmFsdWUuY29sdW1uID8gY29sdW1uKHZhbHVlLmNvbHVtbikgOiBpZGVudGl0eSgpLFxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS5kaXNwbGF5ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBkaXNwbGF5KHZhbHVlLmRpc3BsYXkpXG4gICAgICAgICAgICA6IGlkZW50aXR5KCksXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfSxcbiAgbWQ6IHZhbHVlID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcENsYXNzTmFtZShjID0+IHN0eWxlc1tjXSkoXG4gICAgICBwcmVmaXgoJ21kJykoXG4gICAgICAgIGNvbmNhdChbXG4gICAgICAgICAgdmFsdWUuY29sdW1uID8gY29sdW1uKHZhbHVlLmNvbHVtbikgOiBpZGVudGl0eSgpLFxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS5kaXNwbGF5ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBkaXNwbGF5KHZhbHVlLmRpc3BsYXkpXG4gICAgICAgICAgICA6IGlkZW50aXR5KCksXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfSxcbiAgbGc6IHZhbHVlID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcENsYXNzTmFtZShjID0+IHN0eWxlc1tjXSkoXG4gICAgICBwcmVmaXgoJ2xnJykoXG4gICAgICAgIGNvbmNhdChbXG4gICAgICAgICAgdmFsdWUuY29sdW1uID8gY29sdW1uKHZhbHVlLmNvbHVtbikgOiBpZGVudGl0eSgpLFxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS5kaXNwbGF5ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBkaXNwbGF5KHZhbHVlLmRpc3BsYXkpXG4gICAgICAgICAgICA6IGlkZW50aXR5KCksXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfSxcblxuICBkaXNwbGF5OiBtYXBwaW5nKHtcbiAgICBub25lOiBzdHlsZXMueHNEaXNwbGF5Tm9uZSxcbiAgICBmbGV4OiBzdHlsZXMueHNEaXNwbGF5RmxleCxcbiAgICBibG9jazogc3R5bGVzLnhzRGlzcGxheUJsb2NrLFxuICAgIGlubGluZUJsb2NrOiBzdHlsZXMueHNEaXNwbGF5SW5saW5lQmxvY2ssXG4gICAgdmlzdWFsbHlIaWRkZW46IHN0eWxlcy54c0Rpc3BsYXlWaXN1YWxseUhpZGRlbixcbiAgfSksXG4gIGNvbHVtbjogYmluZChyYW5nZSgneHNDb2wnKSwgc3R5bGVzKSxcbiAgZGlyZWN0aW9uOiBtYXBwaW5nKHtcbiAgICByb3c6IHN0eWxlcy54c0RpcmVjdGlvblJvdyxcbiAgICBjb2x1bW46IHN0eWxlcy54c0RpcmVjdGlvbkNvbHVtbixcbiAgfSksXG5cbiAgc21EaXNwbGF5OiBtYXBwaW5nKHtcbiAgICBub25lOiBzdHlsZXMuc21EaXNwbGF5Tm9uZSxcbiAgICBmbGV4OiBzdHlsZXMuc21EaXNwbGF5RmxleCxcbiAgICBibG9jazogc3R5bGVzLnNtRGlzcGxheUJsb2NrLFxuICAgIGlubGluZUJsb2NrOiBzdHlsZXMuc21EaXNwbGF5SW5saW5lQmxvY2ssXG4gICAgdmlzdWFsbHlIaWRkZW46IHN0eWxlcy5zbURpc3BsYXlWaXN1YWxseUhpZGRlbixcbiAgfSksXG4gIHNtQ29sdW1uOiBiaW5kKHJhbmdlKCdzbUNvbCcpLCBzdHlsZXMpLFxuICBzbURpcmVjdGlvbjogbWFwcGluZyh7XG4gICAgcm93OiBzdHlsZXMuc21EaXJlY3Rpb25Sb3csXG4gICAgY29sdW1uOiBzdHlsZXMuc21EaXJlY3Rpb25Db2x1bW4sXG4gIH0pLFxuXG4gIG1kRGlzcGxheTogbWFwcGluZyh7XG4gICAgbm9uZTogc3R5bGVzLm1kRGlzcGxheU5vbmUsXG4gICAgZmxleDogc3R5bGVzLm1kRGlzcGxheUZsZXgsXG4gICAgYmxvY2s6IHN0eWxlcy5tZERpc3BsYXlCbG9jayxcbiAgICBpbmxpbmVCbG9jazogc3R5bGVzLm1kRGlzcGxheUlubGluZUJsb2NrLFxuICAgIHZpc3VhbGx5SGlkZGVuOiBzdHlsZXMubWREaXNwbGF5VmlzdWFsbHlIaWRkZW4sXG4gIH0pLFxuICBtZENvbHVtbjogYmluZChyYW5nZSgnbWRDb2wnKSwgc3R5bGVzKSxcbiAgbWREaXJlY3Rpb246IG1hcHBpbmcoe1xuICAgIHJvdzogc3R5bGVzLm1kRGlyZWN0aW9uUm93LFxuICAgIGNvbHVtbjogc3R5bGVzLm1kRGlyZWN0aW9uQ29sdW1uLFxuICB9KSxcblxuICBsZ0Rpc3BsYXk6IG1hcHBpbmcoe1xuICAgIG5vbmU6IHN0eWxlcy5sZ0Rpc3BsYXlOb25lLFxuICAgIGZsZXg6IHN0eWxlcy5sZ0Rpc3BsYXlGbGV4LFxuICAgIGJsb2NrOiBzdHlsZXMubGdEaXNwbGF5QmxvY2ssXG4gICAgaW5saW5lQmxvY2s6IHN0eWxlcy5sZ0Rpc3BsYXlJbmxpbmVCbG9jayxcbiAgICB2aXN1YWxseUhpZGRlbjogc3R5bGVzLmxnRGlzcGxheVZpc3VhbGx5SGlkZGVuLFxuICB9KSxcbiAgbGdDb2x1bW46IGJpbmQocmFuZ2UoJ2xnQ29sJyksIHN0eWxlcyksXG4gIGxnRGlyZWN0aW9uOiBtYXBwaW5nKHtcbiAgICByb3c6IHN0eWxlcy5sZ0RpcmVjdGlvblJvdyxcbiAgICBjb2x1bW46IHN0eWxlcy5sZ0RpcmVjdGlvbkNvbHVtbixcbiAgfSksXG5cbiAgYWxpZ25Db250ZW50OiBtYXBwaW5nKHtcbiAgICBzdGFydDogbGF5b3V0LmNvbnRlbnRTdGFydCxcbiAgICBlbmQ6IGxheW91dC5jb250ZW50RW5kLFxuICAgIGNlbnRlcjogbGF5b3V0LmNvbnRlbnRDZW50ZXIsXG4gICAgYmV0d2VlbjogbGF5b3V0LmNvbnRlbnRCZXR3ZWVuLFxuICAgIGFyb3VuZDogbGF5b3V0LmNvbnRlbnRBcm91bmQsXG4gICAgLy8gZGVmYXVsdDogc3RyZXRjaFxuICB9KSxcbiAgYWxpZ25JdGVtczogbWFwcGluZyh7XG4gICAgc3RhcnQ6IGxheW91dC5pdGVtc1N0YXJ0LFxuICAgIGVuZDogbGF5b3V0Lml0ZW1zRW5kLFxuICAgIGNlbnRlcjogbGF5b3V0Lml0ZW1zQ2VudGVyLFxuICAgIGJhc2VsaW5lOiBsYXlvdXQuaXRlbXNCYXNlbGluZSxcbiAgICAvLyBkZWZhdWx0OiBzdHJldGNoXG4gIH0pLFxuICBhbGlnblNlbGY6IG1hcHBpbmcoe1xuICAgIHN0YXJ0OiBsYXlvdXQuc2VsZlN0YXJ0LFxuICAgIGVuZDogbGF5b3V0LnNlbGZFbmQsXG4gICAgY2VudGVyOiBsYXlvdXQuc2VsZkNlbnRlcixcbiAgICBiYXNlbGluZTogbGF5b3V0LnNlbGZCYXNlbGluZSxcbiAgICBzdHJldGNoOiBsYXlvdXQuc2VsZlN0cmV0Y2gsXG4gICAgLy8gZGVmYXVsdDogYXV0b1xuICB9KSxcbiAgYm90dG9tOiB0b2dnbGUobGF5b3V0LmJvdHRvbTApLFxuICBjb2xvcjogbWFwcGluZyh7XG4gICAgYmx1ZTogY29sb3JzLmJsdWVCZyxcbiAgICBkYXJrR3JheTogY29sb3JzLmRhcmtHcmF5QmcsXG4gICAgcGluZTogY29sb3JzLnBpbmVCZyxcbiAgICBncmF5OiBjb2xvcnMuZ3JheUJnLFxuICAgIHJlZDogY29sb3JzLnJlZEJnLFxuICAgIG9saXZlOiBjb2xvcnMub2xpdmVCZyxcbiAgICBsaWdodEdyYXk6IGNvbG9ycy5saWdodEdyYXlCZyxcbiAgICB3aGl0ZTogY29sb3JzLndoaXRlQmcsXG4gICAgb3JhbmdlOiBjb2xvcnMub3JhbmdlQmcsXG4gICAgZ3JlZW46IGNvbG9ycy5ncmVlbkJnLFxuICAgIG5hdnk6IGNvbG9ycy5uYXZ5QmcsXG4gICAgbWlkbmlnaHQ6IGNvbG9ycy5taWRuaWdodEJnLFxuICAgIHB1cnBsZTogY29sb3JzLnB1cnBsZUJnLFxuICAgIG9yY2hpZDogY29sb3JzLm9yY2hpZEJnLFxuICAgIGVnZ3BsYW50OiBjb2xvcnMuZWdncGxhbnRCZyxcbiAgICBtYXJvb246IGNvbG9ycy5tYXJvb25CZyxcbiAgICB3YXRlcm1lbG9uOiBjb2xvcnMud2F0ZXJtZWxvbkJnLFxuICAgIGxpZ2h0V2FzaDogY29sb3JzLmxpZ2h0V2FzaEJnLFxuICAgIGRhcmtXYXNoOiBjb2xvcnMuZGFya1dhc2hCZyxcbiAgICB0cmFuc3BhcmVudERhcmtHcmF5OiBjb2xvcnMudHJhbnNwYXJlbnREYXJrR3JheUJnLFxuICAgIC8vIGRlZmF1bHQ6IHRyYW5zcGFyZW50XG4gIH0pLFxuICBmaXQ6IHRvZ2dsZShsYXlvdXQuZml0KSxcbiAgZmxleDogbWFwcGluZyh7XG4gICAgZ3JvdzogbGF5b3V0LmZsZXhHcm93LFxuICAgIG5vbmU6IGxheW91dC5mbGV4Tm9uZSxcbiAgICAvLyBkZWZhdWx0OiBzaHJpbmtcbiAgfSksXG4gIGhlaWdodDogaGVpZ2h0ID0+IGZyb21JbmxpbmVTdHlsZSh7IGhlaWdodCB9KSxcbiAganVzdGlmeUNvbnRlbnQ6IG1hcHBpbmcoe1xuICAgIGVuZDogbGF5b3V0Lmp1c3RpZnlFbmQsXG4gICAgY2VudGVyOiBsYXlvdXQuanVzdGlmeUNlbnRlcixcbiAgICBiZXR3ZWVuOiBsYXlvdXQuanVzdGlmeUJldHdlZW4sXG4gICAgYXJvdW5kOiBsYXlvdXQuanVzdGlmeUFyb3VuZCxcbiAgICAvLyBkZWZhdWx0OiBzdGFydFxuICB9KSxcbiAgbGVmdDogdG9nZ2xlKGxheW91dC5sZWZ0MCksXG4gIGRlcHJlY2F0ZWRNYXJnaW46IHZhbHVlID0+IHtcbiAgICBsZXQgbXQgPSBpZGVudGl0eSgpO1xuICAgIGxldCBtYiA9IGlkZW50aXR5KCk7XG4gICAgbGV0IG1sID0gaWRlbnRpdHkoKTtcbiAgICBsZXQgbXIgPSBpZGVudGl0eSgpO1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gZnJvbUNsYXNzTmFtZSh3aGl0ZXNwYWNlTGVnYWN5W2BtJHtmb3JtYXRJbnRCb2ludCh2YWx1ZSl9YF0pO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKHZhbHVlLnRvcCkge1xuICAgICAgICAgIG10ID0gZnJvbUNsYXNzTmFtZShcbiAgICAgICAgICAgIHdoaXRlc3BhY2VMZWdhY3lbYG10JHtmb3JtYXRJbnRCb2ludCh2YWx1ZS50b3ApfWBdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5ib3R0b20pIHtcbiAgICAgICAgICBtYiA9IGZyb21DbGFzc05hbWUoXG4gICAgICAgICAgICB3aGl0ZXNwYWNlTGVnYWN5W2BtYiR7Zm9ybWF0SW50Qm9pbnQodmFsdWUuYm90dG9tKX1gXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVmdCkge1xuICAgICAgICAgIG1sID0gZnJvbUNsYXNzTmFtZShcbiAgICAgICAgICAgIHZhbHVlLmxlZnQgPT09ICdhdXRvJ1xuICAgICAgICAgICAgICA/IHdoaXRlc3BhY2VMZWdhY3kubWxBdXRvXG4gICAgICAgICAgICAgIDogd2hpdGVzcGFjZUxlZ2FjeVtgbWwke2Zvcm1hdEludEJvaW50KHZhbHVlLmxlZnQpfWBdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5yaWdodCkge1xuICAgICAgICAgIG1yID0gZnJvbUNsYXNzTmFtZShcbiAgICAgICAgICAgIHZhbHVlLnJpZ2h0ID09PSAnYXV0bydcbiAgICAgICAgICAgICAgPyB3aGl0ZXNwYWNlTGVnYWN5Lm1yQXV0b1xuICAgICAgICAgICAgICA6IHdoaXRlc3BhY2VMZWdhY3lbYG1yJHtmb3JtYXRJbnRCb2ludCh2YWx1ZS5yaWdodCl9YF1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXQoW210LCBtYiwgbWwsIG1yXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gaWRlbnRpdHkoKTtcbiAgICB9XG4gIH0sXG4gIG1hcmdpblN0YXJ0LFxuICBtYXJnaW5FbmQsXG4gIG1hcmdpbixcbiAgbWFyZ2luVG9wLFxuICBtYXJnaW5SaWdodCxcbiAgbWFyZ2luQm90dG9tLFxuICBtYXJnaW5MZWZ0LFxuICBzbU1hcmdpbixcbiAgc21NYXJnaW5Ub3AsXG4gIHNtTWFyZ2luUmlnaHQsXG4gIHNtTWFyZ2luQm90dG9tLFxuICBzbU1hcmdpbkxlZnQsXG4gIG1kTWFyZ2luLFxuICBtZE1hcmdpblRvcCxcbiAgbWRNYXJnaW5SaWdodCxcbiAgbWRNYXJnaW5Cb3R0b20sXG4gIG1kTWFyZ2luTGVmdCxcbiAgbGdNYXJnaW4sXG4gIGxnTWFyZ2luVG9wLFxuICBsZ01hcmdpblJpZ2h0LFxuICBsZ01hcmdpbkJvdHRvbSxcbiAgbGdNYXJnaW5MZWZ0LFxuICBtYXhIZWlnaHQ6IG1heEhlaWdodCA9PiBmcm9tSW5saW5lU3R5bGUoeyBtYXhIZWlnaHQgfSksXG4gIG1heFdpZHRoOiBtYXhXaWR0aCA9PiBmcm9tSW5saW5lU3R5bGUoeyBtYXhXaWR0aCB9KSxcbiAgbWluSGVpZ2h0OiBtaW5IZWlnaHQgPT4gZnJvbUlubGluZVN0eWxlKHsgbWluSGVpZ2h0IH0pLFxuICBtaW5XaWR0aDogbWluV2lkdGggPT4gZnJvbUlubGluZVN0eWxlKHsgbWluV2lkdGggfSksXG4gIG92ZXJmbG93OiBtYXBwaW5nKHtcbiAgICBoaWRkZW46IGxheW91dC5vdmVyZmxvd0hpZGRlbixcbiAgICBzY3JvbGw6IGxheW91dC5vdmVyZmxvd1Njcm9sbCxcbiAgICBhdXRvOiBsYXlvdXQub3ZlcmZsb3dBdXRvLFxuICAgIHNjcm9sbFg6IGxheW91dC5vdmVyZmxvd1Njcm9sbFgsXG4gICAgc2Nyb2xsWTogbGF5b3V0Lm92ZXJmbG93U2Nyb2xsWSxcbiAgICAvLyBkZWZhdWx0OiB2aXNpYmxlXG4gIH0pLFxuICBkZXByZWNhdGVkUGFkZGluZzogdmFsdWUgPT4ge1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gZnJvbUNsYXNzTmFtZSh3aGl0ZXNwYWNlTGVnYWN5W2BwJHt2YWx1ZX1gXSk7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgICB2YWx1ZS54XG4gICAgICAgICAgICA/IGZyb21DbGFzc05hbWUod2hpdGVzcGFjZUxlZ2FjeVtgcHgke3ZhbHVlLnh9YF0pXG4gICAgICAgICAgICA6IGlkZW50aXR5KCksXG4gICAgICAgICAgdmFsdWUueVxuICAgICAgICAgICAgPyBmcm9tQ2xhc3NOYW1lKHdoaXRlc3BhY2VMZWdhY3lbYHB5JHt2YWx1ZS55fWBdKVxuICAgICAgICAgICAgOiBpZGVudGl0eSgpLFxuICAgICAgICBdKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBpZGVudGl0eSgpO1xuICAgIH1cbiAgfSxcbiAgcGFkZGluZyxcbiAgcGFkZGluZ1gsXG4gIHBhZGRpbmdZLFxuICBzbVBhZGRpbmcsXG4gIHNtUGFkZGluZ1gsXG4gIHNtUGFkZGluZ1ksXG4gIG1kUGFkZGluZyxcbiAgbWRQYWRkaW5nWCxcbiAgbWRQYWRkaW5nWSxcbiAgbGdQYWRkaW5nLFxuICBsZ1BhZGRpbmdYLFxuICBsZ1BhZGRpbmdZLFxuICBwb3NpdGlvbjogbWFwcGluZyh7XG4gICAgYWJzb2x1dGU6IGxheW91dC5hYnNvbHV0ZSxcbiAgICByZWxhdGl2ZTogbGF5b3V0LnJlbGF0aXZlLFxuICAgIGZpeGVkOiBsYXlvdXQuZml4ZWQsXG4gICAgLy8gZGVmYXVsdDogc3RhdGljXG4gIH0pLFxuICByaWdodDogdG9nZ2xlKGxheW91dC5yaWdodDApLFxuICBzaGFwZTogbWFwcGluZyh7XG4gICAgY2lyY2xlOiBib3JkZXJzLmNpcmNsZSxcbiAgICBwaWxsOiBib3JkZXJzLnBpbGwsXG4gICAgcm91bmRlZDogYm9yZGVycy5yb3VuZGVkLFxuICAgIHJvdW5kZWRCb3R0b206IGJvcmRlcnMucm91bmRlZEJvdHRvbSxcbiAgICByb3VuZGVkTGVmdDogYm9yZGVycy5yb3VuZGVkTGVmdCxcbiAgICByb3VuZGVkUmlnaHQ6IGJvcmRlcnMucm91bmRlZFJpZ2h0LFxuICAgIHJvdW5kZWRUb3A6IGJvcmRlcnMucm91bmRlZFRvcCxcbiAgICAvLyBkZWZhdWx0OiBzcXVhcmVcbiAgfSksXG4gIHRvcDogdG9nZ2xlKGxheW91dC50b3AwKSxcbiAgd2lkdGg6IHdpZHRoID0+IGZyb21JbmxpbmVTdHlsZSh7IHdpZHRoIH0pLFxuICB3cmFwOiB0b2dnbGUobGF5b3V0LmZsZXhXcmFwKSxcbiAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZTogdmFsdWUgPT5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cbiAgICB2YWx1ZSAmJiB2YWx1ZS5fX3N0eWxlID8gZnJvbUlubGluZVN0eWxlKHZhbHVlLl9fc3R5bGUpIDogaWRlbnRpdHkoKSxcbn07XG5cbi8qXG5cbiMgVGhlIENvbXBvbmVudFxuXG4qL1xuXG5jb25zdCBjb250YWlucyA9IChrZXksIGFycikgPT4gYXJyLmluZGV4T2Yoa2V5KSA+PSAwO1xuY29uc3Qgb21pdCA9IChrZXlzLCBvYmopID0+XG4gIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChhY2MsIGspID0+IHtcbiAgICBpZiAoY29udGFpbnMoaywga2V5cykpIHtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5hY2MsXG4gICAgICBba106IG9ialtrXSxcbiAgICB9O1xuICB9LCB7fSk7XG5cbi8vICRGbG93SXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzYxMDNcbmNvbnN0IEJveCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gICh7IGNoaWxkcmVuLCAuLi5wcm9wcyB9OiBQcm9wVHlwZSwgcmVmOiBSZWFjdC5FbGVtZW50UmVmPCo+KSA9PiB7XG4gICAgLy8gRmxvdyBjYW4ndCByZWFzb24gYWJvdXQgdGhlIGNvbnN0YW50IG5hdHVyZSBvZiBPYmplY3Qua2V5cyBzbyB3ZSBjYW4ndCB1c2VcbiAgICAvLyBhIGZ1bmN0aW9uYWwgKHJlZHVjZSkgc3R5bGUgaGVyZS5cblxuICAgIC8vIEJveCBpcyBhIFwicGFzcy10aHJvdWdoXCIgY29tcG9uZW50LCBtZWFuaW5nIHRoYXQgaWYgeW91IHBhc3MgcHJvcGVydGllcyB0b1xuICAgIC8vIGl0IHRoYXQgaXQgZG9lc24ndCBrbm93IGFib3V0IChgYXJpYS1sYWJlbGAgZm9yIGluc3RhbmNlKSBpdCBwYXNzZXNcbiAgICAvLyBkaXJlY3RseSBiYWNrIHRvIHRoZSB1bmRlcmx5aW5nIGA8ZGl2Lz5gLiBUaGF0J3MgZ2VuZXJhbGx5IHVzZWZ1bCwgYnV0XG4gICAgLy8gd2UnZCBhbHNvIGxpa2UgdG8gc3RyaXAgb3V0IGEgZmV3IG5hdWdodHkgcHJvcGVydGllcyB0aGF0IGJyZWFrIHN0eWxlXG4gICAgLy8gZW5jYXBzdWxhdGlvbiAoY2xhc3NOYW1lLCBzdHlsZSkgb3IgYWNjZXNzaWJpbGl0eSAob25DbGljaykuXG4gICAgbGV0IGJsYWNrbGlzdCA9IFsnb25DbGljaycsICdjbGFzc05hbWUnLCAnc3R5bGUnXTtcblxuICAgIC8vIEFsbCBCb3gncyBhcmUgYm94LXNpemVkIGJ5IGRlZmF1bHQsIHNvIHdlIHN0YXJ0IG9mZiBidWlsZGluZyB1cCB0aGUgc3R5bGVzXG4gICAgLy8gdG8gYmUgYXBwbGllZCB3aXRoIGEgQm94IGJhc2UgY2xhc3MuXG4gICAgbGV0IHMgPSBmcm9tQ2xhc3NOYW1lKHN0eWxlcy5ib3gpO1xuXG4gICAgLy8gVGhpcyBsb29wcyB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGlmIGl0IGV4aXN0cyBpbiB0aGUgcHJldmlvdXNseVxuICAgIC8vIGRlZmluZWQgdHJhbnNmb3JtIG1hcCwgY29uY2F0ZW50ZXMgdGhlIHJlc3VsdGluZyBzdHlsZXMgdG8gdGhlIGJhc2VcbiAgICAvLyBzdHlsZXMuIElmIHRoZXJlJ3MgYSBtYXRjaCwgd2UgYWxzbyBkb24ndCBwYXNzIHRocm91Z2ggdGhhdCBwcm9wZXJ0eS4gVGhpc1xuICAgIC8vIG1lYW5zIEJveCdzIHJ1bnRpbWUgaXMgb25seSBkZXBlbmRlbnQgb24gdGhlIG51bWJlciBvZiBwcm9wZXJ0aWVzIHBhc3NlZFxuICAgIC8vIHRvIGl0ICh3aGljaCBpcyB0eXBpY2FsbHkgc21hbGwpIGluc3RlYWQgb2YgdGhlIHRvdGFsIG51bWJlciBvZiBwb3NzaWJsZVxuICAgIC8vIHByb3BlcnRpZXMgKH4zMCBvciBzbykuIFdoaWxlIGl0IG1heSB+ZmVlbH4gbGlrZSBCb3ggaXMgaW5uZWZmaWNpZW50LCBpdHNcbiAgICAvLyBiaWdnZXN0IHBlcmZvcm1hbmNlIGltcGFjdCBpcyBvbiBzdGFydHVwIHRpbWUgYmVjYXVzZSB0aGVyZSdzIHNvIG11Y2ggY29kZVxuICAgIC8vIGhlcmUuXG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcFRvRm4sIHByb3ApKSB7XG4gICAgICAgIGNvbnN0IGZuID0gcHJvcFRvRm5bcHJvcF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcHNbcHJvcF07XG4gICAgICAgIGJsYWNrbGlzdCA9IGJsYWNrbGlzdC5jb25jYXQocHJvcCk7XG4gICAgICAgIHMgPSBjb25jYXQoW3MsIGZuKHZhbHVlKV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFuZC4uLiBtYWdpYyFcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiB7Li4ub21pdChibGFja2xpc3QsIHByb3BzKX0gey4uLnRvUHJvcHMocyl9IHJlZj17cmVmfT5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuKTtcblxuLy8gIE5PVEU6IFRoaXMgaXMgbmVlZGVkIGluIG9yZGVyIHRvIG92ZXJyaWRlIHRoZSBGb3J3YXJkUmVmIGRpc3BsYXkgbmFtZSB0aGF0IGlzXG4vLyAgdXNlZCBpbiBkZXYgdG9vbHMgYW5kIGluIHNuYXBzaG90IHRlc3RpbmcuXG5Cb3guZGlzcGxheU5hbWUgPSAnQm94JztcblxuZXhwb3J0IGRlZmF1bHQgQm94O1xuXG4vKlxuXG4jIFByb3BUeXBlc1xuXG5BbmQgd2UncmUgZG9uZSBoZXJlIDopXG5cbiovXG5cbmNvbnN0IENvbHVtblByb3BUeXBlID0gUHJvcFR5cGVzLm9uZU9mKFtcbiAgMCxcbiAgMSxcbiAgMixcbiAgMyxcbiAgNCxcbiAgNSxcbiAgNixcbiAgNyxcbiAgOCxcbiAgOSxcbiAgMTAsXG4gIDExLFxuICAxMixcbl0pO1xuXG5jb25zdCBNYXJnaW5Qcm9wVHlwZSA9IFByb3BUeXBlcy5vbmVPZihbXG4gIC0xMixcbiAgLTExLFxuICAtMTAsXG4gIC05LFxuICAtOCxcbiAgLTcsXG4gIC02LFxuICAtNSxcbiAgLTQsXG4gIC0zLFxuICAtMixcbiAgLTEsXG4gIDAsXG4gIDEsXG4gIDIsXG4gIDMsXG4gIDQsXG4gIDUsXG4gIDYsXG4gIDcsXG4gIDgsXG4gIDksXG4gIDEwLFxuICAxMSxcbiAgMTIsXG5dKTtcblxuY29uc3QgUGFkZGluZ1Byb3BUeXBlID0gUHJvcFR5cGVzLm9uZU9mKFtcbiAgMCxcbiAgMSxcbiAgMixcbiAgMyxcbiAgNCxcbiAgNSxcbiAgNixcbiAgNyxcbiAgOCxcbiAgOSxcbiAgMTAsXG4gIDExLFxuICAxMixcbl0pO1xuXG4vLyAkRmxvd0lzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy83NDg0XG5Cb3gucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU6IFByb3BUeXBlcy5leGFjdCh7XG4gICAgX19zdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgfSksXG5cbiAgeHM6IFByb3BUeXBlcy5leGFjdCh7XG4gICAgZGlzcGxheTogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuYm9vbCxcbiAgICAgIFByb3BUeXBlcy5vbmVPZihbJ2ZsZXgnLCAnZmxleENvbHVtbicsICdpbmxpbmVCbG9jayddKSxcbiAgICBdKSxcbiAgICBjb2x1bW46IFByb3BUeXBlcy5udW1iZXIsXG4gIH0pLFxuICBzbTogUHJvcFR5cGVzLmV4YWN0KHtcbiAgICBkaXNwbGF5OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgIFByb3BUeXBlcy5ib29sLFxuICAgICAgUHJvcFR5cGVzLm9uZU9mKFsnZmxleCcsICdmbGV4Q29sdW1uJywgJ2lubGluZUJsb2NrJ10pLFxuICAgIF0pLFxuICAgIGNvbHVtbjogUHJvcFR5cGVzLm51bWJlcixcbiAgfSksXG4gIG1kOiBQcm9wVHlwZXMuZXhhY3Qoe1xuICAgIGRpc3BsYXk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgUHJvcFR5cGVzLmJvb2wsXG4gICAgICBQcm9wVHlwZXMub25lT2YoWydmbGV4JywgJ2ZsZXhDb2x1bW4nLCAnaW5saW5lQmxvY2snXSksXG4gICAgXSksXG4gICAgY29sdW1uOiBQcm9wVHlwZXMubnVtYmVyLFxuICB9KSxcbiAgbGc6IFByb3BUeXBlcy5leGFjdCh7XG4gICAgZGlzcGxheTogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuYm9vbCxcbiAgICAgIFByb3BUeXBlcy5vbmVPZihbJ2ZsZXgnLCAnZmxleENvbHVtbicsICdpbmxpbmVCbG9jayddKSxcbiAgICBdKSxcbiAgICBjb2x1bW46IFByb3BUeXBlcy5udW1iZXIsXG4gIH0pLFxuICBkZXByZWNhdGVkTWFyZ2luOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMubnVtYmVyLFxuICAgIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICBib3R0b206IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICBsZWZ0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMub25lT2YoWydhdXRvJ10pXSksXG4gICAgICByaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLm9uZU9mKFsnYXV0byddKV0pLFxuICAgIH0pLFxuICBdKSxcbiAgZGVwcmVjYXRlZFBhZGRpbmc6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgIFByb3BUeXBlcy5udW1iZXIsXG4gICAgUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIHg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICB5OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIH0pLFxuICBdKSxcblxuICBkaXNwbGF5OiBQcm9wVHlwZXMub25lT2YoW1xuICAgICdub25lJyxcbiAgICAnZmxleCcsXG4gICAgJ2Jsb2NrJyxcbiAgICAnaW5saW5lQmxvY2snLFxuICAgICd2aXN1YWxseUhpZGRlbicsXG4gIF0pLFxuICBkaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ3JvdycsICdjb2x1bW4nXSksXG4gIGNvbHVtbjogQ29sdW1uUHJvcFR5cGUsXG5cbiAgc21EaXNwbGF5OiBQcm9wVHlwZXMub25lT2YoW1xuICAgICdub25lJyxcbiAgICAnZmxleCcsXG4gICAgJ2Jsb2NrJyxcbiAgICAnaW5saW5lQmxvY2snLFxuICAgICd2aXN1YWxseUhpZGRlbicsXG4gIF0pLFxuICBzbURpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsncm93JywgJ2NvbHVtbiddKSxcbiAgc21Db2x1bW46IENvbHVtblByb3BUeXBlLFxuXG4gIG1kRGlzcGxheTogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnbm9uZScsXG4gICAgJ2ZsZXgnLFxuICAgICdibG9jaycsXG4gICAgJ2lubGluZUJsb2NrJyxcbiAgICAndmlzdWFsbHlIaWRkZW4nLFxuICBdKSxcbiAgbWREaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ3JvdycsICdjb2x1bW4nXSksXG4gIG1kQ29sdW1uOiBDb2x1bW5Qcm9wVHlwZSxcblxuICBsZ0Rpc3BsYXk6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ25vbmUnLFxuICAgICdmbGV4JyxcbiAgICAnYmxvY2snLFxuICAgICdpbmxpbmVCbG9jaycsXG4gICAgJ3Zpc3VhbGx5SGlkZGVuJyxcbiAgXSksXG4gIGxnRGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoWydyb3cnLCAnY29sdW1uJ10pLFxuICBsZ0NvbHVtbjogQ29sdW1uUHJvcFR5cGUsXG5cbiAgYWxpZ25Db250ZW50OiBQcm9wVHlwZXMub25lT2YoW1xuICAgICdzdGFydCcsXG4gICAgJ2VuZCcsXG4gICAgJ2NlbnRlcicsXG4gICAgJ2JldHdlZW4nLFxuICAgICdhcm91bmQnLFxuICAgICdzdHJldGNoJyxcbiAgXSksXG4gIGFsaWduSXRlbXM6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ3N0YXJ0JyxcbiAgICAnZW5kJyxcbiAgICAnY2VudGVyJyxcbiAgICAnYmFzZWxpbmUnLFxuICAgICdzdHJldGNoJyxcbiAgXSksXG4gIGFsaWduU2VsZjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnYXV0bycsXG4gICAgJ3N0YXJ0JyxcbiAgICAnZW5kJyxcbiAgICAnY2VudGVyJyxcbiAgICAnYmFzZWxpbmUnLFxuICAgICdzdHJldGNoJyxcbiAgXSksXG4gIGJvdHRvbTogUHJvcFR5cGVzLmJvb2wsXG4gIGNvbG9yOiBQcm9wVHlwZXMub25lT2YoW1xuICAgICdibHVlJyxcbiAgICAnZGFya0dyYXknLFxuICAgICdkYXJrV2FzaCcsXG4gICAgJ2VnZ3BsYW50JyxcbiAgICAnZ3JheScsXG4gICAgJ2dyZWVuJyxcbiAgICAnbGlnaHRHcmF5JyxcbiAgICAnbGlnaHRXYXNoJyxcbiAgICAnbWFyb29uJyxcbiAgICAnbWlkbmlnaHQnLFxuICAgICduYXZ5JyxcbiAgICAnb2xpdmUnLFxuICAgICdvcmFuZ2UnLFxuICAgICdvcmNoaWQnLFxuICAgICdwaW5lJyxcbiAgICAncHVycGxlJyxcbiAgICAncmVkJyxcbiAgICAndHJhbnNwYXJlbnQnLFxuICAgICd0cmFuc3BhcmVudERhcmtHcmF5JyxcbiAgICAnd2F0ZXJtZWxvbicsXG4gICAgJ3doaXRlJyxcbiAgXSksXG4gIGZpdDogUHJvcFR5cGVzLmJvb2wsXG4gIGZsZXg6IFByb3BUeXBlcy5vbmVPZihbJ2dyb3cnLCAnc2hyaW5rJywgJ25vbmUnXSksXG4gIGdyb3c6IFByb3BUeXBlcy5ib29sLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAganVzdGlmeUNvbnRlbnQ6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ3N0YXJ0JyxcbiAgICAnZW5kJyxcbiAgICAnY2VudGVyJyxcbiAgICAnYmV0d2VlbicsXG4gICAgJ2Fyb3VuZCcsXG4gIF0pLFxuICBsZWZ0OiBQcm9wVHlwZXMuYm9vbCxcblxuICBtYXJnaW5TdGFydDogTWFyZ2luUHJvcFR5cGUsXG4gIG1hcmdpbkVuZDogTWFyZ2luUHJvcFR5cGUsXG5cbiAgbWFyZ2luOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbWFyZ2luVG9wOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbWFyZ2luUmlnaHQ6IE1hcmdpblByb3BUeXBlLFxuICBtYXJnaW5Cb3R0b206IE1hcmdpblByb3BUeXBlLFxuICBtYXJnaW5MZWZ0OiBNYXJnaW5Qcm9wVHlwZSxcblxuICBzbU1hcmdpbjogTWFyZ2luUHJvcFR5cGUsXG4gIHNtTWFyZ2luVG9wOiBNYXJnaW5Qcm9wVHlwZSxcbiAgc21NYXJnaW5SaWdodDogTWFyZ2luUHJvcFR5cGUsXG4gIHNtTWFyZ2luQm90dG9tOiBNYXJnaW5Qcm9wVHlwZSxcbiAgc21NYXJnaW5MZWZ0OiBNYXJnaW5Qcm9wVHlwZSxcblxuICBtZE1hcmdpbjogTWFyZ2luUHJvcFR5cGUsXG4gIG1kTWFyZ2luVG9wOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbWRNYXJnaW5SaWdodDogTWFyZ2luUHJvcFR5cGUsXG4gIG1kTWFyZ2luQm90dG9tOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbWRNYXJnaW5MZWZ0OiBNYXJnaW5Qcm9wVHlwZSxcblxuICBsZ01hcmdpbjogTWFyZ2luUHJvcFR5cGUsXG4gIGxnTWFyZ2luVG9wOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbGdNYXJnaW5SaWdodDogTWFyZ2luUHJvcFR5cGUsXG4gIGxnTWFyZ2luQm90dG9tOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbGdNYXJnaW5MZWZ0OiBNYXJnaW5Qcm9wVHlwZSxcblxuICBtYXhIZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgbWF4V2lkdGg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgbWluSGVpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIG1pbldpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgb3ZlcmZsb3c6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ3Zpc2libGUnLFxuICAgICdoaWRkZW4nLFxuICAgICdzY3JvbGwnLFxuICAgICdzY3JvbGxYJyxcbiAgICAnc2Nyb2xsWScsXG4gICAgJ2F1dG8nLFxuICBdKSxcblxuICBwYWRkaW5nOiBQYWRkaW5nUHJvcFR5cGUsXG4gIHBhZGRpbmdYOiBQYWRkaW5nUHJvcFR5cGUsXG4gIHBhZGRpbmdZOiBQYWRkaW5nUHJvcFR5cGUsXG5cbiAgc21QYWRkaW5nOiBQYWRkaW5nUHJvcFR5cGUsXG4gIHNtUGFkZGluZ1g6IFBhZGRpbmdQcm9wVHlwZSxcbiAgc21QYWRkaW5nWTogUGFkZGluZ1Byb3BUeXBlLFxuXG4gIG1kUGFkZGluZzogUGFkZGluZ1Byb3BUeXBlLFxuICBtZFBhZGRpbmdYOiBQYWRkaW5nUHJvcFR5cGUsXG4gIG1kUGFkZGluZ1k6IFBhZGRpbmdQcm9wVHlwZSxcblxuICBsZ1BhZGRpbmc6IFBhZGRpbmdQcm9wVHlwZSxcbiAgbGdQYWRkaW5nWDogUGFkZGluZ1Byb3BUeXBlLFxuICBsZ1BhZGRpbmdZOiBQYWRkaW5nUHJvcFR5cGUsXG5cbiAgcG9zaXRpb246IFByb3BUeXBlcy5vbmVPZihbJ3N0YXRpYycsICdhYnNvbHV0ZScsICdyZWxhdGl2ZScsICdmaXhlZCddKSxcbiAgcmlnaHQ6IFByb3BUeXBlcy5ib29sLFxuICBzaGFwZTogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnc3F1YXJlJyxcbiAgICAncm91bmRlZCcsXG4gICAgJ3BpbGwnLFxuICAgICdjaXJjbGUnLFxuICAgICdyb3VuZGVkVG9wJyxcbiAgICAncm91bmRlZEJvdHRvbScsXG4gICAgJ3JvdW5kZWRMZWZ0JyxcbiAgICAncm91bmRlZFJpZ2h0JyxcbiAgXSksXG4gIHRvcDogUHJvcFR5cGVzLmJvb2wsXG4gIHdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIHdyYXA6IFByb3BUeXBlcy5ib29sLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgYWRkIGZyb20gJy4vYWRkLnN2Zyc7XG5pbXBvcnQgYWRkQ2lyY2xlIGZyb20gJy4vYWRkLWNpcmNsZS5zdmcnO1xuaW1wb3J0IGFkZFBpbiBmcm9tICcuL2FkZC1waW4uc3ZnJztcbmltcG9ydCBhbGVydCBmcm9tICcuL2FsZXJ0LnN2Zyc7XG5pbXBvcnQgYWxpZ25Cb3R0b21DZW50ZXIgZnJvbSAnLi9hbGlnbi1ib3R0b20tY2VudGVyLnN2Zyc7XG5pbXBvcnQgYWxpZ25Cb3R0b21MZWZ0IGZyb20gJy4vYWxpZ24tYm90dG9tLWxlZnQuc3ZnJztcbmltcG9ydCBhbGlnbkJvdHRvbVJpZ2h0IGZyb20gJy4vYWxpZ24tYm90dG9tLXJpZ2h0LnN2Zyc7XG5pbXBvcnQgYWxpZ25Cb3R0b20gZnJvbSAnLi9hbGlnbi1ib3R0b20uc3ZnJztcbmltcG9ydCBhbGlnbk1pZGRsZSBmcm9tICcuL2FsaWduLW1pZGRsZS5zdmcnO1xuaW1wb3J0IGFsaWduVG9wQ2VudGVyIGZyb20gJy4vYWxpZ24tdG9wLWNlbnRlci5zdmcnO1xuaW1wb3J0IGFsaWduVG9wTGVmdCBmcm9tICcuL2FsaWduLXRvcC1sZWZ0LnN2Zyc7XG5pbXBvcnQgYWxpZ25Ub3BSaWdodCBmcm9tICcuL2FsaWduLXRvcC1yaWdodC5zdmcnO1xuaW1wb3J0IGFsaWduVG9wIGZyb20gJy4vYWxpZ24tdG9wLnN2Zyc7XG5pbXBvcnQgYW5nbGVkUGluIGZyb20gJy4vYW5nbGVkLXBpbi5zdmcnO1xuaW1wb3J0IGFwcHMgZnJvbSAnLi9hcHBzLnN2Zyc7XG5pbXBvcnQgYXJyb3dCYWNrIGZyb20gJy4vYXJyb3ctYmFjay5zdmcnO1xuaW1wb3J0IGFycm93Q2lyY2xlRG93biBmcm9tICcuL2Fycm93LWNpcmNsZS1kb3duLnN2Zyc7XG5pbXBvcnQgYXJyb3dDaXJjbGVGb3J3YXJkIGZyb20gJy4vYXJyb3ctY2lyY2xlLWZvcndhcmQuc3ZnJztcbmltcG9ydCBhcnJvd0NpcmNsZVVwIGZyb20gJy4vYXJyb3ctY2lyY2xlLXVwLnN2Zyc7XG5pbXBvcnQgYXJyb3dEb3duIGZyb20gJy4vYXJyb3ctZG93bi5zdmcnO1xuaW1wb3J0IGFycm93Rm9yd2FyZCBmcm9tICcuL2Fycm93LWZvcndhcmQuc3ZnJztcbmltcG9ydCBhcnJvd1VwIGZyb20gJy4vYXJyb3ctdXAuc3ZnJztcbmltcG9ydCBhcnJvd1VwUmlnaHQgZnJvbSAnLi9hcnJvdy11cC1yaWdodC5zdmcnO1xuaW1wb3J0IGJlbGwgZnJvbSAnLi9iZWxsLnN2Zyc7XG5pbXBvcnQgY2FtZXJhIGZyb20gJy4vY2FtZXJhLnN2Zyc7XG5pbXBvcnQgY2FtZXJhUm9sbCBmcm9tICcuL2NhbWVyYS1yb2xsLnN2Zyc7XG5pbXBvcnQgY2FuY2VsIGZyb20gJy4vY2FuY2VsLnN2Zyc7XG5pbXBvcnQgY2Fub25pY2FsUGluIGZyb20gJy4vY2Fub25pY2FsLXBpbi5zdmcnO1xuaW1wb3J0IGNoZWNrIGZyb20gJy4vY2hlY2suc3ZnJztcbmltcG9ydCBjaGVja0NpcmNsZSBmcm9tICcuL2NoZWNrLWNpcmNsZS5zdmcnO1xuaW1wb3J0IGNpcmNsZU91dGxpbmUgZnJvbSAnLi9jaXJjbGUtb3V0bGluZS5zdmcnO1xuaW1wb3J0IGNsZWFyIGZyb20gJy4vY2xlYXIuc3ZnJztcbmltcG9ydCBjbG9jayBmcm9tICcuL2Nsb2NrLnN2Zyc7XG5pbXBvcnQgY29nIGZyb20gJy4vY29nLnN2Zyc7XG5pbXBvcnQgY29sb3JQaWNrZXIgZnJvbSAnLi9jb2xvci1waWNrZXIuc3ZnJztcbmltcG9ydCBjb21wYXNzIGZyb20gJy4vY29tcGFzcy5zdmcnO1xuaW1wb3J0IGNvbXBvc2UgZnJvbSAnLi9jb21wb3NlLnN2Zyc7XG5pbXBvcnQgY3JvcCBmcm9tICcuL2Nyb3Auc3ZnJztcbmltcG9ydCBkYXNoIGZyb20gJy4vZGFzaC5zdmcnO1xuaW1wb3J0IGRvd25sb2FkIGZyb20gJy4vZG93bmxvYWQuc3ZnJztcbmltcG9ydCBlZGl0IGZyb20gJy4vZWRpdC5zdmcnO1xuaW1wb3J0IGVsbGlwc2lzIGZyb20gJy4vZWxsaXBzaXMuc3ZnJztcbmltcG9ydCBlbGxpcHNpc0NpcmNsZU91dGxpbmUgZnJvbSAnLi9lbGxpcHNpcy1jaXJjbGUtb3V0bGluZS5zdmcnO1xuaW1wb3J0IGVudmVsb3BlIGZyb20gJy4vZW52ZWxvcGUuc3ZnJztcbmltcG9ydCBleWUgZnJvbSAnLi9leWUuc3ZnJztcbmltcG9ydCBmYWNlYm9vayBmcm9tICcuL2ZhY2Vib29rLnN2Zyc7XG5pbXBvcnQgZmFjZUhhcHB5IGZyb20gJy4vZmFjZS1oYXBweS5zdmcnO1xuaW1wb3J0IGZhY2VTYWQgZnJvbSAnLi9mYWNlLXNhZC5zdmcnO1xuaW1wb3J0IGZhY2VTbWlsZXkgZnJvbSAnLi9mYWNlLXNtaWxleS5zdmcnO1xuaW1wb3J0IGZpbHRlciBmcm9tICcuL2ZpbHRlci5zdmcnO1xuaW1wb3J0IGZpbGxPcGFxdWUgZnJvbSAnLi9maWxsLW9wYXF1ZS5zdmcnO1xuaW1wb3J0IGZpbGxUcmFuc3BhcmVudCBmcm9tICcuL2ZpbGwtdHJhbnNwYXJlbnQuc3ZnJztcbmltcG9ydCBmbGFnIGZyb20gJy4vZmxhZy5zdmcnO1xuaW1wb3J0IGZsYXNobGlnaHQgZnJvbSAnLi9mbGFzaGxpZ2h0LnN2Zyc7XG5pbXBvcnQgZmxpcEhvcml6b250YWwgZnJvbSAnLi9mbGlwLWhvcml6b250YWwuc3ZnJztcbmltcG9ydCBmbGlwVmVydGljYWwgZnJvbSAnLi9mbGlwLXZlcnRpY2FsLnN2Zyc7XG5pbXBvcnQgZ2lmIGZyb20gJy4vZ2lmLnN2Zyc7XG5pbXBvcnQgZ2xvYmUgZnJvbSAnLi9nbG9iZS5zdmcnO1xuaW1wb3J0IGdsb2JlQ2hlY2tlZCBmcm9tICcuL2dsb2JlLWNoZWNrZWQuc3ZnJztcbmltcG9ydCBnbWFpbCBmcm9tICcuL2dtYWlsLnN2Zyc7XG5pbXBvcnQgZ29vZ2xlUGx1cyBmcm9tICcuL2dvb2dsZS1wbHVzLnN2Zyc7XG5pbXBvcnQgZ3JhcGhCYXIgZnJvbSAnLi9ncmFwaC1iYXIuc3ZnJztcbmltcG9ydCBrbm9vcCBmcm9tICcuL2tub29wLnN2Zyc7XG5pbXBvcnQgbGlnaHRidWxiIGZyb20gJy4vbGlnaHRidWxiLnN2Zyc7XG5pbXBvcnQgbG9nb3V0IGZyb20gJy4vbG9nb3V0LnN2Zyc7XG5pbXBvcnQgbG9nb0xhcmdlIGZyb20gJy4vbG9nby1sYXJnZS5zdmcnO1xuaW1wb3J0IGxvZ29TbWFsbCBmcm9tICcuL2xvZ28tc21hbGwuc3ZnJztcbmltcG9ydCBoYW5kbGUgZnJvbSAnLi9oYW5kbGUuc3ZnJztcbmltcG9ydCBoYW5kUG9pbnRpbmcgZnJvbSAnLi9oYW5kLXBvaW50aW5nLnN2Zyc7XG5pbXBvcnQgaGVhcnQgZnJvbSAnLi9oZWFydC5zdmcnO1xuaW1wb3J0IGhlYXJ0QnJva2VuIGZyb20gJy4vaGVhcnQtYnJva2VuLnN2Zyc7XG5pbXBvcnQgaW1wcmVzc3VtIGZyb20gJy4vaW1wcmVzc3VtLnN2Zyc7XG5pbXBvcnQgbGluayBmcm9tICcuL2xpbmsuc3ZnJztcbmltcG9ydCBsb2NhdGlvbiBmcm9tICcuL2xvY2F0aW9uLnN2Zyc7XG5pbXBvcnQgbG9jayBmcm9tICcuL2xvY2suc3ZnJztcbmltcG9ydCBtYXJnaW5zTGFyZ2UgZnJvbSAnLi9tYXJnaW5zLWxhcmdlLnN2Zyc7XG5pbXBvcnQgbWFyZ2luc01lZGl1bSBmcm9tICcuL21hcmdpbnMtbWVkaXVtLnN2Zyc7XG5pbXBvcnQgbWFyZ2luc1NtYWxsIGZyb20gJy4vbWFyZ2lucy1zbWFsbC5zdmcnO1xuaW1wb3J0IG1heGltaXplIGZyb20gJy4vbWF4aW1pemUuc3ZnJztcbmltcG9ydCBtZWdhcGhvbmUgZnJvbSAnLi9tZWdhcGhvbmUuc3ZnJztcbmltcG9ydCBtZW51IGZyb20gJy4vbWVudS5zdmcnO1xuaW1wb3J0IG1pbmltaXplIGZyb20gJy4vbWluaW1pemUuc3ZnJztcbmltcG9ydCBtb3ZlIGZyb20gJy4vbW92ZS5zdmcnO1xuaW1wb3J0IG11dGUgZnJvbSAnLi9tdXRlLnN2Zyc7XG5pbXBvcnQgb3ZlcmxheVRleHQgZnJvbSAnLi9vdmVybGF5LXRleHQuc3ZnJztcbmltcG9ydCBwYXVzZSBmcm9tICcuL3BhdXNlLnN2Zyc7XG5pbXBvcnQgcGVvcGxlIGZyb20gJy4vcGVvcGxlLnN2Zyc7XG5pbXBvcnQgcGVyc29uIGZyb20gJy4vcGVyc29uLnN2Zyc7XG5pbXBvcnQgcGVyc29uQWRkIGZyb20gJy4vcGVyc29uLWFkZC5zdmcnO1xuaW1wb3J0IHBpbiBmcm9tICcuL3Bpbi5zdmcnO1xuaW1wb3J0IHBpbkhpZGUgZnJvbSAnLi9waW4taGlkZS5zdmcnO1xuaW1wb3J0IHBpbnRlcmVzdCBmcm9tICcuL3BpbnRlcmVzdC5zdmcnO1xuaW1wb3J0IHBsYXkgZnJvbSAnLi9wbGF5LnN2Zyc7XG5pbXBvcnQgcXVlc3Rpb25NYXJrIGZyb20gJy4vcXVlc3Rpb24tbWFyay5zdmcnO1xuaW1wb3J0IHJlbW92ZSBmcm9tICcuL3JlbW92ZS5zdmcnO1xuaW1wb3J0IHJlb3JkZXJJbWFnZXMgZnJvbSAnLi9yZW9yZGVyLWltYWdlcy5zdmcnO1xuaW1wb3J0IHJlcG9ydCBmcm9tICcuL3JlcG9ydC5zdmcnO1xuaW1wb3J0IHJvdGF0ZSBmcm9tICcuL3JvdGF0ZS5zdmcnO1xuaW1wb3J0IHNlYXJjaCBmcm9tICcuL3NlYXJjaC5zdmcnO1xuaW1wb3J0IHNlY3VyaXR5IGZyb20gJy4vc2VjdXJpdHkuc3ZnJztcbmltcG9ydCBzZW5kIGZyb20gJy4vc2VuZC5zdmcnO1xuaW1wb3J0IHNoYXJlIGZyb20gJy4vc2hhcmUuc3ZnJztcbmltcG9ydCBzaG9wcGluZ0JhZyBmcm9tICcuL3Nob3BwaW5nLWJhZy5zdmcnO1xuaW1wb3J0IHNtaWxleSBmcm9tICcuL3NtaWxleS5zdmcnO1xuaW1wb3J0IHNtaWxleU91dGxpbmUgZnJvbSAnLi9zbWlsZXktb3V0bGluZS5zdmcnO1xuaW1wb3J0IHNvdW5kIGZyb20gJy4vc291bmQuc3ZnJztcbmltcG9ydCBzcGVlY2ggZnJvbSAnLi9zcGVlY2guc3ZnJztcbmltcG9ydCBzcGVlY2hFbGxpcHNpcyBmcm9tICcuL3NwZWVjaC1lbGxpcHNpcy5zdmcnO1xuaW1wb3J0IHN0YXIgZnJvbSAnLi9zdGFyLnN2Zyc7XG5pbXBvcnQgc3dpdGNoQWNjb3VudCBmcm9tICcuL3N3aXRjaC1hY2NvdW50LnN2Zyc7XG5pbXBvcnQgdGFnIGZyb20gJy4vdGFnLnN2Zyc7XG5pbXBvcnQgdGVybXMgZnJvbSAnLi90ZXJtcy5zdmcnO1xuaW1wb3J0IHRleHRBbGlnbkNlbnRlciBmcm9tICcuL3RleHQtYWxpZ24tY2VudGVyLnN2Zyc7XG5pbXBvcnQgdGV4dEFsaWduTGVmdCBmcm9tICcuL3RleHQtYWxpZ24tbGVmdC5zdmcnO1xuaW1wb3J0IHRleHRBbGlnblJpZ2h0IGZyb20gJy4vdGV4dC1hbGlnbi1yaWdodC5zdmcnO1xuaW1wb3J0IHRleHRBbGxDYXBzIGZyb20gJy4vdGV4dC1hbGwtY2Fwcy5zdmcnO1xuaW1wb3J0IHRleHRFeHRyYVNtYWxsIGZyb20gJy4vdGV4dC1leHRyYS1zbWFsbC5zdmcnO1xuaW1wb3J0IHRleHRMYXJnZSBmcm9tICcuL3RleHQtbGFyZ2Uuc3ZnJztcbmltcG9ydCB0ZXh0TGluZUhlaWdodCBmcm9tICcuL3RleHQtbGluZS1oZWlnaHQuc3ZnJztcbmltcG9ydCB0ZXh0TWVkaXVtIGZyb20gJy4vdGV4dC1tZWRpdW0uc3ZnJztcbmltcG9ydCB0ZXh0U2VudGVuY2VDYXNlIGZyb20gJy4vdGV4dC1zZW50ZW5jZS1jYXNlLnN2Zyc7XG5pbXBvcnQgdGV4dFNpemUgZnJvbSAnLi90ZXh0LXNpemUuc3ZnJztcbmltcG9ydCB0ZXh0U21hbGwgZnJvbSAnLi90ZXh0LXNtYWxsLnN2Zyc7XG5pbXBvcnQgdGV4dFNwYWNpbmcgZnJvbSAnLi90ZXh0LXNwYWNpbmcuc3ZnJztcbmltcG9ydCB0cmFzaENhbiBmcm9tICcuL3RyYXNoLWNhbi5zdmcnO1xuaW1wb3J0IHR3aXR0ZXIgZnJvbSAnLi90d2l0dGVyLnN2Zyc7XG5pbXBvcnQgdmlkZW9DYW1lcmEgZnJvbSAnLi92aWRlby1jYW1lcmEuc3ZnJztcbmltcG9ydCB2aWV3VHlwZURlZmF1bHQgZnJvbSAnLi92aWV3LXR5cGUtZGVmYXVsdC5zdmcnO1xuaW1wb3J0IHZpZXdUeXBlRGVuc2UgZnJvbSAnLi92aWV3LXR5cGUtZGVuc2Uuc3ZnJztcbmltcG9ydCB2aWV3VHlwZUxpc3QgZnJvbSAnLi92aWV3LXR5cGUtbGlzdC5zdmcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGFkZCxcbiAgJ2FkZC1jaXJjbGUnOiBhZGRDaXJjbGUsXG4gICdhZGQtcGluJzogYWRkUGluLFxuICBhbGVydCxcbiAgJ2FsaWduLWJvdHRvbS1jZW50ZXInOiBhbGlnbkJvdHRvbUNlbnRlcixcbiAgJ2FsaWduLWJvdHRvbS1sZWZ0JzogYWxpZ25Cb3R0b21MZWZ0LFxuICAnYWxpZ24tYm90dG9tLXJpZ2h0JzogYWxpZ25Cb3R0b21SaWdodCxcbiAgJ2FsaWduLWJvdHRvbSc6IGFsaWduQm90dG9tLFxuICAnYWxpZ24tbWlkZGxlJzogYWxpZ25NaWRkbGUsXG4gICdhbGlnbi10b3AtY2VudGVyJzogYWxpZ25Ub3BDZW50ZXIsXG4gICdhbGlnbi10b3AtbGVmdCc6IGFsaWduVG9wTGVmdCxcbiAgJ2FsaWduLXRvcC1yaWdodCc6IGFsaWduVG9wUmlnaHQsXG4gICdhbGlnbi10b3AnOiBhbGlnblRvcCxcbiAgJ2FuZ2xlZC1waW4nOiBhbmdsZWRQaW4sXG4gIGFwcHMsXG4gICdhcnJvdy1iYWNrJzogYXJyb3dCYWNrLFxuICAnYXJyb3ctY2lyY2xlLWRvd24nOiBhcnJvd0NpcmNsZURvd24sXG4gICdhcnJvdy1jaXJjbGUtZm9yd2FyZCc6IGFycm93Q2lyY2xlRm9yd2FyZCxcbiAgJ2Fycm93LWNpcmNsZS11cCc6IGFycm93Q2lyY2xlVXAsXG4gICdhcnJvdy1kb3duJzogYXJyb3dEb3duLFxuICAnYXJyb3ctZm9yd2FyZCc6IGFycm93Rm9yd2FyZCxcbiAgJ2Fycm93LXVwJzogYXJyb3dVcCxcbiAgJ2Fycm93LXVwLXJpZ2h0JzogYXJyb3dVcFJpZ2h0LFxuICBiZWxsLFxuICBjYW1lcmEsXG4gICdjYW1lcmEtcm9sbCc6IGNhbWVyYVJvbGwsXG4gIGNhbmNlbCxcbiAgJ2Nhbm9uaWNhbC1waW4nOiBjYW5vbmljYWxQaW4sXG4gICdjb2xvci1waWNrZXInOiBjb2xvclBpY2tlcixcbiAgY2hlY2ssXG4gICdjaGVjay1jaXJjbGUnOiBjaGVja0NpcmNsZSxcbiAgJ2NpcmNsZS1vdXRsaW5lJzogY2lyY2xlT3V0bGluZSxcbiAgY2xlYXIsXG4gIGNsb2NrLFxuICBjb2csXG4gIGNvbXBhc3MsXG4gIGNvbXBvc2UsXG4gIGNyb3AsXG4gIGRhc2gsXG4gIGRvd25sb2FkLFxuICBlZGl0LFxuICBlbGxpcHNpcyxcbiAgJ2VsbGlwc2lzLWNpcmNsZS1vdXRsaW5lJzogZWxsaXBzaXNDaXJjbGVPdXRsaW5lLFxuICBlbnZlbG9wZSxcbiAgZXllLFxuICBmYWNlYm9vayxcbiAgJ2ZhY2UtaGFwcHknOiBmYWNlSGFwcHksXG4gICdmYWNlLXNhZCc6IGZhY2VTYWQsXG4gICdmYWNlLXNtaWxleSc6IGZhY2VTbWlsZXksXG4gICdmaWxsLW9wYXF1ZSc6IGZpbGxPcGFxdWUsXG4gICdmaWxsLXRyYW5zcGFyZW50JzogZmlsbFRyYW5zcGFyZW50LFxuICBmaWx0ZXIsXG4gIGZsYWcsXG4gIGZsYXNobGlnaHQsXG4gIGZsaXBIb3Jpem9udGFsLFxuICBmbGlwVmVydGljYWwsXG4gIGdpZixcbiAgZ2xvYmUsXG4gICdnbG9iZS1jaGVja2VkJzogZ2xvYmVDaGVja2VkLFxuICBnbWFpbCxcbiAgJ2dvb2dsZS1wbHVzJzogZ29vZ2xlUGx1cyxcbiAgJ2dyYXBoLWJhcic6IGdyYXBoQmFyLFxuICBoYW5kbGUsXG4gICdoYW5kLXBvaW50aW5nJzogaGFuZFBvaW50aW5nLFxuICBoZWFydCxcbiAgJ2hlYXJ0LWJyb2tlbic6IGhlYXJ0QnJva2VuLFxuICBpbXByZXNzdW0sXG4gIGtub29wLFxuICBsaWdodGJ1bGIsXG4gIGxpbmssXG4gIGxvY2F0aW9uLFxuICBsb2NrLFxuICAnbG9nby1sYXJnZSc6IGxvZ29MYXJnZSxcbiAgJ2xvZ28tc21hbGwnOiBsb2dvU21hbGwsXG4gIGxvZ291dCxcbiAgJ21hcmdpbnMtbGFyZ2UnOiBtYXJnaW5zTGFyZ2UsXG4gICdtYXJnaW5zLW1lZGl1bSc6IG1hcmdpbnNNZWRpdW0sXG4gICdtYXJnaW5zLXNtYWxsJzogbWFyZ2luc1NtYWxsLFxuICBtYXhpbWl6ZSxcbiAgbWVnYXBob25lLFxuICBtZW51LFxuICBtaW5pbWl6ZSxcbiAgbW92ZSxcbiAgbXV0ZSxcbiAgJ292ZXJsYXktdGV4dCc6IG92ZXJsYXlUZXh0LFxuICBwYXVzZSxcbiAgcGVvcGxlLFxuICBwZXJzb24sXG4gICdwZXJzb24tYWRkJzogcGVyc29uQWRkLFxuICBwaW4sXG4gICdwaW4taGlkZSc6IHBpbkhpZGUsXG4gIHBpbnRlcmVzdCxcbiAgcGxheSxcbiAgJ3F1ZXN0aW9uLW1hcmsnOiBxdWVzdGlvbk1hcmssXG4gIHJlbW92ZSxcbiAgJ3Jlb3JkZXItaW1hZ2VzJzogcmVvcmRlckltYWdlcyxcbiAgcmVwb3J0LFxuICByb3RhdGUsXG4gIHNlYXJjaCxcbiAgc2VjdXJpdHksXG4gICdzaG9wcGluZy1iYWcnOiBzaG9wcGluZ0JhZyxcbiAgc21pbGV5LFxuICAnc21pbGV5LW91dGxpbmUnOiBzbWlsZXlPdXRsaW5lLFxuICBzZW5kLFxuICBzaGFyZSxcbiAgc291bmQsXG4gIHNwZWVjaCxcbiAgJ3NwZWVjaC1lbGxpcHNpcyc6IHNwZWVjaEVsbGlwc2lzLFxuICBzdGFyLFxuICAnc3dpdGNoLWFjY291bnQnOiBzd2l0Y2hBY2NvdW50LFxuICB0YWcsXG4gIHRlcm1zLFxuICAndGV4dC1hbGlnbi1sZWZ0JzogdGV4dEFsaWduTGVmdCxcbiAgJ3RleHQtYWxpZ24tY2VudGVyJzogdGV4dEFsaWduQ2VudGVyLFxuICAndGV4dC1hbGlnbi1yaWdodCc6IHRleHRBbGlnblJpZ2h0LFxuICAndGV4dC1hbGwtY2Fwcyc6IHRleHRBbGxDYXBzLFxuICAndGV4dC1leHRyYS1zbWFsbCc6IHRleHRFeHRyYVNtYWxsLFxuICAndGV4dC1sYXJnZSc6IHRleHRMYXJnZSxcbiAgJ3RleHQtbGluZS1oZWlnaHQnOiB0ZXh0TGluZUhlaWdodCxcbiAgJ3RleHQtbWVkaXVtJzogdGV4dE1lZGl1bSxcbiAgJ3RleHQtc2VudGVuY2UtY2FzZSc6IHRleHRTZW50ZW5jZUNhc2UsXG4gICd0ZXh0LXNpemUnOiB0ZXh0U2l6ZSxcbiAgJ3RleHQtc21hbGwnOiB0ZXh0U21hbGwsXG4gICd0ZXh0LXNwYWNpbmcnOiB0ZXh0U3BhY2luZyxcbiAgJ3RyYXNoLWNhbic6IHRyYXNoQ2FuLFxuICB0d2l0dGVyLFxuICAndmlkZW8tY2FtZXJhJzogdmlkZW9DYW1lcmEsXG4gICd2aWV3LXR5cGUtZGVmYXVsdCc6IHZpZXdUeXBlRGVmYXVsdCxcbiAgJ3ZpZXctdHlwZS1kZW5zZSc6IHZpZXdUeXBlRGVuc2UsXG4gICd2aWV3LXR5cGUtbGlzdCc6IHZpZXdUeXBlTGlzdCxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0ljb24uY3NzJztcbmltcG9ydCBpY29ucyBmcm9tICcuL2ljb25zL2luZGV4LmpzJztcbmltcG9ydCBjb2xvcnMgZnJvbSAnLi9Db2xvcnMuY3NzJztcblxudHlwZSBJY29uUHJvcHMgPSB7XG4gIGFjY2Vzc2liaWxpdHlMYWJlbDogc3RyaW5nLFxuICBjb2xvcj86XG4gICAgfCAnYmx1ZSdcbiAgICB8ICdkYXJrR3JheSdcbiAgICB8ICdlZ2dwbGFudCdcbiAgICB8ICdncmF5J1xuICAgIHwgJ2dyZWVuJ1xuICAgIHwgJ2xpZ2h0R3JheSdcbiAgICB8ICdtYXJvb24nXG4gICAgfCAnbWlkbmlnaHQnXG4gICAgfCAnbmF2eSdcbiAgICB8ICdvbGl2ZSdcbiAgICB8ICdvcmFuZ2UnXG4gICAgfCAnb3JjaGlkJ1xuICAgIHwgJ3BpbmUnXG4gICAgfCAncHVycGxlJ1xuICAgIHwgJ3JlZCdcbiAgICB8ICd3YXRlcm1lbG9uJ1xuICAgIHwgJ3doaXRlJyxcbiAgaW5saW5lPzogYm9vbGVhbixcbiAgc2l6ZT86IG51bWJlciB8IHN0cmluZyxcbn07XG5cbnR5cGUgSWNvbk5vUGF0aCA9IHtcbiAgaWNvbjogJEtleXM8dHlwZW9mIGljb25zPixcbiAgZGFuZ2Vyb3VzbHlTZXRTdmdQYXRoPzogbnVsbCxcbn07XG5cbnR5cGUgUGF0aE5vSWNvbiA9IHtcbiAgaWNvbj86IG51bGwsXG4gIGRhbmdlcm91c2x5U2V0U3ZnUGF0aDogeyBfX3BhdGg6IHN0cmluZyB9LFxufTtcblxudHlwZSBQcm9wcyA9IEljb25Qcm9wcyAmIChQYXRoTm9JY29uIHwgSWNvbk5vUGF0aCk7XG5cbmNvbnN0IEljb25OYW1lcyA9IE9iamVjdC5rZXlzKGljb25zKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSWNvbihwcm9wczogUHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGFjY2Vzc2liaWxpdHlMYWJlbCxcbiAgICBjb2xvciA9ICdncmF5JyxcbiAgICBkYW5nZXJvdXNseVNldFN2Z1BhdGgsXG4gICAgaWNvbixcbiAgICBpbmxpbmUsXG4gICAgc2l6ZSA9IDE2LFxuICB9ID0gcHJvcHM7XG5cbiAgY29uc3QgY3MgPSBjbGFzc25hbWVzKHN0eWxlcy5pY29uLCBjb2xvcnNbY29sb3JdLCB7XG4gICAgW3N0eWxlcy5pY29uQmxvY2tdOiAhaW5saW5lLFxuICB9KTtcblxuICBjb25zdCBwYXRoID1cbiAgICAoaWNvbiAmJiBpY29uc1tpY29uXSkgfHxcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cbiAgICAoZGFuZ2Vyb3VzbHlTZXRTdmdQYXRoICYmIGRhbmdlcm91c2x5U2V0U3ZnUGF0aC5fX3BhdGgpIHx8XG4gICAgdW5kZWZpbmVkO1xuXG4gIGNvbnN0IGFyaWFIaWRkZW4gPSBhY2Nlc3NpYmlsaXR5TGFiZWwgPT09ICcnID8gdHJ1ZSA6IG51bGw7XG5cbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICBjbGFzc05hbWU9e2NzfVxuICAgICAgaGVpZ2h0PXtzaXplfVxuICAgICAgd2lkdGg9e3NpemV9XG4gICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgIGFyaWEtaGlkZGVuPXthcmlhSGlkZGVufVxuICAgICAgYXJpYS1sYWJlbD17YWNjZXNzaWJpbGl0eUxhYmVsfVxuICAgICAgcm9sZT1cImltZ1wiXG4gICAgPlxuICAgICAgPHBhdGggZD17cGF0aH0gLz5cbiAgICA8L3N2Zz5cbiAgKTtcbn1cblxuSWNvbi5pY29ucyA9IEljb25OYW1lcztcblxuSWNvbi5wcm9wVHlwZXMgPSB7XG4gIGFjY2Vzc2liaWxpdHlMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnYmx1ZScsXG4gICAgJ2RhcmtHcmF5JyxcbiAgICAnZWdncGxhbnQnLFxuICAgICdncmF5JyxcbiAgICAnZ3JlZW4nLFxuICAgICdsaWdodEdyYXknLFxuICAgICdtYXJvb24nLFxuICAgICdtaWRuaWdodCcsXG4gICAgJ25hdnknLFxuICAgICdvbGl2ZScsXG4gICAgJ29yYW5nZScsXG4gICAgJ29yY2hpZCcsXG4gICAgJ3BpbmUnLFxuICAgICdwdXJwbGUnLFxuICAgICdyZWQnLFxuICAgICd3YXRlcm1lbG9uJyxcbiAgICAnd2hpdGUnLFxuICBdKSxcbiAgZGFuZ2Vyb3VzbHlTZXRTdmdQYXRoOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIF9fcGF0aDogUHJvcFR5cGVzLnN0cmluZyxcbiAgfSksXG4gIGljb246IFByb3BUeXBlcy5vbmVPZihJY29uTmFtZXMpLFxuICBpbmxpbmU6IFByb3BUeXBlcy5ib29sLFxuICBzaXplOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9JbWFnZS5jc3MnO1xuXG5jb25zdCBzaG91bGRTY2FsZUltYWdlID0gZml0ID0+IGZpdCA9PT0gJ2NvdmVyJyB8fCBmaXQgPT09ICdjb250YWluJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFsdDogc3RyaW5nLFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGNvbG9yOiBzdHJpbmcsXG4gIGZpdDogJ2NvbnRhaW4nIHwgJ2NvdmVyJyB8ICdub25lJyxcbiAgbmF0dXJhbEhlaWdodDogbnVtYmVyLFxuICBuYXR1cmFsV2lkdGg6IG51bWJlcixcbiAgb25FcnJvcj86ICgpID0+IHZvaWQsXG4gIG9uTG9hZD86ICgpID0+IHZvaWQsXG4gIHNpemVzPzogc3RyaW5nLFxuICBzcmM6IHN0cmluZyxcbiAgc3JjU2V0Pzogc3RyaW5nLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEltYWdlIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxQcm9wcz4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGFsdDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICBjb2xvcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBmaXQ6IFByb3BUeXBlcy5vbmVPZihbJ2NvbnRhaW4nLCAnY292ZXInLCAnbm9uZSddKSxcbiAgICBuYXR1cmFsSGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgbmF0dXJhbFdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgb25FcnJvcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Mb2FkOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBzaXplczogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBzcmM6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBzcmNTZXQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICBmaXQ6ICdub25lJyxcbiAgfTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAoc2hvdWxkU2NhbGVJbWFnZSh0aGlzLnByb3BzLmZpdCkpIHtcbiAgICAgIHRoaXMubG9hZEltYWdlKCk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogUHJvcHMpIHtcbiAgICBjb25zdCB7IGZpdCwgc3JjIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChzaG91bGRTY2FsZUltYWdlKGZpdCkgJiYgcHJldlByb3BzLnNyYyAhPT0gc3JjKSB7XG4gICAgICB0aGlzLmxvYWRJbWFnZSgpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICB0aGlzLnByb3BzLm9uTG9hZCgpO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVFcnJvciA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5wcm9wcy5vbkVycm9yKSB7XG4gICAgICB0aGlzLnByb3BzLm9uRXJyb3IoKTtcbiAgICB9XG4gIH07XG5cbiAgbG9hZEltYWdlKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgd2luZG93LkltYWdlKCk7XG4gICAgICBpbWFnZS5vbmxvYWQgPSB0aGlzLmhhbmRsZUxvYWQ7XG4gICAgICBpbWFnZS5vbmVycm9yID0gdGhpcy5oYW5kbGVFcnJvcjtcbiAgICAgIGltYWdlLnNyYyA9IHRoaXMucHJvcHMuc3JjO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbHQsXG4gICAgICBjb2xvcixcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZml0LFxuICAgICAgbmF0dXJhbEhlaWdodCxcbiAgICAgIG5hdHVyYWxXaWR0aCxcbiAgICAgIHNpemVzLFxuICAgICAgc3JjLFxuICAgICAgc3JjU2V0LFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgaXNTY2FsZWRJbWFnZSA9IHNob3VsZFNjYWxlSW1hZ2UoZml0KTtcbiAgICBjb25zdCBjaGlsZENvbnRlbnQgPSBjaGlsZHJlbiA/IChcbiAgICAgIDxCb3ggcG9zaXRpb249XCJhYnNvbHV0ZVwiIHRvcCBsZWZ0IGJvdHRvbSByaWdodCBvdmVyZmxvdz1cImhpZGRlblwiPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L0JveD5cbiAgICApIDogbnVsbDtcblxuICAgIHJldHVybiBpc1NjYWxlZEltYWdlID8gKFxuICAgICAgPGRpdlxuICAgICAgICBhcmlhLWxhYmVsPXthbHR9XG4gICAgICAgIGNsYXNzTmFtZT17c3R5bGVzW2ZpdF19XG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcixcbiAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJyR7c3JjfScpYCxcbiAgICAgICAgfX1cbiAgICAgICAgcm9sZT1cImltZ1wiXG4gICAgICA+XG4gICAgICAgIHtjaGlsZENvbnRlbnR9XG4gICAgICA8L2Rpdj5cbiAgICApIDogKFxuICAgICAgPEJveFxuICAgICAgICBwb3NpdGlvbj1cInJlbGF0aXZlXCJcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17e1xuICAgICAgICAgIF9fc3R5bGU6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tOiBgJHsobmF0dXJhbEhlaWdodCAvIG5hdHVyYWxXaWR0aCkgKiAxMDB9JWAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgPGltZ1xuICAgICAgICAgIGFsdD17YWx0fVxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmltZ31cbiAgICAgICAgICBvbkVycm9yPXt0aGlzLmhhbmRsZUVycm9yfVxuICAgICAgICAgIG9uTG9hZD17dGhpcy5oYW5kbGVMb2FkfVxuICAgICAgICAgIHNpemVzPXtzaXplc31cbiAgICAgICAgICBzcmM9e3NyY31cbiAgICAgICAgICBzcmNTZXQ9e3NyY1NldH1cbiAgICAgICAgLz5cbiAgICAgICAge2NoaWxkQ29udGVudH1cbiAgICAgIDwvQm94PlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL01hc2suY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgaGVpZ2h0PzogbnVtYmVyIHwgc3RyaW5nLFxuICBzaGFwZT86ICdjaXJjbGUnIHwgJ3JvdW5kZWQnIHwgJ3NxdWFyZScsXG4gIHdpZHRoPzogbnVtYmVyIHwgc3RyaW5nLFxuICB3aWxsQ2hhbmdlVHJhbnNmb3JtPzogYm9vbGVhbixcbiAgd2FzaD86IGJvb2xlYW4sXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWFzayhwcm9wczogUHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIHNoYXBlID0gJ3NxdWFyZScsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHdpbGxDaGFuZ2VUcmFuc2Zvcm0gPSB0cnVlLFxuICAgIHdhc2ggPSBmYWxzZSxcbiAgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17Y3goc3R5bGVzLk1hc2ssIHN0eWxlc1tzaGFwZV0sIHtcbiAgICAgICAgW3N0eWxlcy53aWxsQ2hhbmdlVHJhbnNmb3JtXTogd2lsbENoYW5nZVRyYW5zZm9ybSxcbiAgICAgIH0pfVxuICAgICAgc3R5bGU9e3sgd2lkdGgsIGhlaWdodCB9fVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICAgIHt3YXNoICYmIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMud2FzaH0gLz59XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbk1hc2sucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGhlaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBzaGFwZTogUHJvcFR5cGVzLm9uZU9mKFsnY2lyY2xlJywgJ3JvdW5kZWQnLCAnc3F1YXJlJ10pLFxuICB3aWR0aDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICB3aWxsQ2hhbmdlVHJhbnNmb3JtOiBQcm9wVHlwZXMuYm9vbCxcbiAgd2FzaDogUHJvcFR5cGVzLmJvb2wsXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5pbXBvcnQgSW1hZ2UgZnJvbSAnLi9JbWFnZS5qcyc7XG5pbXBvcnQgTWFzayBmcm9tICcuL01hc2suanMnO1xuaW1wb3J0IHR5cG9ncmFwaHkgZnJvbSAnLi9UeXBvZ3JhcGh5LmNzcyc7XG5cbmNvbnN0IFNxdWFyZSA9IChwcm9wczogKikgPT4gKFxuICA8Qm94IHsuLi5wcm9wc30gcG9zaXRpb249XCJyZWxhdGl2ZVwiPlxuICAgIDxCb3hcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyBwYWRkaW5nQm90dG9tOiAnMTAwJScgfSB9fVxuICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgLz5cbiAgICA8Qm94IHBvc2l0aW9uPVwiYWJzb2x1dGVcIiB0b3AgbGVmdCBib3R0b20gcmlnaHQ+XG4gICAgICB7cHJvcHMuY2hpbGRyZW59XG4gICAgPC9Cb3g+XG4gIDwvQm94PlxuKTtcblxuY29uc3QgRGVmYXVsdEF2YXRhciA9ICh7IG5hbWUgfTogeyBuYW1lOiBzdHJpbmcgfSkgPT4ge1xuICBjb25zdCBmaXJzdEluaXRpYWwgPSBuYW1lID8gWy4uLm5hbWVdWzBdLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgcmV0dXJuIChcbiAgICA8U3F1YXJlIGNvbG9yPVwiZ3JheVwiIHNoYXBlPVwiY2lyY2xlXCI+XG4gICAgICB7Zmlyc3RJbml0aWFsICYmIChcbiAgICAgICAgPHN2Z1xuICAgICAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgICAgICAgdmlld0JveD1cIi01MCAtNTAgMTAwIDEwMFwiXG4gICAgICAgICAgdmVyc2lvbj1cIjEuMVwiXG4gICAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIlxuICAgICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICA+XG4gICAgICAgICAgPHRpdGxlPntuYW1lfTwvdGl0bGU+XG4gICAgICAgICAgPHRleHRcbiAgICAgICAgICAgIGZvbnRTaXplPVwiNTBweFwiXG4gICAgICAgICAgICBmaWxsPVwiI2ZmZlwiXG4gICAgICAgICAgICBkeT1cIjAuMzVlbVwiXG4gICAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17W1xuICAgICAgICAgICAgICB0eXBvZ3JhcGh5LmFudGlhbGlhc2VkLFxuICAgICAgICAgICAgICB0eXBvZ3JhcGh5LnNhbnNTZXJpZixcbiAgICAgICAgICAgICAgdHlwb2dyYXBoeS5sZWFkaW5nU21hbGwsXG4gICAgICAgICAgICAgIHR5cG9ncmFwaHkuZm9udFdlaWdodEJvbGQsXG4gICAgICAgICAgICBdLmpvaW4oJyAnKX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7Zmlyc3RJbml0aWFsfVxuICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgPC9zdmc+XG4gICAgICApfVxuICAgIDwvU3F1YXJlPlxuICApO1xufTtcblxudHlwZSBTdGF0ZSA9IHt8IGlzSW1hZ2VMb2FkZWQ6IGJvb2xlYW4gfH07XG5cbnR5cGUgQXZhdGFyUHJvcHMgPSB7fFxuICBuYW1lOiBzdHJpbmcsXG4gIG91dGxpbmU/OiBib29sZWFuLFxuICBzaXplPzogJ3NtJyB8ICdtZCcgfCAnbGcnLFxuICBzcmM/OiBzdHJpbmcsXG4gIHZlcmlmaWVkPzogYm9vbGVhbixcbiAgaWNvbj86ICdjaGVjay1jaXJjbGUnIHwgJ3BpbnRlcmVzdCcsXG58fTtcblxuY29uc3Qgc2l6ZXMgPSB7XG4gIHNtOiAyNCxcbiAgbWQ6IDQwLFxuICBsZzogNzIsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdmF0YXIgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PEF2YXRhclByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBvdXRsaW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBzcmM6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnc20nLCAnbWQnLCAnbGcnXSksXG4gICAgdmVyaWZpZWQ6IFByb3BUeXBlcy5ib29sLFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIGlzSW1hZ2VMb2FkZWQ6IHRydWUsXG4gIH07XG5cbiAgaGFuZGxlSW1hZ2VFcnJvciA9ICgpID0+IHRoaXMuc2V0U3RhdGUoeyBpc0ltYWdlTG9hZGVkOiBmYWxzZSB9KTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIG91dGxpbmUsXG4gICAgICBzaXplLFxuICAgICAgc3JjLFxuICAgICAgdmVyaWZpZWQsXG4gICAgICBpY29uID0gJ2NoZWNrLWNpcmNsZScsXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBpc0ltYWdlTG9hZGVkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHdpZHRoID0gc2l6ZSA/IHNpemVzW3NpemVdIDogJzEwMCUnO1xuICAgIGNvbnN0IGhlaWdodCA9IHNpemUgPyBzaXplc1tzaXplXSA6ICcnO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3hcbiAgICAgICAgY29sb3I9XCJ3aGl0ZVwiXG4gICAgICAgIHsuLi4ob3V0bGluZVxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgX19zdHlsZToge1xuICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiAnMCAwIDAgMnB4ICNmZmYnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7fSl9XG4gICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgIHBvc2l0aW9uPVwicmVsYXRpdmVcIlxuICAgICAgICBzaGFwZT1cImNpcmNsZVwiXG4gICAgICA+XG4gICAgICAgIHtzcmMgJiYgaXNJbWFnZUxvYWRlZCA/IChcbiAgICAgICAgICA8TWFzayBzaGFwZT1cImNpcmNsZVwiIHdhc2g+XG4gICAgICAgICAgICA8SW1hZ2VcbiAgICAgICAgICAgICAgYWx0PXtuYW1lfVxuICAgICAgICAgICAgICBjb2xvcj1cIiNFRkVGRUZcIlxuICAgICAgICAgICAgICBuYXR1cmFsSGVpZ2h0PXsxfVxuICAgICAgICAgICAgICBuYXR1cmFsV2lkdGg9ezF9XG4gICAgICAgICAgICAgIHNyYz17c3JjfVxuICAgICAgICAgICAgICBvbkVycm9yPXt0aGlzLmhhbmRsZUltYWdlRXJyb3J9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvTWFzaz5cbiAgICAgICAgKSA6IChcbiAgICAgICAgICA8RGVmYXVsdEF2YXRhciBuYW1lPXtuYW1lfSAvPlxuICAgICAgICApfVxuICAgICAgICB7dmVyaWZpZWQgJiYgKFxuICAgICAgICAgIDxCb3hcbiAgICAgICAgICAgIHBvc2l0aW9uPVwiYWJzb2x1dGVcIlxuICAgICAgICAgICAgd2lkdGg9XCIyMCVcIlxuICAgICAgICAgICAgaGVpZ2h0PVwiMjAlXCJcbiAgICAgICAgICAgIG1pbldpZHRoPXs4fVxuICAgICAgICAgICAgbWluSGVpZ2h0PXs4fVxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17e1xuICAgICAgICAgICAgICBfX3N0eWxlOiB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAnNCUnLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAnNCUnLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8Qm94XG4gICAgICAgICAgICAgIGNvbG9yPVwid2hpdGVcIlxuICAgICAgICAgICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgICAgICAgICBoZWlnaHQ9XCIxMDAlXCJcbiAgICAgICAgICAgICAgc2hhcGU9XCJjaXJjbGVcIlxuICAgICAgICAgICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7XG4gICAgICAgICAgICAgICAgX19zdHlsZToge1xuICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiAnMCAwIDAgMnB4ICNmZmYnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxJY29uIGNvbG9yPVwicmVkXCIgaWNvbj17aWNvbn0gYWNjZXNzaWJpbGl0eUxhYmVsPVwiXCIgc2l6ZT1cIjEwMCVcIiAvPlxuICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgPC9Cb3g+XG4gICAgICAgICl9XG4gICAgICA8L0JveD5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9CYWRnZS5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgcG9zaXRpb24/OiAnbWlkZGxlJyB8ICd0b3AnLFxuICB0ZXh0OiBzdHJpbmcsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQmFkZ2UocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHsgcG9zaXRpb24gPSAnbWlkZGxlJywgdGV4dCB9ID0gcHJvcHM7XG4gIGNvbnN0IGNzID0gY3goc3R5bGVzLkJhZGdlLCBzdHlsZXNbcG9zaXRpb25dKTtcblxuICByZXR1cm4gPHNwYW4gY2xhc3NOYW1lPXtjc30+e3RleHR9PC9zcGFuPjtcbn1cblxuQmFkZ2UucHJvcFR5cGVzID0ge1xuICBwb3NpdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsnbWlkZGxlJywgJ3RvcCddKSxcbiAgdGV4dDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxufTtcbiIsIi8vIEBmbG93XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgY29sb3JzIGZyb20gJy4vQ29sb3JzLmNzcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vVGV4dC5jc3MnO1xuaW1wb3J0IHR5cG9ncmFwaHkgZnJvbSAnLi9UeXBvZ3JhcGh5LmNzcyc7XG5cbmNvbnN0IFNJWkVfU0NBTEU6IHsgW3NpemU6ID9zdHJpbmddOiBudW1iZXIgfSA9IHtcbiAgeHM6IDEsXG4gIHNtOiAyLFxuICBtZDogMyxcbiAgbGc6IDQsXG4gIHhsOiA1LFxufTtcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFsaWduPzogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInIHwgJ2p1c3RpZnknLFxuICBib2xkPzogYm9vbGVhbixcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICBjb2xvcj86XG4gICAgfCAnZ3JlZW4nXG4gICAgfCAncGluZSdcbiAgICB8ICdvbGl2ZSdcbiAgICB8ICdibHVlJ1xuICAgIHwgJ25hdnknXG4gICAgfCAnbWlkbmlnaHQnXG4gICAgfCAncHVycGxlJ1xuICAgIHwgJ29yY2hpZCdcbiAgICB8ICdlZ2dwbGFudCdcbiAgICB8ICdtYXJvb24nXG4gICAgfCAnd2F0ZXJtZWxvbidcbiAgICB8ICdvcmFuZ2UnXG4gICAgfCAnZGFya0dyYXknXG4gICAgfCAnZ3JheSdcbiAgICB8ICdsaWdodEdyYXknXG4gICAgfCAncmVkJ1xuICAgIHwgJ3doaXRlJyxcbiAgaW5saW5lPzogYm9vbGVhbixcbiAgaXRhbGljPzogYm9vbGVhbixcbiAgb3ZlcmZsb3c/OiAnbm9ybWFsJyB8ICdicmVha1dvcmQnLFxuICBzaXplPzogJ3hzJyB8ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCcsXG4gIHNtU2l6ZT86ICd4cycgfCAnc20nIHwgJ21kJyB8ICdsZycgfCAneGwnLFxuICBtZFNpemU/OiAneHMnIHwgJ3NtJyB8ICdtZCcgfCAnbGcnIHwgJ3hsJyxcbiAgbGdTaXplPzogJ3hzJyB8ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCcsXG4gIGxlYWRpbmc/OiAndGFsbCcgfCAnc2hvcnQnLFxuICB0cnVuY2F0ZT86IGJvb2xlYW4sXG4gIF9fZGFuZ2Vyb3VzbHlJbmNyZWFzZUxpbmVIZWlnaHQ/OiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRleHQoe1xuICBhbGlnbiA9ICdsZWZ0JyxcbiAgYm9sZCA9IGZhbHNlLFxuICBjaGlsZHJlbixcbiAgY29sb3IgPSAnZGFya0dyYXknLFxuICBpbmxpbmUgPSBmYWxzZSxcbiAgaXRhbGljID0gZmFsc2UsXG4gIG92ZXJmbG93ID0gJ2JyZWFrV29yZCcsXG4gIHNpemUgPSAnbWQnLFxuICBzbVNpemUsXG4gIG1kU2l6ZSxcbiAgbGdTaXplLFxuICBsZWFkaW5nLFxuICB0cnVuY2F0ZSA9IGZhbHNlLFxuICBfX2Rhbmdlcm91c2x5SW5jcmVhc2VMaW5lSGVpZ2h0ID0gZmFsc2UsXG59OiBQcm9wcykge1xuICBjb25zdCBzY2FsZSA9IFNJWkVfU0NBTEVbc2l6ZV07XG4gIGNvbnN0IHNtU2NhbGUgPSBTSVpFX1NDQUxFW3NtU2l6ZV07XG4gIGNvbnN0IG1kU2NhbGUgPSBTSVpFX1NDQUxFW21kU2l6ZV07XG4gIGNvbnN0IGxnU2NhbGUgPSBTSVpFX1NDQUxFW2xnU2l6ZV07XG5cbiAgY29uc3QgY3MgPSBjeChcbiAgICBzdHlsZXMuVGV4dCxcbiAgICBzdHlsZXNbYGZvbnRTaXplJHtzY2FsZX1gXSxcbiAgICBsZ1NpemUgJiYgc3R5bGVzW2BsZ0ZvbnRTaXplJHtsZ1NjYWxlfWBdLFxuICAgIG1kU2l6ZSAmJiBzdHlsZXNbYG1kRm9udFNpemUke21kU2NhbGV9YF0sXG4gICAgc21TaXplICYmIHN0eWxlc1tgc21Gb250U2l6ZSR7c21TY2FsZX1gXSxcbiAgICBjb2xvciA9PT0gJ2JsdWUnICYmIGNvbG9ycy5ibHVlLFxuICAgIGNvbG9yID09PSAnZGFya0dyYXknICYmIGNvbG9ycy5kYXJrR3JheSxcbiAgICBjb2xvciA9PT0gJ2VnZ3BsYW50JyAmJiBjb2xvcnMuZWdncGxhbnQsXG4gICAgY29sb3IgPT09ICdncmF5JyAmJiBjb2xvcnMuZ3JheSxcbiAgICBjb2xvciA9PT0gJ2dyZWVuJyAmJiBjb2xvcnMuZ3JlZW4sXG4gICAgY29sb3IgPT09ICdsaWdodEdyYXknICYmIGNvbG9ycy5saWdodEdyYXksXG4gICAgY29sb3IgPT09ICdtYXJvb24nICYmIGNvbG9ycy5tYXJvb24sXG4gICAgY29sb3IgPT09ICdtaWRuaWdodCcgJiYgY29sb3JzLm1pZG5pZ2h0LFxuICAgIGNvbG9yID09PSAnbmF2eScgJiYgY29sb3JzLm5hdnksXG4gICAgY29sb3IgPT09ICdvbGl2ZScgJiYgY29sb3JzLm9saXZlLFxuICAgIGNvbG9yID09PSAnb3JhbmdlJyAmJiBjb2xvcnMub3JhbmdlLFxuICAgIGNvbG9yID09PSAnb3JjaGlkJyAmJiBjb2xvcnMub3JjaGlkLFxuICAgIGNvbG9yID09PSAncGluZScgJiYgY29sb3JzLnBpbmUsXG4gICAgY29sb3IgPT09ICdwdXJwbGUnICYmIGNvbG9ycy5wdXJwbGUsXG4gICAgY29sb3IgPT09ICdyZWQnICYmIGNvbG9ycy5yZWQsXG4gICAgY29sb3IgPT09ICd3YXRlcm1lbG9uJyAmJiBjb2xvcnMud2F0ZXJtZWxvbixcbiAgICBjb2xvciA9PT0gJ3doaXRlJyAmJiBjb2xvcnMud2hpdGUsXG4gICAgbGVhZGluZyA9PT0gJ3Nob3J0JyAmJiB0eXBvZ3JhcGh5LmxlYWRpbmdTaG9ydCxcbiAgICAobGVhZGluZyA9PT0gJ3RhbGwnIHx8IF9fZGFuZ2Vyb3VzbHlJbmNyZWFzZUxpbmVIZWlnaHQpICYmXG4gICAgICB0eXBvZ3JhcGh5LmxlYWRpbmdUYWxsLFxuICAgIGFsaWduID09PSAnY2VudGVyJyAmJiB0eXBvZ3JhcGh5LmFsaWduQ2VudGVyLFxuICAgIGFsaWduID09PSAnanVzdGlmeScgJiYgdHlwb2dyYXBoeS5hbGlnbkp1c3RpZnksXG4gICAgYWxpZ24gPT09ICdsZWZ0JyAmJiB0eXBvZ3JhcGh5LmFsaWduTGVmdCxcbiAgICBhbGlnbiA9PT0gJ3JpZ2h0JyAmJiB0eXBvZ3JhcGh5LmFsaWduUmlnaHQsXG4gICAgb3ZlcmZsb3cgPT09ICdicmVha1dvcmQnICYmIHR5cG9ncmFwaHkuYnJlYWtXb3JkLFxuICAgIGl0YWxpYyAmJiB0eXBvZ3JhcGh5LmZvbnRTdHlsZUl0YWxpYyxcbiAgICAhaXRhbGljICYmIHR5cG9ncmFwaHkuZm9udFN0eWxlTm9ybWFsLFxuICAgIGJvbGQgJiYgdHlwb2dyYXBoeS5mb250V2VpZ2h0Qm9sZCxcbiAgICAhYm9sZCAmJiB0eXBvZ3JhcGh5LmZvbnRXZWlnaHROb3JtYWwsXG4gICAgdHJ1bmNhdGUgJiYgdHlwb2dyYXBoeS50cnVuY2F0ZVxuICApO1xuICBjb25zdCBUYWcgPSBpbmxpbmUgPyAnc3BhbicgOiAnZGl2JztcblxuICByZXR1cm4gKFxuICAgIDxUYWdcbiAgICAgIGNsYXNzTmFtZT17Y3N9XG4gICAgICB7Li4uKHRydW5jYXRlICYmIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZydcbiAgICAgICAgPyB7IHRpdGxlOiBjaGlsZHJlbiB9XG4gICAgICAgIDogbnVsbCl9XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvVGFnPlxuICApO1xufVxuXG5UZXh0LnByb3BUeXBlcyA9IHtcbiAgX19kYW5nZXJvdXNseUluY3JlYXNlTGluZUhlaWdodDogUHJvcFR5cGVzLmJvb2wsXG4gIGFsaWduOiBQcm9wVHlwZXMub25lT2YoWydsZWZ0JywgJ3JpZ2h0JywgJ2NlbnRlcicsICdqdXN0aWZ5J10pLFxuICBib2xkOiBQcm9wVHlwZXMuYm9vbCxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnZ3JlZW4nLFxuICAgICdwaW5lJyxcbiAgICAnb2xpdmUnLFxuICAgICdibHVlJyxcbiAgICAnbmF2eScsXG4gICAgJ21pZG5pZ2h0JyxcbiAgICAncHVycGxlJyxcbiAgICAnb3JjaGlkJyxcbiAgICAnZWdncGxhbnQnLFxuICAgICdtYXJvb24nLFxuICAgICd3YXRlcm1lbG9uJyxcbiAgICAnb3JhbmdlJyxcbiAgICAnZGFya0dyYXknLFxuICAgICdncmF5JyxcbiAgICAnbGlnaHRHcmF5JyxcbiAgICAncmVkJyxcbiAgICAnd2hpdGUnLFxuICBdKSxcbiAgaW5saW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgaXRhbGljOiBQcm9wVHlwZXMuYm9vbCxcbiAgbGVhZGluZzogUHJvcFR5cGVzLm9uZU9mKFsndGFsbCcsICdzaG9ydCddKSxcbiAgbGdTaXplOiBQcm9wVHlwZXMub25lT2YoWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddKSxcbiAgbWRTaXplOiBQcm9wVHlwZXMub25lT2YoWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddKSxcbiAgb3ZlcmZsb3c6IFByb3BUeXBlcy5vbmVPZihbJ25vcm1hbCcsICdicmVha1dvcmQnXSksXG4gIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10pLFxuICBzbVNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10pLFxuICB0cnVuY2F0ZTogUHJvcFR5cGVzLmJvb2wsXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBib3JkZXJTdHlsZXMgZnJvbSAnLi9Cb3JkZXJzLmNzcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vQnV0dG9uLmNzcyc7XG5pbXBvcnQgVGV4dCBmcm9tICcuL1RleHQuanMnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgYWNjZXNzaWJpbGl0eUV4cGFuZGVkPzogYm9vbGVhbixcbiAgYWNjZXNzaWJpbGl0eUhhc3BvcHVwPzogYm9vbGVhbixcbiAgYWNjZXNzaWJpbGl0eUxhYmVsPzogc3RyaW5nLFxuICBjb2xvcj86ICdncmF5JyB8ICdyZWQnIHwgJ2JsdWUnIHwgJ3RyYW5zcGFyZW50JyB8ICd3aGl0ZScsXG4gIGRpc2FibGVkPzogYm9vbGVhbixcbiAgaW5saW5lPzogYm9vbGVhbixcbiAgbmFtZT86IHN0cmluZyxcbiAgb25DbGljaz86ICh7IGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PD4gfSkgPT4gdm9pZCxcbiAgc2l6ZT86ICdzbScgfCAnbWQnIHwgJ2xnJyxcbiAgdGV4dDogc3RyaW5nLFxuICB0eXBlPzogJ3N1Ym1pdCcgfCAnYnV0dG9uJyxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCdXR0b24ocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBhY2Nlc3NpYmlsaXR5RXhwYW5kZWQsXG4gICAgYWNjZXNzaWJpbGl0eUhhc3BvcHVwLFxuICAgIGFjY2Vzc2liaWxpdHlMYWJlbCxcbiAgICBjb2xvciA9ICdncmF5JyxcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgIGlubGluZSA9IGZhbHNlLFxuICAgIG5hbWUsXG4gICAgb25DbGljayxcbiAgICBzaXplID0gJ21kJyxcbiAgICB0ZXh0LFxuICAgIHR5cGUgPSAnYnV0dG9uJyxcbiAgfSA9IHByb3BzO1xuXG4gIGNvbnN0IHRleHRDb2xvciA9IHtcbiAgICBibHVlOiAnd2hpdGUnLFxuICAgIGdyYXk6ICdkYXJrR3JheScsXG4gICAgcmVkOiAnd2hpdGUnLFxuICAgIHRyYW5zcGFyZW50OiAnd2hpdGUnLFxuICAgIHdoaXRlOiAnZGFya0dyYXknLFxuICB9O1xuXG4gIGNvbnN0IGNsYXNzZXMgPSBjbGFzc25hbWVzKHN0eWxlcy5idXR0b24sIHtcbiAgICBbc3R5bGVzLnNtXTogc2l6ZSA9PT0gJ3NtJyxcbiAgICBbc3R5bGVzLm1kXTogc2l6ZSA9PT0gJ21kJyxcbiAgICBbc3R5bGVzLmxnXTogc2l6ZSA9PT0gJ2xnJyxcbiAgICBbc3R5bGVzLnNvbGlkXTogY29sb3IgIT09ICd0cmFuc3BhcmVudCcsXG4gICAgW3N0eWxlc1tjb2xvcl1dOiAhZGlzYWJsZWQsXG4gICAgW3N0eWxlcy5kaXNhYmxlZF06IGRpc2FibGVkLFxuICAgIFtzdHlsZXMuZW5hYmxlZF06ICFkaXNhYmxlZCxcbiAgICBbc3R5bGVzLmlubGluZV06IGlubGluZSxcbiAgICBbc3R5bGVzLmJsb2NrXTogIWlubGluZSxcbiAgICBbYm9yZGVyU3R5bGVzLnJhZGl1c0xhcmdlXTogIWlubGluZSxcbiAgICBbYm9yZGVyU3R5bGVzLnJhZGl1c1NtYWxsXTogaW5saW5lLFxuICB9KTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9idXR0b24taGFzLXR5cGUgKi9cbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uXG4gICAgICBhcmlhLWV4cGFuZGVkPXthY2Nlc3NpYmlsaXR5RXhwYW5kZWR9XG4gICAgICBhcmlhLWhhc3BvcHVwPXthY2Nlc3NpYmlsaXR5SGFzcG9wdXB9XG4gICAgICBhcmlhLWxhYmVsPXthY2Nlc3NpYmlsaXR5TGFiZWx9XG4gICAgICBjbGFzc05hbWU9e2NsYXNzZXN9XG4gICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICBuYW1lPXtuYW1lfVxuICAgICAgb25DbGljaz17ZXZlbnQgPT4gb25DbGljayAmJiBvbkNsaWNrKHsgZXZlbnQgfSl9XG4gICAgICB0eXBlPXt0eXBlfVxuICAgID5cbiAgICAgIDxUZXh0XG4gICAgICAgIGFsaWduPVwiY2VudGVyXCJcbiAgICAgICAgYm9sZFxuICAgICAgICBjb2xvcj17ZGlzYWJsZWQgPyAnZ3JheScgOiB0ZXh0Q29sb3JbY29sb3JdfVxuICAgICAgICBvdmVyZmxvdz1cIm5vcm1hbFwiXG4gICAgICAgIHNpemU9e3NpemV9XG4gICAgICA+XG4gICAgICAgIHt0ZXh0fVxuICAgICAgPC9UZXh0PlxuICAgIDwvYnV0dG9uPlxuICApO1xuICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0L2J1dHRvbi1oYXMtdHlwZSAqL1xufVxuXG5CdXR0b24ucHJvcFR5cGVzID0ge1xuICBhY2Nlc3NpYmlsaXR5RXhwYW5kZWQ6IFByb3BUeXBlcy5ib29sLFxuICBhY2Nlc3NpYmlsaXR5SGFzcG9wdXA6IFByb3BUeXBlcy5ib29sLFxuICBhY2Nlc3NpYmlsaXR5TGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNvbG9yOiBQcm9wVHlwZXMub25lT2YoWydibHVlJywgJ2dyYXknLCAncmVkJywgJ3RyYW5zcGFyZW50JywgJ3doaXRlJ10pLFxuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gIGlubGluZTogUHJvcFR5cGVzLmJvb2wsXG4gIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydzbScsICdtZCcsICdsZyddKSxcbiAgdGV4dDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICB0eXBlOiBQcm9wVHlwZXMub25lT2YoWydidXR0b24nLCAnc3VibWl0J10pLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9DYXJkLmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY3RpdmU/OiA/Ym9vbGVhbixcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICBpbWFnZT86IFJlYWN0Lk5vZGUsXG4gIG9uTW91c2VFbnRlcj86ICh7IGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PiB9KSA9PiB2b2lkLFxuICBvbk1vdXNlTGVhdmU/OiAoeyBldmVudDogU3ludGhldGljTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4gfSkgPT4gdm9pZCxcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgaG92ZXJlZDogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXJkIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGFjdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgIGltYWdlOiBQcm9wVHlwZXMubm9kZSxcbiAgICBvbk1vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uTW91c2VMZWF2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIH07XG5cbiAgc3RhdGU6IFN0YXRlID0ge1xuICAgIGhvdmVyZWQ6IGZhbHNlLFxuICB9O1xuXG4gIGhhbmRsZU1vdXNlRW50ZXIgPSAoZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBvbk1vdXNlRW50ZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgIHsgaG92ZXJlZDogdHJ1ZSB9LFxuICAgICAgb25Nb3VzZUVudGVyICYmICgoKSA9PiBvbk1vdXNlRW50ZXIoeyBldmVudCB9KSlcbiAgICApO1xuICB9O1xuXG4gIGhhbmRsZU1vdXNlTGVhdmUgPSAoZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBvbk1vdXNlTGVhdmUgfSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgIHsgaG92ZXJlZDogZmFsc2UgfSxcbiAgICAgIG9uTW91c2VMZWF2ZSAmJiAoKCkgPT4gb25Nb3VzZUxlYXZlKHsgZXZlbnQgfSkpXG4gICAgKTtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBhY3RpdmUsIGNoaWxkcmVuLCBpbWFnZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGhvdmVyZWQgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCBjbGFzc2VzID0gY2xhc3NuYW1lcyhzdHlsZXMuY2FyZCwge1xuICAgICAgLy8gSWYsIGxpa2UgQGNocmlzbGxveWQsIHlvdSBjYW4ndCByZW1lbWJlciBKYXZhc2NyaXB0IGVxdWFsaXR5IHJ1bGVzLFxuICAgICAgLy8gPT0gbnVsbCBjaGVja3MgZm9yIGBudWxsYCBvciBgdW5kZWZpbmVkYCBhbmQgbGVhdmVzIG91dCBgZmFsc2VgLlxuICAgICAgW3N0eWxlcy5ob3Zlcl06IGFjdGl2ZSB8fCAoYWN0aXZlID09IG51bGwgJiYgaG92ZXJlZCksXG4gICAgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEJveFxuICAgICAgICBvbk1vdXNlRW50ZXI9e3RoaXMuaGFuZGxlTW91c2VFbnRlcn1cbiAgICAgICAgb25Nb3VzZUxlYXZlPXt0aGlzLmhhbmRsZU1vdXNlTGVhdmV9XG4gICAgICAgIHBvc2l0aW9uPVwicmVsYXRpdmVcIlxuICAgICAgPlxuICAgICAgICB7aW1hZ2UgJiYgPEJveCBtYXJnaW5Cb3R0b209ezF9PntpbWFnZX08L0JveD59XG4gICAgICAgIDxCb3g+e2NoaWxkcmVufTwvQm94PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlc30gLz5cbiAgICAgIDwvQm94PlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgY29sb3JzIGZyb20gJy4vQ29sb3JzLmNzcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vQ2hlY2tib3guY3NzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi9JY29uLmpzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoZWNrZWQ/OiBib29sZWFuLFxuICBkaXNhYmxlZD86IGJvb2xlYW4sXG4gIGhhc0Vycm9yPzogYm9vbGVhbixcbiAgaWQ6IHN0cmluZyxcbiAgaW5kZXRlcm1pbmF0ZT86IGJvb2xlYW4sXG4gIG5hbWU/OiBzdHJpbmcsXG4gIG9uQ2hhbmdlOiAoeyBldmVudDogU3ludGhldGljSW5wdXRFdmVudDw+LCBjaGVja2VkOiBib29sZWFuIH0pID0+IHZvaWQsXG4gIG9uQ2xpY2s/OiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+LFxuICAgIGNoZWNrZWQ6IGJvb2xlYW4sXG4gIH0pID0+IHZvaWQsXG4gIHNpemU/OiAnc20nIHwgJ21kJyxcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgZm9jdXNlZDogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGVja2JveCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBjaGVja2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgaGFzRXJyb3I6IFByb3BUeXBlcy5ib29sLFxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgaW5kZXRlcm1pbmF0ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydzbScsICdtZCddKSxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGNoZWNrZWQ6IGZhbHNlLFxuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBoYXNFcnJvcjogZmFsc2UsXG4gICAgaW5kZXRlcm1pbmF0ZTogZmFsc2UsXG4gICAgc2l6ZTogJ21kJyxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBmb2N1c2VkOiBmYWxzZSxcbiAgfTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5pbmRldGVybWluYXRlKSB7XG4gICAgICB0aGlzLnNldEluZGV0ZXJtaW5hdGUoISF0aGlzLnByb3BzLmluZGV0ZXJtaW5hdGUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2aW91c1Byb3BzOiBQcm9wcykge1xuICAgIGlmIChwcmV2aW91c1Byb3BzLmluZGV0ZXJtaW5hdGUgIT09IHRoaXMucHJvcHMuaW5kZXRlcm1pbmF0ZSkge1xuICAgICAgdGhpcy5zZXRJbmRldGVybWluYXRlKCEhdGhpcy5wcm9wcy5pbmRldGVybWluYXRlKTtcbiAgICB9XG4gIH1cblxuICBzZXRJbmRldGVybWluYXRlKGluZGV0ZXJtaW5hdGU6IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5pbnB1dCkge1xuICAgICAgdGhpcy5pbnB1dC5pbmRldGVybWluYXRlID0gaW5kZXRlcm1pbmF0ZTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVDaGFuZ2UgPSAoZXZlbnQ6IFN5bnRoZXRpY0lucHV0RXZlbnQ8PikgPT4ge1xuICAgIGNvbnN0IHsgY2hlY2tlZCB9ID0gZXZlbnQudGFyZ2V0O1xuICAgIHRoaXMucHJvcHMub25DaGFuZ2UoeyBldmVudCwgY2hlY2tlZCB9KTtcbiAgfTtcblxuICBoYW5kbGVDbGljayA9IChldmVudDogU3ludGhldGljSW5wdXRFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25DbGljayB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAob25DbGljaykge1xuICAgICAgY29uc3QgeyBjaGVja2VkIH0gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgb25DbGljayh7IGV2ZW50LCBjaGVja2VkIH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVCbHVyID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IGZhbHNlIH0pO1xuXG4gIGhhbmRsZUZvY3VzID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IHRydWUgfSk7XG5cbiAgaW5wdXQ6ID9IVE1MSW5wdXRFbGVtZW50O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjaGVja2VkLFxuICAgICAgZGlzYWJsZWQsXG4gICAgICBoYXNFcnJvcixcbiAgICAgIGlkLFxuICAgICAgaW5kZXRlcm1pbmF0ZSxcbiAgICAgIG5hbWUsXG4gICAgICBzaXplLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgbGV0IGJvcmRlclN0eWxlID0gc3R5bGVzLmJvcmRlcjtcbiAgICBpZiAoIWRpc2FibGVkICYmIChjaGVja2VkIHx8IGluZGV0ZXJtaW5hdGUpKSB7XG4gICAgICBib3JkZXJTdHlsZSA9IHN0eWxlcy5ib3JkZXJEYXJrO1xuICAgIH0gZWxzZSBpZiAoaGFzRXJyb3IpIHtcbiAgICAgIGJvcmRlclN0eWxlID0gc3R5bGVzLmJvcmRlckVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8Qm94IHBvc2l0aW9uPVwicmVsYXRpdmVcIj5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoc3R5bGVzLmlucHV0LCB7XG4gICAgICAgICAgICBbc3R5bGVzLmlucHV0RW5hYmxlZF06ICFkaXNhYmxlZCxcbiAgICAgICAgICAgIFtzdHlsZXMuaW5kZXRlcm1pbmF0ZV06IGluZGV0ZXJtaW5hdGUsXG4gICAgICAgICAgICBbc3R5bGVzLmlucHV0U21dOiBzaXplID09PSAnc20nLFxuICAgICAgICAgICAgW3N0eWxlcy5pbnB1dE1kXTogc2l6ZSA9PT0gJ21kJyxcbiAgICAgICAgICB9KX1cbiAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgaWQ9e2lkfVxuICAgICAgICAgIG5hbWU9e25hbWV9XG4gICAgICAgICAgb25CbHVyPXt0aGlzLmhhbmRsZUJsdXJ9XG4gICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlfVxuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9XG4gICAgICAgICAgb25Gb2N1cz17dGhpcy5oYW5kbGVGb2N1c31cbiAgICAgICAgICByZWY9e2VsID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBlbDtcbiAgICAgICAgICB9fVxuICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoXG4gICAgICAgICAgICBib3JkZXJTdHlsZSxcbiAgICAgICAgICAgIHN0eWxlcy5jaGVjayxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgZGlzYWJsZWRcbiAgICAgICAgICAgICAgPyBjaGVja2VkIHx8IGluZGV0ZXJtaW5hdGVcbiAgICAgICAgICAgICAgICA/IGNvbG9ycy5ncmF5QmdcbiAgICAgICAgICAgICAgICA6IGNvbG9ycy5saWdodEdyYXlCZ1xuICAgICAgICAgICAgICA6IGNoZWNrZWQgfHwgaW5kZXRlcm1pbmF0ZVxuICAgICAgICAgICAgICAgID8gY29sb3JzLmRhcmtHcmF5QmdcbiAgICAgICAgICAgICAgICA6IGNvbG9ycy53aGl0ZUJnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBbc3R5bGVzLmNoZWNrRW5hYmxlZF06ICFkaXNhYmxlZCxcbiAgICAgICAgICAgICAgW3N0eWxlcy5jaGVja0ZvY3VzZWRdOiB0aGlzLnN0YXRlLmZvY3VzZWQsXG4gICAgICAgICAgICAgIFtzdHlsZXMuY2hlY2tNZF06IHNpemUgPT09ICdtZCcsXG4gICAgICAgICAgICAgIFtzdHlsZXMuY2hlY2tTbV06IHNpemUgPT09ICdzbScsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKX1cbiAgICAgICAgPlxuICAgICAgICAgIHsoY2hlY2tlZCB8fCBpbmRldGVybWluYXRlKSAmJiAoXG4gICAgICAgICAgICA8SWNvblxuICAgICAgICAgICAgICBhY2Nlc3NpYmlsaXR5TGFiZWw9XCJcIlxuICAgICAgICAgICAgICBjb2xvcj1cIndoaXRlXCJcbiAgICAgICAgICAgICAgaWNvbj17aW5kZXRlcm1pbmF0ZSA/ICdkYXNoJyA6ICdjaGVjayd9XG4gICAgICAgICAgICAgIHNpemU9e3NpemUgPT09ICdzbScgPyA4IDogMTJ9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9Cb3g+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbi8qXG4gICMgQ29sbGVjdGlvblxuXG4gIENvbGxlY3Rpb24gaXMgY29tcG9uZW50IHRoYXQgY2FuIGFic29sdXRlbHkgcG9zaXRpb24gYW5kIHZpcnR1YWxpemUgaXRlbXMuIEl0J3MgbWVhbnQgdG8gYmUgYW4gZXh0ZXJlbWx5IHNpbXBsZSB3b3JraG9yc2UgdG8gcmUtaW1wbGVtZW50IGN1c3RvbSBsYXlvdXRzLiBJdCdzIG5vdCBwZXJmZWN0IGZvciBhbGwgc2l0dWF0aW9ucyBidXQgaXQgZG9lcyBoYXZlIGEgY2xvc2VkIEFQSSBhbmQgaXMgcHJldHR5IHBlcmZvcm1hbnQuXG5cbiAgIyMgSG93IGl0IHdvcmtzXG5cbiAgVGhlcmUgYXJlIHR3byBjZW50cmFsIGNvbmNlcHRzIHRvIENvbGxlY3Rpb24gLSB0aGUgY29udGVudCBsYXllciBhbmQgdGhlIHZpZXdwb3J0IGxheWVyLlxuXG4gIENvbnRlbnQgbGF5ZXIgICAgICAgICAgICAgICBWaWV3cG9ydCAgICAgICAgICAgICAgICAgICBDb21wb3NpdGUgbGF5ZXJcblxuICArLS0tLS0tLS0tLS0tLS0tLSsgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tK1xuICB8ICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfFxuICB8ICstLSsgKy0tKyArLS0rIHwgICAgICAgICAgfCAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfFxuICB8IHwgIHwgfCAgfCB8ICB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfFxuICB8IHwgIHwgfCAgfCB8ICB8IHwgICAgICAgICAgfCArLS0tLS0tLS0tLS0tKyB8ICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLSsgfFxuICB8ICstLSsgfCAgfCB8ICB8IHwgICAgICAgICAgfCB8ICAgICAgICAgICAgfCB8ICAgICAgICAgIHwgfC0tKyB8ICB8IHwgIHwgfFxuICB8ICAgICAgfCAgfCArLS0rIHwgICAgICAgICAgfCB8ICAgICAgICAgICAgfCB8ICAgICAgICAgIHwgfCAgICB8ICB8ICstLXwgfFxuICB8ICstLSsgKy0tKyAgICAgIHwgICAgICAgICAgfCB8ICAgICAgICAgICAgfCB8ICAgICAgICAgIHwgfC0tKyArLS0rICAgIHwgfFxuICB8IHwgIHwgICAgICArLS0rIHwgKy0tLS0tLT4gfCB8ICAgICAgICAgICAgfCB8ICstLS0tLS0+IHwgfCAgfCAgICAgICstLXwgfFxuICB8ICstLSsgKy0tKyB8ICB8IHwgICAgICAgICAgfCB8ICAgICAgICAgICAgfCB8ICAgICAgICAgIHwgfC0tKyArLS0rIHwgIHwgfFxuICB8ICAgICAgfCAgfCB8ICB8IHwgICAgICAgICAgfCB8ICAgICAgICAgICAgfCB8ICAgICAgICAgIHwgfCAgICB8ICB8IHwgIHwgfFxuICB8ICstLSsgfCAgfCArLS0rIHwgICAgICAgICAgfCB8ICAgICAgICAgICAgfCB8ICAgICAgICAgIHwgfC0tKyB8ICB8ICstLXwgfFxuICB8IHwgIHwgfCAgfCAgICAgIHwgICAgICAgICAgfCB8ICAgICAgICAgICAgfCB8ICAgICAgICAgIHwgfCAgfCB8ICB8ICAgIHwgfFxuICB8IHwgIHwgfCAgfCArLS0rIHwgICAgICAgICAgfCArLS0tLS0tLS0tLS0tKyB8ICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLSsgfFxuICB8IHwgIHwgfCAgfCB8ICB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfFxuICB8ICstLSsgKy0tKyArLS0rIHwgICAgICAgICAgfCAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfFxuICB8ICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfFxuICArLS0tLS0tLS0tLS0tLS0tLSsgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tK1xuXG4gIFlvdSBwb3NpdGlvbiB5b3VyIGl0ZW1zIGluIHRoZSB2aXJ0dWFsIGNvbnRlbnQgbGF5ZXIsIHRoZW4geW91IGRlZmluZSB0aGUgdmlld3BvcnQgbGF5ZXIgKGJ5IGRlZmF1bHQgdGhpcyBpcyB0aGUgZnVsbCBzaXplIG9mIHRoZSBjb250ZW50IGxheWVyKS4gQ29sbGVjdGlvbiB0aGVuIHRha2VzIHRob3NlIGl0ZW1zLCBhbmQgdGhlIHZpZXdwb3J0IHJlbmRlcmluZyB0aGUgY29udGVudCBsYXllciB3aXRoIG9ubHkgdGhlIGl0ZW1zIHRoYXQgZml0IGluc2lkZSB0aGUgdmlld3BvcnQuXG5cbiAgIyMgQXNzdW1wdGlvbnNcblxuICAxLiBZb3VyIGxheW91dCBpcyBwcmUtY2FsY3VsYXRlZC4gQ29sbGVjdGlvbiBleHBlY3RzIGxheW91dCB0byBiZSBwYXNzZWQgaW4gYXMgYSBwcm9wZXJ0eS4gSWYgeW91ciBsYXlvdXQgaXNuJ3QgcmVhZHkgKGkuZS4gc29tZXRoaW5nIG5lZWRzIHRvIGJlIG1lYXN1cmVkKSB0aGUgY2FsbGVyIG5lZWRzIHRvIGZpZ3VyZSB0aGF0IG91dC5cbiAgMi4gUGFzc2VkIGluIEl0ZW0gYXJlIHNvbWV3aGF0IHB1cmUgLSB0aGV5IGNhbiBiZSBtb3VudGVkIGFuZCB1bm1vdW50ZWQgYXQgYW55dGltZSBzbyBJdGVtJ3MgbGlmZWN5Y2xlIG1ldGhvZHMgbmVlZCB0byBhY2NvdW50IGZvciB0aGF0LlxuICAzLiBQYXNzZWQgaW4gSXRlbXMgYXJlIGJvdW5kIHRvIHRoZWlyIGRhdGEtc291cmNlIHNlcGVyYXRlbHkuIEFsbCB0aGV5IHJlY2VpdmUgaXMgYW4gaW5kZXgsIHNvIHRoZXkgbmVlZCB0byBoYXZlIGFueSBleHRlcm5hbCBkYXRhIHNvdXJjZXMgaW4gc2NvcGUuXG4gIDQuIFRoZSB2aWV3cG9ydCBjYW4gYmUgYW55IHNpemUuIE1vc3Qgd2luZG93aW5nL3JlY3ljbGluZyBzb2x1dGlvbnMgaW1wbGVtZW50IHNvbWUgc29ydCBvZiBvdmVyc2Nhbm5pbmcsIGhvd2V2ZXIgQ29sbGVjdGlvbiBsZWF2ZXMgdGhpcyB1cCB0aGUgdGhlIHBhcmVudC5cblxuKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgbGF5b3V0U3R5bGVzIGZyb20gJy4vTGF5b3V0LmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBJdGVtOiAoeyBpZHg6IG51bWJlciB9KSA9PiBSZWFjdC5Ob2RlLFxuICBsYXlvdXQ6IEFycmF5PHt8XG4gICAgdG9wOiBudW1iZXIsXG4gICAgbGVmdDogbnVtYmVyLFxuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgaGVpZ2h0OiBudW1iZXIsXG4gIHx9PixcbiAgdmlld3BvcnRUb3A/OiBudW1iZXIsXG4gIHZpZXdwb3J0TGVmdD86IG51bWJlcixcbiAgdmlld3BvcnRXaWR0aD86IG51bWJlcixcbiAgdmlld3BvcnRIZWlnaHQ/OiBudW1iZXIsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sbGVjdGlvbiBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8UHJvcHMsIHZvaWQ+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZm9yYmlkLXByb3AtdHlwZXNcbiAgICBJdGVtOiBQcm9wVHlwZXMuYW55LFxuICAgIGxheW91dDogUHJvcFR5cGVzLmFycmF5T2YoXG4gICAgICBQcm9wVHlwZXMuZXhhY3Qoe1xuICAgICAgICB0b3A6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICAgICAgbGVmdDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgICAgICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgICAgICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICAgIH0pLmlzUmVxdWlyZWRcbiAgICApLFxuICAgIHZpZXdwb3J0SGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHZpZXdwb3J0TGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAgICB2aWV3cG9ydFRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgICB2aWV3cG9ydFdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgbGF5b3V0OiBbXSxcbiAgICB2aWV3cG9ydExlZnQ6IDAsXG4gICAgdmlld3BvcnRUb3A6IDAsXG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgSXRlbSwgbGF5b3V0LCB2aWV3cG9ydFRvcCA9IDAsIHZpZXdwb3J0TGVmdCA9IDAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGZ1bGwgZGltZW5zaW9ucyBvZiB0aGUgaXRlbSBsYXllclxuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoLi4ubGF5b3V0Lm1hcChpdGVtID0+IGl0ZW0ubGVmdCArIGl0ZW0ud2lkdGgpKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heCguLi5sYXlvdXQubWFwKGl0ZW0gPT4gaXRlbS50b3AgKyBpdGVtLmhlaWdodCkpO1xuXG4gICAgLy8gRGVmYXVsdCB0aGUgdmlld3BvcnQgdG8gYmVpbmcgdGhlIGZ1bGwgd2lkdGggb2YgdGhlIGNvbnRlbnQgbGF5ZXJcbiAgICBjb25zdCB7IHZpZXdwb3J0V2lkdGggPSB3aWR0aCwgdmlld3BvcnRIZWlnaHQgPSBoZWlnaHQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBDYWxjdWxhdGVzIHdoaWNoIGl0ZW1zIGZyb20gdGhlIGl0ZW0gbGF5ZXIgdG8gcmVuZGVyIGluIHRoZSB2aWV3cG9ydFxuICAgIC8vIGxheWVyLlxuICAgIGNvbnN0IGl0ZW1zID0gbGF5b3V0LnJlZHVjZSgoYWNjLCBwb3NpdGlvbiwgaWR4KSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHBvc2l0aW9uLnRvcCArIHBvc2l0aW9uLmhlaWdodCA+IHZpZXdwb3J0VG9wICYmXG4gICAgICAgIHBvc2l0aW9uLnRvcCA8IHZpZXdwb3J0SGVpZ2h0ICsgdmlld3BvcnRUb3AgJiZcbiAgICAgICAgcG9zaXRpb24ubGVmdCA8IHZpZXdwb3J0V2lkdGggKyB2aWV3cG9ydExlZnQgJiZcbiAgICAgICAgcG9zaXRpb24ubGVmdCArIHBvc2l0aW9uLndpZHRoID4gdmlld3BvcnRMZWZ0XG4gICAgICApIHtcbiAgICAgICAgYWNjLnB1c2goeyBpZHgsIC4uLnBvc2l0aW9uIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e2xheW91dFN0eWxlcy5yZWxhdGl2ZX0gc3R5bGU9e3sgd2lkdGgsIGhlaWdodCB9fT5cbiAgICAgICAge2l0ZW1zLm1hcCgoeyBpZHgsIC4uLnN0eWxlIH0pID0+IChcbiAgICAgICAgICA8ZGl2IGtleT17aWR4fSBjbGFzc05hbWU9e2xheW91dFN0eWxlcy5hYnNvbHV0ZX0gc3R5bGU9e3N0eWxlfT5cbiAgICAgICAgICAgIDxJdGVtIGlkeD17aWR4fSAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApKX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi9Db2xsZWN0aW9uLmpzJztcblxudHlwZSBDb2x1bW4gPSAyIHwgMyB8IDQ7XG5cbi8qXG5cblRoaXMgZnVuY3Rpb24ganVzdCBpbXBsZW1lbnRzIHRoZSBkZXNpZ24gY29uc3RyYWludHMgZm9yIGFzeW1ldHJpY2FsIGNvbHVtbnMgaW5cbmEgdmVyeSBzaW1wbGUgd2F5LiBJdCdzIG5vdCBwZXJmZWN0LCBidXQgaXQncyB2ZXJ5IHByZWRpY3RpYmxlLiBJZiB5b3UgZG9cbmFueXRoaW5nLCBpbXByb3ZlIGl0IHNvIHRoYXQgaXQgdGFrZXMgdGhlc2UgY29uc3RyYWludHMgYW5kIGdlbmVyYXRlcyB0aGVtXG5mb3IgbiA+IDQuXG5cbjEgKyBuIGNvbHVtbnM6XG4gIGZpcnN0IGNvbHVtbiBpcyA1MC81MFxuICBjYW4ndCBoYXZlIDMgY29sdW1ucyBpbiBhIHJvdyBiZSA1MC81MFxuXG4qL1xuY29uc3QgVVAgPSBbMC43NSwgMC4yNV07XG5jb25zdCBET1dOID0gWzAuMjUsIDAuNzVdO1xuY29uc3QgTUlEID0gWzAuNSwgMC41XTtcbmNvbnN0IGNvbHVtbkxheW91dCA9IChudW1PZkNvbHVtbnM6IDEgfCBDb2x1bW4pID0+IHtcbiAgc3dpdGNoIChudW1PZkNvbHVtbnMpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gW1tNSURdLCBbVVBdLCBbRE9XTl1dO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBbW1VQLCBNSURdLCBbRE9XTiwgTUlEXSwgW01JRCwgVVBdLCBbTUlELCBET1dOXV07XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgW01JRCwgVVAsIE1JRCwgTUlEXSxcbiAgICAgICAgW01JRCwgRE9XTiwgTUlELCBNSURdLFxuICAgICAgICBbTUlELCBNSUQsIFVQLCBNSURdLFxuICAgICAgICBbTUlELCBNSUQsIERPV04sIE1JRF0sXG4gICAgICAgIFtNSUQsIFVQLCBNSUQsIERPV05dLFxuICAgICAgICBbTUlELCBET1dOLCBNSUQsIFVQXSxcbiAgICAgIF07XG4gICAgY2FzZSAzOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbTUlELCBVUCwgTUlEXSxcbiAgICAgICAgW01JRCwgRE9XTiwgTUlEXSxcbiAgICAgICAgW01JRCwgTUlELCBVUF0sXG4gICAgICAgIFtNSUQsIE1JRCwgRE9XTl0sXG4gICAgICBdO1xuICB9XG59O1xuXG5jb25zdCBwYWRkaW5nQWxsID0gKGd1dHRlciwgcG9zaXRpb25zKSA9PlxuICBwb3NpdGlvbnMubWFwKCh7IHRvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCB9KSA9PiAoe1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIHdpZHRoOiB3aWR0aCAtIGd1dHRlcixcbiAgICBoZWlnaHQ6IGhlaWdodCAtIGd1dHRlcixcbiAgfSkpO1xuXG5jb25zdCBtaW5kZXggPSBhcnIgPT5cbiAgYXJyLnJlZHVjZSgobWluSW5kZXgsIGl0ZW0sIGkpID0+IChpdGVtIDwgYXJyW21pbkluZGV4XSA/IGkgOiBtaW5JbmRleCksIDApO1xuXG5jb25zdCBjb2x1bW5zRm9yQ29sbGFnZVdpdGhDb3ZlciA9IChudW1PZkNvbHVtbnM6IENvbHVtbikgPT5cbiAgbnVtT2ZDb2x1bW5zID09PSA0ID8gMiA6IDE7XG5cbmZ1bmN0aW9uIGdldENvbGxhZ2VMYXlvdXQoe1xuICBndXR0ZXIsXG4gIGNvdmVyLFxuICBjb2x1bW5zOiBudW1Db2xzLFxuICBoZWlnaHQ6IGgsXG4gIHdpZHRoOiB3LFxuICBsYXlvdXRLZXksXG59OiB7XG4gIGd1dHRlcjogbnVtYmVyLFxuICBjb3ZlcjogYm9vbGVhbixcbiAgY29sdW1uczogQ29sdW1uLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgd2lkdGg6IG51bWJlcixcbiAgbGF5b3V0S2V5OiBudW1iZXIsXG59KSB7XG4gIGxldCBwb3NpdGlvbnMgPSBbXTtcbiAgY29uc3Qgd2lkdGggPSB3ICsgZ3V0dGVyO1xuICBjb25zdCBoZWlnaHQgPSBoICsgZ3V0dGVyO1xuXG4gIC8vIElmIHRoZXJlJ3MgYSBjb3ZlciBpbWFnZSwgd2UnbGwgYWRkIHRoYXQgbGF0ZXIuIEl0IHNob3VsZCBiZSBhIGxpdHRsZVxuICAvLyBsZXNzIHRoYW4gaGFsZiB0aGUgd2lkdGggb2YgdGhlIGNvbGxhZ2UuIFdlIGRvIHRoaXMgbm93IChhbmQgbm90IGxhdGVyXG4gIC8vIHdoZW4gd2UgYWRkIHRoZSBjb3ZlciBpbWFnZSkgYmVjYXVzZSBvZiBgY29sdW1uTGF5b3V0YCdzIGNvbnN0cmFpbnRzXG4gIC8vIG5lZWRpbmcgdGhlIGV4YWN0IG51bWJlciBvZiBjb2x1bW5zIHRoYXQgYXJlIGRpc3BsYXllZC5cbiAgY29uc3QgZ3JpZENvbHMgPSBjb3ZlciA/IGNvbHVtbnNGb3JDb2xsYWdlV2l0aENvdmVyKG51bUNvbHMpIDogbnVtQ29scztcblxuICAvLyBTZWxlY3RzIHRoZSBsYXlvdXQgdGhhdCB3ZSdyZSBnb2luZyB0byB1c2UgZm9yIHRoZSBncmlkXG4gIGNvbnN0IGNvbHVtbnMgPSBjb2x1bW5MYXlvdXQoZ3JpZENvbHMpO1xuICBjb25zdCBsYXlvdXRJZHggPSBsYXlvdXRLZXkgJSBjb2x1bW5zLmxlbmd0aDtcbiAgY29uc3QgbGF5b3V0ID0gY29sdW1uc1tsYXlvdXRJZHhdO1xuXG4gIC8vIFRoaXMgZG9lcyBhIHJlYWxseSBzaW1wbGUgdmVyc2lvbiBvZiBvdXIgbWFzb25yeSBsYXlvdXQuIFdoeSByZXBsaWNhdGVcbiAgLy8gdGhhdCBoZXJlPyBhLikgZmV3ZXIgZGVwZW5kZW5jaWVzIGFuZCBiLikgd2UgbmVlZCB0aGUgYWxnb3JpdGhtIHRvXG4gIC8vIHJvdWdobHkgcHJlc2VydmUgdGhlIG9yZGVyIG9mIHRoZSBjb2xsYWdlcyBmcm9tIHdoZW4gdGhleSB3ZXJlIG9yZGVyZWRcbiAgLy8gYnkgTWFzb25yeS5cbiAgY29uc3QgY29sSGVpZ2h0cyA9IG5ldyBBcnJheShncmlkQ29scykuZmlsbCgwKTtcbiAgY29uc3QgY29sQ291bnRzID0gbmV3IEFycmF5KGdyaWRDb2xzKS5maWxsKDApO1xuXG4gIC8vIFdlIGl0ZXJhdGUgb3ZlciBldmVyeSBwb3NpdGlvbiB0aGF0IHdlIHRoaW5rIHdlIGNvdWxkIF9wb3RlbnRpYWxseV8gaGF2ZVxuICAvLyBzbyB0aGF0IHdlIGNhbiBmaWxsIHRoZW0gd2l0aCBlbXB0eSBzZWN0aW9ucyBpZiBuZWVkIGJlLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IDIgKiBncmlkQ29sczsgaSArPSAxKSB7XG4gICAgY29uc3QgY29sID0gbWluZGV4KGNvbEhlaWdodHMpO1xuICAgIGNvbnN0IGNvbElkeCA9IGNvbENvdW50c1tjb2xdO1xuICAgIGNvbnN0IGl0ZW1IZWlnaHQgPSBsYXlvdXRbY29sXVtjb2xJZHhdICogaGVpZ2h0O1xuXG4gICAgcG9zaXRpb25zLnB1c2goe1xuICAgICAgdG9wOiBjb2xIZWlnaHRzW2NvbF0sXG4gICAgICBsZWZ0OiBjb2wgKiAod2lkdGggLyBudW1Db2xzKSxcbiAgICAgIHdpZHRoOiB3aWR0aCAvIG51bUNvbHMsXG4gICAgICBoZWlnaHQ6IGl0ZW1IZWlnaHQsXG4gICAgfSk7XG5cbiAgICBjb2xIZWlnaHRzW2NvbF0gKz0gaXRlbUhlaWdodDtcbiAgICBjb2xDb3VudHNbY29sXSArPSAxO1xuICB9XG5cbiAgLy8gSWYgd2UgaGF2ZSBhIGNvdmVyIGltYWdlLCBmaWd1cmUgb3V0IGhvdyBiaWcgaXQgaXMsIHRoZW4gbW92ZSBhbGwgdGhlXG4gIC8vIGV4aXN0aW5nIGNvbHVtbnMgb3Zlci5cbiAgaWYgKGNvdmVyKSB7XG4gICAgY29uc3QgY292ZXJJbWFnZVdpZHRoID0gTWF0aC5jZWlsKG51bUNvbHMgLyAyKSAqICh3aWR0aCAvIG51bUNvbHMpO1xuICAgIHBvc2l0aW9ucyA9IHBvc2l0aW9ucy5tYXAocG9zaXRpb24gPT4gKHtcbiAgICAgIC4uLnBvc2l0aW9uLFxuICAgICAgbGVmdDogY292ZXJJbWFnZVdpZHRoICsgcG9zaXRpb24ubGVmdCxcbiAgICB9KSk7XG4gICAgcG9zaXRpb25zLnVuc2hpZnQoeyB0b3A6IDAsIGxlZnQ6IDAsIHdpZHRoOiBjb3ZlckltYWdlV2lkdGgsIGhlaWdodCB9KTtcbiAgfVxuXG4gIC8vIFRoaXMgYWRkcyB0aGUgc3BhY2UgYmV0d2VlbiBhbnkgaXRlbXMgdGhhdCB3ZSBoYXZlLiBJdCdzIG5pY2UgdG8gZG9cbiAgLy8gdGhpcyBhcyBhIHNlcGFyYXRlIHBhc3MgYWZ0ZXIgZXZlcnl0aGluZyBlbHNlLCBiZWNhdXNlIHRoZSBtYXRoIGVhcmxpZXJcbiAgLy8gYmVjb21lcyBlYXNpZXIgYW5kIGl0J3MgbGVzcyBicml0dGxlIHRvIGNoYW5nZS5cbiAgaWYgKGd1dHRlcikge1xuICAgIHBvc2l0aW9ucyA9IHBhZGRpbmdBbGwoZ3V0dGVyLCBwb3NpdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHBvc2l0aW9ucztcbn1cblxudHlwZSBQcm9wcyA9IHt8XG4gIGNvbHVtbnM6IENvbHVtbixcbiAgY292ZXI/OiBib29sZWFuLFxuICBndXR0ZXI/OiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyLFxuICBsYXlvdXRLZXk/OiBudW1iZXIsXG4gIHJlbmRlckltYWdlOiAoe3xcbiAgICB3aWR0aDogbnVtYmVyLFxuICAgIGhlaWdodDogbnVtYmVyLFxuICAgIGluZGV4OiBudW1iZXIsXG4gIHx9KSA9PiBSZWFjdC5Ob2RlLFxuICB3aWR0aDogbnVtYmVyLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvbGxhZ2UocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjb2x1bW5zLFxuICAgIGNvdmVyLFxuICAgIGd1dHRlcixcbiAgICBoZWlnaHQsXG4gICAgbGF5b3V0S2V5LFxuICAgIHJlbmRlckltYWdlLFxuICAgIHdpZHRoLFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IGdldENvbGxhZ2VMYXlvdXQoe1xuICAgIGNvbHVtbnMsXG4gICAgY292ZXI6ICEhY292ZXIsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGd1dHRlcjogZ3V0dGVyIHx8IDAsXG4gICAgbGF5b3V0S2V5OiBsYXlvdXRLZXkgfHwgMCxcbiAgfSk7XG4gIHJldHVybiAoXG4gICAgPENvbGxlY3Rpb25cbiAgICAgIEl0ZW09eyh7IGlkeDogaW5kZXggfSkgPT5cbiAgICAgICAgcmVuZGVySW1hZ2Uoe1xuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHdpZHRoOiBwb3NpdGlvbnNbaW5kZXhdLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogcG9zaXRpb25zW2luZGV4XS5oZWlnaHQsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBsYXlvdXQ9e3Bvc2l0aW9uc31cbiAgICAvPlxuICApO1xufVxuXG5Db2xsYWdlLnByb3BUeXBlcyA9IHtcbiAgY29sdW1uczogUHJvcFR5cGVzLm9uZU9mKFsyLCAzLCA0XSkuaXNSZXF1aXJlZCxcbiAgY292ZXI6IFByb3BUeXBlcy5ib29sLFxuICBndXR0ZXI6IFByb3BUeXBlcy5udW1iZXIsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBsYXlvdXRLZXk6IFByb3BUeXBlcy5udW1iZXIsXG4gIHJlbmRlckltYWdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcbiIsIi8qIEBmbG93ICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vQ29sdW1uQ29sdW1uLmNzcyc7XG5cbnR5cGUgRGVwcmVjYXRlZENvbHVtbnMgPSAxIHwgMiB8IDMgfCA0IHwgNSB8IDYgfCA3IHwgOCB8IDkgfCAxMCB8IDExIHwgMTI7XG50eXBlIENvbHVtbnMgPSAwIHwgMSB8IDIgfCAzIHwgNCB8IDUgfCA2IHwgNyB8IDggfCA5IHwgMTAgfCAxMSB8IDEyO1xuXG50eXBlIENvbHVtblByb3BzID1cbiAgfCB7fFxuICAgICAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICAgICAgc3BhbjogQ29sdW1ucyxcbiAgICAgIHNtU3Bhbj86IENvbHVtbnMsXG4gICAgICBtZFNwYW4/OiBDb2x1bW5zLFxuICAgICAgbGdTcGFuPzogQ29sdW1ucyxcbiAgICB8fVxuICB8IHt8XG4gICAgICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gICAgICB4cz86IERlcHJlY2F0ZWRDb2x1bW5zLFxuICAgICAgc20/OiBEZXByZWNhdGVkQ29sdW1ucyxcbiAgICAgIG1kPzogRGVwcmVjYXRlZENvbHVtbnMsXG4gICAgICBsZz86IERlcHJlY2F0ZWRDb2x1bW5zLFxuICAgIHx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb2x1bW4ocHJvcHM6IENvbHVtblByb3BzKSB7XG4gIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHByb3BzO1xuICBjb25zdCBjcyA9IGNsYXNzbmFtZXMoXG4gICAgKHByb3BzLnhzICE9PSB1bmRlZmluZWQgfHxcbiAgICAgIHByb3BzLnNtICE9PSB1bmRlZmluZWQgfHxcbiAgICAgIHByb3BzLm1kICE9PSB1bmRlZmluZWQgfHxcbiAgICAgIHByb3BzLmxnICE9PSB1bmRlZmluZWQpICYmXG4gICAgICBzdHlsZXMuZGVwcmVjYXRlZENvbHVtbixcbiAgICBwcm9wcy54cyAmJiBzdHlsZXNbYHhzQ29sJHtwcm9wcy54c31gXSxcbiAgICBwcm9wcy5zbSAmJiBzdHlsZXNbYHNtQ29sJHtwcm9wcy5zbX1gXSxcbiAgICBwcm9wcy5tZCAmJiBzdHlsZXNbYG1kQ29sJHtwcm9wcy5tZH1gXSxcbiAgICBwcm9wcy5sZyAmJiBzdHlsZXNbYGxnQ29sJHtwcm9wcy5sZ31gXSxcbiAgICBwcm9wcy5zcGFuICE9IG51bGwgJiYgc3R5bGVzW2B4c0NvbCR7cHJvcHMuc3Bhbn1gXSxcbiAgICBwcm9wcy5zbVNwYW4gIT0gbnVsbCAmJiBzdHlsZXNbYHNtQ29sJHtwcm9wcy5zbVNwYW59YF0sXG4gICAgcHJvcHMubWRTcGFuICE9IG51bGwgJiYgc3R5bGVzW2BtZENvbCR7cHJvcHMubWRTcGFufWBdLFxuICAgIHByb3BzLmxnU3BhbiAhPSBudWxsICYmIHN0eWxlc1tgbGdDb2wke3Byb3BzLmxnU3Bhbn1gXVxuICApO1xuICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e2NzfT57Y2hpbGRyZW59PC9kaXY+O1xufVxuXG5Db2x1bW4ucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIHhzOiBQcm9wVHlwZXMubnVtYmVyLFxuICBzbTogUHJvcFR5cGVzLm51bWJlcixcbiAgbWQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxnOiBQcm9wVHlwZXMubnVtYmVyLFxuICBzcGFuOiBQcm9wVHlwZXMubnVtYmVyLFxuICBzbVNwYW46IFByb3BUeXBlcy5udW1iZXIsXG4gIG1kU3BhbjogUHJvcFR5cGVzLm51bWJlcixcbiAgbGdTcGFuOiBQcm9wVHlwZXMubnVtYmVyLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29udGFpbmVyKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7IGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8Qm94IGp1c3RpZnlDb250ZW50PVwiY2VudGVyXCIgZGlzcGxheT1cImZsZXhcIj5cbiAgICAgIDxCb3ggbWF4V2lkdGg9ezgwMH0gd2lkdGg9XCIxMDAlXCI+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvQm94PlxuICAgIDwvQm94PlxuICApO1xufVxuXG5Db250YWluZXIucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9EaXZpZGVyLmNzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERpdmlkZXIoKSB7XG4gIHJldHVybiA8aHIgY2xhc3NOYW1lPXtzdHlsZXMuZGl2aWRlcn0gLz47XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxudHlwZSBQcm9wcyA9IHtcbiAgZGlyZWN0aW9uPzogPyd1cCcgfCAncmlnaHQnIHwgJ2Rvd24nIHwgJ2xlZnQnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FyZXQocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHsgZGlyZWN0aW9uIH0gPSBwcm9wcztcbiAgbGV0IHBhdGg7XG4gIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgY2FzZSAndXAnOlxuICAgICAgcGF0aCA9ICdNMCAwIEwxMiAxMiBMMjQgMCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICBwYXRoID0gJ00yNCAwIEwxMiAxMiBMMjQgMjQnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZG93bic6XG4gICAgICBwYXRoID0gJ00wIDI0IEwxMiAxMiBMMjQgMjQnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICBwYXRoID0gJ00wIDAgTDEyIDEyIEwwIDI0JztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxzdmcgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCI+XG4gICAgICA8cGF0aCBkPXtwYXRofSAvPlxuICAgIDwvc3ZnPlxuICApO1xufVxuXG5DYXJldC5wcm9wVHlwZXMgPSB7XG4gIGRpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsndXAnLCAncmlnaHQnLCAnZG93bicsICdsZWZ0J10pLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgQ2FyZXQgZnJvbSAnLi9DYXJldC5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vQ29udGVudHMuY3NzJztcbmltcG9ydCBjb2xvcnMgZnJvbSAnLi9Db2xvcnMuY3NzJztcblxuLyogTmVlZGVkIHVudGlsIHRoaXMgRmxvdyBpc3N1ZSBpcyBmaXhlZDogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzM4MCAqL1xuLyogZXNsaW50IHF1b3RlLXByb3BzOiAwICovXG5jb25zdCBTUEFDRVNfSU5ERVhfTUFQID0ge1xuICAnMCc6ICd1cCcsXG4gICcxJzogJ3JpZ2h0JyxcbiAgJzInOiAnZG93bicsXG4gICczJzogJ2xlZnQnLFxufTtcblxuY29uc3QgRElSX0lOREVYX01BUCA9IHtcbiAgdXA6IDAsXG4gIHJpZ2h0OiAxLFxuICBkb3duOiAyLFxuICBsZWZ0OiAzLFxufTtcblxuY29uc3QgTUFSR0lOID0gMjQ7XG5leHBvcnQgY29uc3QgQ0FSRVRfSEVJR0hUID0gMjQ7XG5jb25zdCBDQVJFVF9PRkZTRVRfRlJPTV9TSURFID0gMjQ7XG5leHBvcnQgY29uc3QgQk9SREVSX1JBRElVUyA9IDg7XG5cbnR5cGUgTWFpbkRpciA9ID8oJ3VwJyB8ICdyaWdodCcgfCAnZG93bicgfCAnbGVmdCcpO1xudHlwZSBTdWJEaXIgPSAndXAnIHwgJ3JpZ2h0JyB8ICdkb3duJyB8ICdsZWZ0JyB8ICdtaWRkbGUnO1xuXG50eXBlIENsaWVudFJlY3QgPSB7XG4gIGJvdHRvbTogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgbGVmdDogbnVtYmVyLFxuICByaWdodDogbnVtYmVyLFxuICB0b3A6IG51bWJlcixcbiAgd2lkdGg6IG51bWJlcixcbn07XG5cbnR5cGUgV2luZG93ID0ge1xuICBoZWlnaHQ6IG51bWJlcixcbiAgd2lkdGg6IG51bWJlcixcbiAgc2Nyb2xsWTogbnVtYmVyLFxuICBzY3JvbGxYOiBudW1iZXIsXG59O1xuXG50eXBlIEZseW91dCA9IHsgaGVpZ2h0OiBudW1iZXIsIHdpZHRoOiBudW1iZXIgfTtcblxudHlwZSBTaGlmdCA9IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfTtcblxudHlwZSBFZGdlU2hpZnQgPSB7IGNhcmV0OiBTaGlmdCwgZmx5b3V0OiBTaGlmdCB9O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9uby11bnVzZWQtcHJvcC10eXBlcyAqL1xudHlwZSBQcm9wcyA9IHt8XG4gIGJnQ29sb3I6ICdibHVlJyB8ICdkYXJrR3JheScgfCAnb3JhbmdlJyB8ICd3aGl0ZScsXG4gIGNhcmV0PzogYm9vbGVhbixcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICBpZGVhbERpcmVjdGlvbj86ICd1cCcgfCAncmlnaHQnIHwgJ2Rvd24nIHwgJ2xlZnQnLFxuICBvbktleURvd246IChldmVudDogeyBrZXlDb2RlOiBudW1iZXIgfSkgPT4gdm9pZCxcbiAgb25SZXNpemU6ICgpID0+IHZvaWQsXG4gIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcj86IGJvb2xlYW4sXG4gIHJlbGF0aXZlT2Zmc2V0OiB7XG4gICAgeDogbnVtYmVyLFxuICAgIHk6IG51bWJlcixcbiAgfSxcbiAgc2hvdWxkRm9jdXM/OiBib29sZWFuLFxuICB0cmlnZ2VyUmVjdDogQ2xpZW50UmVjdCxcbiAgd2lkdGg6ID9udW1iZXIsXG58fTtcbi8qIGVzbGludC1lbmFibGUgcmVhY3Qvbm8tdW51c2VkLXByb3AtdHlwZXMgKi9cblxudHlwZSBTdGF0ZSA9IHt8XG4gIGZseW91dE9mZnNldDoge1xuICAgIHRvcDogP251bWJlcixcbiAgICBsZWZ0OiA/bnVtYmVyLFxuICB9LFxuICBjYXJldE9mZnNldDoge1xuICAgIHRvcDogP251bWJlcixcbiAgICByaWdodDogP251bWJlcixcbiAgICBib3R0b206ID9udW1iZXIsXG4gICAgbGVmdDogP251bWJlcixcbiAgfSxcbiAgbWFpbkRpcjogP01haW5EaXIsXG58fTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBtYWluIGRpcmVjdGlvbiB0aGUgZmx5b3V0IG9wZW5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYWluRGlyKFxuICBmbHlvdXRTaXplOiBGbHlvdXQsXG4gIGlkZWFsRGlyZWN0aW9uOiBNYWluRGlyLFxuICB0cmlnZ2VyUmVjdDogQ2xpZW50UmVjdCxcbiAgd2luZG93U2l6ZTogV2luZG93XG4pIHtcbiAgLy8gQ2FsY3VsYXRlcyB0aGUgYXZhaWxhYmxlIHNwYWNlIGlmIHdlIHdlcmUgdG8gcGxhY2UgdGhlIGZseW91dCBpbiB0aGUgNCBtYWluIGRpcmVjdGlvbnNcbiAgLy8gdG8gZGV0ZXJtaW5lIHdoaWNoICdxdWFkcmFudCcgdG8gcG9zaXRpb24gdGhlIGZseW91dCBpbnNpZGUgb2ZcbiAgbGV0IHVwID0gdHJpZ2dlclJlY3QudG9wIC0gZmx5b3V0U2l6ZS5oZWlnaHQgLSBDQVJFVF9IRUlHSFQ7XG4gIGxldCByaWdodCA9XG4gICAgd2luZG93U2l6ZS53aWR0aCAtIGZseW91dFNpemUud2lkdGggLSBDQVJFVF9IRUlHSFQgLSB0cmlnZ2VyUmVjdC5yaWdodDtcbiAgbGV0IGRvd24gPVxuICAgIHdpbmRvd1NpemUuaGVpZ2h0IC0gZmx5b3V0U2l6ZS5oZWlnaHQgLSBDQVJFVF9IRUlHSFQgLSB0cmlnZ2VyUmVjdC5ib3R0b207XG4gIGxldCBsZWZ0ID0gdHJpZ2dlclJlY3QubGVmdCAtIGZseW91dFNpemUud2lkdGggLSBDQVJFVF9IRUlHSFQ7XG5cbiAgLy8gb3ZlcnJpZGVzIGF2YWlsYWJsZSBzcGFjZSB3aGVuIHRoZSB0cmlnZ2VyIGlzIGNsb3NlIHRvIHRoZSBlZGdlIG9mIHRoZSBzY3JlZW5cbiAgLy8gdHJpZ2dlciBpcyB0b28gY2xvc2UgdG8gdG9wL2JvdHRvbSBvZiBzY3JlZW4gZm9yIGxlZnQgJiByaWdodCBmbHlvdXRzXG4gIGlmIChcbiAgICB0cmlnZ2VyUmVjdC50b3AgPCBCT1JERVJfUkFESVVTIHx8XG4gICAgd2luZG93U2l6ZS5oZWlnaHQgLSB0cmlnZ2VyUmVjdC5ib3R0b20gPCBCT1JERVJfUkFESVVTXG4gICkge1xuICAgIGxlZnQgPSAwO1xuICAgIHJpZ2h0ID0gMDtcbiAgfVxuXG4gIC8vIHRyaWdnZXIgaXMgdG9vIGNsb3NlIHRvIHRoZSBsZWZ0L3JpZ2h0IG9mIHNjcmVlbiBmb3IgdXAgJiBkb3duIGZseW91dHNcbiAgaWYgKFxuICAgIHRyaWdnZXJSZWN0LmxlZnQgPCBCT1JERVJfUkFESVVTIHx8XG4gICAgd2luZG93U2l6ZS53aWR0aCAtIHRyaWdnZXJSZWN0LnJpZ2h0IDwgQk9SREVSX1JBRElVU1xuICApIHtcbiAgICB1cCA9IDA7XG4gICAgZG93biA9IDA7XG4gIH1cblxuICBjb25zdCBzcGFjZXMgPSBbdXAsIHJpZ2h0LCBkb3duLCBsZWZ0XTtcblxuICAvLyBJZGVudGlmeSBiZXN0IGRpcmVjdGlvbiBvZiBhdmFpbGFibGUgc3BhY2VzXG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLnNwYWNlcyk7XG5cbiAgLy8gQ2hvc2UgdGhlIG1haW4gZGlyZWN0aW9uIGZvciB0aGUgZmx5b3V0IGJhc2VkIG9uIGF2YWlsYWJsZSBzcGFjZXMgJiB1c2VyIHByZWZlcmVuY2VcbiAgbGV0IG1haW5EaXI7XG4gIGlmIChpZGVhbERpcmVjdGlvbiAmJiBzcGFjZXNbRElSX0lOREVYX01BUFtpZGVhbERpcmVjdGlvbl1dID4gMCkge1xuICAgIC8vIHVzZXIgcHJlZlxuICAgIG1haW5EaXIgPSBpZGVhbERpcmVjdGlvbjtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBubyBkaXJlY3Rpb24gcHJlZiwgY2hvc2UgdGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0aGVyZSBpcyB0aGUgbW9zdCBzcGFjZSBhdmFpbGFibGVcbiAgICBtYWluRGlyID0gU1BBQ0VTX0lOREVYX01BUFtzcGFjZXMuaW5kZXhPZihtYXgpXTtcbiAgfVxuICByZXR1cm4gbWFpbkRpcjtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBzdWIgZGlyZWN0aW9uIG9mIGhvdyB0aGUgZmx5b3V0IGlzIHBvc2l0aW9uZWQgd2l0aGluIHRoZSBtYWluIGRpclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3ViRGlyKFxuICBmbHlvdXRTaXplOiBGbHlvdXQsXG4gIG1haW5EaXI6IE1haW5EaXIsXG4gIHRyaWdnZXJSZWN0OiBDbGllbnRSZWN0LFxuICB3aW5kb3dTaXplOiBXaW5kb3dcbikge1xuICAvLyBOb3cgdGhhdCB3ZSBoYXZlIHRoZSBtYWluIGRpcmVjdGlvbiwgY2hvc2UgZnJvbSAzIGNhcmV0IHBsYWNlbWVudHMgZm9yIHRoYXQgZGlyZWN0aW9uXG4gIGxldCBvZmZzZXQ7XG4gIGxldCB0cmlnZ2VyTWlkO1xuICBsZXQgd2luZG93U3BhY2VBdmFpbGFibGU7XG5cbiAgaWYgKG1haW5EaXIgPT09ICdyaWdodCcgfHwgbWFpbkRpciA9PT0gJ2xlZnQnKSB7XG4gICAgb2Zmc2V0ID0gZmx5b3V0U2l6ZS5oZWlnaHQgLyAyO1xuICAgIHRyaWdnZXJNaWQgPSB0cmlnZ2VyUmVjdC50b3AgKyAodHJpZ2dlclJlY3QuYm90dG9tIC0gdHJpZ2dlclJlY3QudG9wKSAvIDI7XG4gICAgd2luZG93U3BhY2VBdmFpbGFibGUgPSB3aW5kb3dTaXplLmhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICAvLyAobWFpbkRpciA9PT0gJ3VwJyB8fCBtYWluRGlyID09PSAnZG93bicpXG4gICAgb2Zmc2V0ID0gZmx5b3V0U2l6ZS53aWR0aCAvIDI7XG4gICAgdHJpZ2dlck1pZCA9IHRyaWdnZXJSZWN0LmxlZnQgKyAodHJpZ2dlclJlY3QucmlnaHQgLSB0cmlnZ2VyUmVjdC5sZWZ0KSAvIDI7XG4gICAgd2luZG93U3BhY2VBdmFpbGFibGUgPSB3aW5kb3dTaXplLndpZHRoO1xuICB9XG5cbiAgY29uc3QgYWJvdmVPckxlZnQgPSB0cmlnZ2VyTWlkIC0gb2Zmc2V0IC0gTUFSR0lOO1xuICBjb25zdCBiZWxvd09yUmlnaHQgPSB3aW5kb3dTcGFjZUF2YWlsYWJsZSAtIHRyaWdnZXJNaWQgLSBvZmZzZXQgLSBNQVJHSU47XG4gIGxldCBzdWJEaXI7XG4gIGlmIChhYm92ZU9yTGVmdCA+IDAgJiYgYmVsb3dPclJpZ2h0ID4gMCkge1xuICAgIC8vIGNhcmV0IHNob3VsZCBnbyBpbiBtaWRkbGUgYi9jIGl0IGNhblxuICAgIHN1YkRpciA9ICdtaWRkbGUnO1xuICB9IGVsc2UgaWYgKGJlbG93T3JSaWdodCA+IDApIHtcbiAgICAvLyBjYXJldCBzaG91bGQgZ28gYXQgdG9wIGZvciBsZWZ0L3JpZ2h0IGFuZCBsZWZ0IGZvciB1cC9kb3duXG4gICAgc3ViRGlyID0gbWFpbkRpciA9PT0gJ2xlZnQnIHx8IG1haW5EaXIgPT09ICdyaWdodCcgPyAndXAnIDogJ2xlZnQnO1xuICB9IGVsc2Uge1xuICAgIC8vIGNhcmV0IHNob3VsZCBnbyBhdCBib3R0b20gZm9yIGxlZnQvcmlnaHQgYW5kIHJpZ2h0IGZvciB1cC9kb3duXG4gICAgc3ViRGlyID0gbWFpbkRpciA9PT0gJ2xlZnQnIHx8IG1haW5EaXIgPT09ICdyaWdodCcgPyAnZG93bicgOiAncmlnaHQnO1xuICB9XG4gIHJldHVybiBzdWJEaXI7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYW1vdW50IHRoZSBmbHlvdXQgJiBjYXJldCBuZWVkIHRvIHNoaWZ0IG92ZXIgdG8gYWxpZ24gd2l0aCBkZXNpZ25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjRWRnZVNoaWZ0cyhcbiAgc3ViRGlyOiBTdWJEaXIsXG4gIHRyaWdnZXJSZWN0OiBDbGllbnRSZWN0LFxuICB3aW5kb3dTaXplOiBXaW5kb3dcbikge1xuICAvLyBUYXJnZXQgdmFsdWVzIGZvciBmbHlvdXQgYW5kIGNhcmV0IHNoaWZ0c1xuICBsZXQgZmx5b3V0VmVydGljYWxTaGlmdCA9XG4gICAgQ0FSRVRfT0ZGU0VUX0ZST01fU0lERSAtICh0cmlnZ2VyUmVjdC5oZWlnaHQgLSBDQVJFVF9IRUlHSFQpIC8gMjtcbiAgbGV0IGZseW91dEhvcml6b250YWxTaGlmdCA9XG4gICAgQ0FSRVRfT0ZGU0VUX0ZST01fU0lERSAtICh0cmlnZ2VyUmVjdC53aWR0aCAtIENBUkVUX0hFSUdIVCkgLyAyO1xuICBsZXQgY2FyZXRWZXJ0aWNhbFNoaWZ0ID0gQ0FSRVRfSEVJR0hUO1xuICBsZXQgY2FyZXRIb3Jpem9udGFsU2hpZnQgPSBDQVJFVF9IRUlHSFQ7XG5cbiAgLy8gQ292ZXJzIGVkZ2UgY2FzZSB3aGVyZSB0cmlnZ2VyIGlzIGluIGEgY29ybmVyIGFuZCB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgb2Zmc2V0IG9mIHRoZSBjYXJldFxuICAvLyB0byBzb21ldGhpbmcgc21hbGxlciB0aGFuIG5vcm1hbCBpbiBvcmRlclxuICBjb25zdCBpc0Nsb3NlVmVydGljYWxseSA9XG4gICAgdHJpZ2dlclJlY3QudG9wIC0gZmx5b3V0VmVydGljYWxTaGlmdCA8IDAgfHxcbiAgICB0cmlnZ2VyUmVjdC5ib3R0b20gKyBmbHlvdXRWZXJ0aWNhbFNoaWZ0ID4gd2luZG93U2l6ZS5oZWlnaHQ7XG4gIGNvbnN0IGlzQ2xvc2VIb3Jpem9udGFsbHkgPVxuICAgIHRyaWdnZXJSZWN0LmxlZnQgLSBmbHlvdXRIb3Jpem9udGFsU2hpZnQgPCAwIHx8XG4gICAgdHJpZ2dlclJlY3QucmlnaHQgKyBmbHlvdXRIb3Jpem9udGFsU2hpZnQgPiB3aW5kb3dTaXplLndpZHRoO1xuICBpZiAoaXNDbG9zZVZlcnRpY2FsbHkpIHtcbiAgICBmbHlvdXRWZXJ0aWNhbFNoaWZ0ID1cbiAgICAgIEJPUkRFUl9SQURJVVMgLSAodHJpZ2dlclJlY3QuaGVpZ2h0IC0gQ0FSRVRfSEVJR0hUKSAvIDI7XG4gICAgY2FyZXRWZXJ0aWNhbFNoaWZ0ID0gQk9SREVSX1JBRElVUztcbiAgfVxuICBpZiAoaXNDbG9zZUhvcml6b250YWxseSkge1xuICAgIGZseW91dEhvcml6b250YWxTaGlmdCA9XG4gICAgICBCT1JERVJfUkFESVVTIC0gKHRyaWdnZXJSZWN0LndpZHRoIC0gQ0FSRVRfSEVJR0hUKSAvIDI7XG4gICAgY2FyZXRIb3Jpem9udGFsU2hpZnQgPSBCT1JERVJfUkFESVVTO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmbHlvdXQ6IHtcbiAgICAgIHg6IGZseW91dEhvcml6b250YWxTaGlmdCxcbiAgICAgIHk6IGZseW91dFZlcnRpY2FsU2hpZnQsXG4gICAgfSxcbiAgICBjYXJldDoge1xuICAgICAgeDogY2FyZXRIb3Jpem9udGFsU2hpZnQsXG4gICAgICB5OiBjYXJldFZlcnRpY2FsU2hpZnQsXG4gICAgfSxcbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGZseW91dCBhbmQgY2FyZXQgb2Zmc2V0cyBmb3Igc3R5bGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWRqdXN0T2Zmc2V0cyhcbiAgYmFzZTogeyB0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyIH0sXG4gIGVkZ2VTaGlmdDogRWRnZVNoaWZ0LFxuICBmbHlvdXRTaXplOiBGbHlvdXQsXG4gIG1haW5EaXI6IE1haW5EaXIsXG4gIHN1YkRpcjogU3ViRGlyLFxuICB0cmlnZ2VyUmVjdDogQ2xpZW50UmVjdFxuKSB7XG4gIGxldCBmbHlvdXRMZWZ0ID0gYmFzZS5sZWZ0O1xuICBsZXQgZmx5b3V0VG9wID0gYmFzZS50b3A7XG5cbiAgbGV0IGNhcmV0VG9wID0gbWFpbkRpciA9PT0gJ2Rvd24nID8gLUNBUkVUX0hFSUdIVCA6IG51bGw7XG4gIGxldCBjYXJldFJpZ2h0ID0gbWFpbkRpciA9PT0gJ2xlZnQnID8gLUNBUkVUX0hFSUdIVCA6IG51bGw7XG4gIGxldCBjYXJldEJvdHRvbSA9IG51bGw7XG4gIGxldCBjYXJldExlZnQgPSBtYWluRGlyID09PSAncmlnaHQnID8gLUNBUkVUX0hFSUdIVCA6IG51bGw7XG5cbiAgaWYgKHN1YkRpciA9PT0gJ3VwJykge1xuICAgIGZseW91dFRvcCA9IGJhc2UudG9wIC0gZWRnZVNoaWZ0LmZseW91dC55O1xuICAgIGNhcmV0VG9wID0gZWRnZVNoaWZ0LmNhcmV0Lnk7XG4gIH0gZWxzZSBpZiAoc3ViRGlyID09PSAnZG93bicpIHtcbiAgICBmbHlvdXRUb3AgPVxuICAgICAgYmFzZS50b3AgLSBmbHlvdXRTaXplLmhlaWdodCArIHRyaWdnZXJSZWN0LmhlaWdodCArIGVkZ2VTaGlmdC5mbHlvdXQueTtcbiAgICBjYXJldEJvdHRvbSA9IGVkZ2VTaGlmdC5jYXJldC55O1xuICB9IGVsc2UgaWYgKHN1YkRpciA9PT0gJ2xlZnQnKSB7XG4gICAgZmx5b3V0TGVmdCA9IGJhc2UubGVmdCAtIGVkZ2VTaGlmdC5mbHlvdXQueDtcbiAgICBjYXJldExlZnQgPSBlZGdlU2hpZnQuY2FyZXQueDtcbiAgfSBlbHNlIGlmIChzdWJEaXIgPT09ICdyaWdodCcpIHtcbiAgICBmbHlvdXRMZWZ0ID1cbiAgICAgIGJhc2UubGVmdCAtIGZseW91dFNpemUud2lkdGggKyB0cmlnZ2VyUmVjdC53aWR0aCArIGVkZ2VTaGlmdC5mbHlvdXQueDtcbiAgICBjYXJldFJpZ2h0ID0gZWRnZVNoaWZ0LmNhcmV0Lng7XG4gIH0gZWxzZSBpZiAoc3ViRGlyID09PSAnbWlkZGxlJykge1xuICAgIGlmIChtYWluRGlyID09PSAnbGVmdCcgfHwgbWFpbkRpciA9PT0gJ3JpZ2h0Jykge1xuICAgICAgY29uc3QgdHJpZ2dlck1pZCA9IGZseW91dFRvcCArIHRyaWdnZXJSZWN0LmhlaWdodCAvIDI7XG4gICAgICBmbHlvdXRUb3AgPSB0cmlnZ2VyTWlkIC0gZmx5b3V0U2l6ZS5oZWlnaHQgLyAyO1xuICAgICAgY2FyZXRUb3AgPSAoZmx5b3V0U2l6ZS5oZWlnaHQgLSBDQVJFVF9IRUlHSFQpIC8gMjtcbiAgICB9XG4gICAgaWYgKG1haW5EaXIgPT09ICd1cCcgfHwgbWFpbkRpciA9PT0gJ2Rvd24nKSB7XG4gICAgICBjb25zdCB0cmlnZ2VyTWlkID0gZmx5b3V0TGVmdCArIHRyaWdnZXJSZWN0LndpZHRoIC8gMjtcbiAgICAgIGZseW91dExlZnQgPSB0cmlnZ2VyTWlkIC0gZmx5b3V0U2l6ZS53aWR0aCAvIDI7XG4gICAgICBjYXJldExlZnQgPSAoZmx5b3V0U2l6ZS53aWR0aCAtIENBUkVUX0hFSUdIVCkgLyAyO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZmx5b3V0T2Zmc2V0OiB7XG4gICAgICB0b3A6IGZseW91dFRvcCxcbiAgICAgIGxlZnQ6IGZseW91dExlZnQsXG4gICAgfSxcbiAgICBjYXJldE9mZnNldDoge1xuICAgICAgdG9wOiBjYXJldFRvcCxcbiAgICAgIHJpZ2h0OiBjYXJldFJpZ2h0LFxuICAgICAgYm90dG9tOiBjYXJldEJvdHRvbSxcbiAgICAgIGxlZnQ6IGNhcmV0TGVmdCxcbiAgICB9LFxuICB9O1xufVxuXG4vKiBDYWxjdWxhdGVzIGJhc2VsaW5lIHRvcCBhbmQgbGVmdCBvZmZzZXQgZm9yIGZseW91dCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2VPZmZzZXRzKFxuICByZWxhdGl2ZU9mZnNldDogeyB4OiBudW1iZXIsIHk6IG51bWJlciB9LFxuICBmbHlvdXRTaXplOiBGbHlvdXQsXG4gIG1haW5EaXI6IE1haW5EaXIsXG4gIHRyaWdnZXJSZWN0OiBDbGllbnRSZWN0LFxuICB3aW5kb3dTaXplOiBXaW5kb3dcbikge1xuICBjb25zdCBIQUxGX0NBUkVUID0gQ0FSRVRfSEVJR0hUIC8gMjtcbiAgLy8gVE9QIE9GRlNFVFxuICBsZXQgdG9wO1xuICBpZiAobWFpbkRpciA9PT0gJ2Rvd24nKSB7XG4gICAgdG9wID0gd2luZG93U2l6ZS5zY3JvbGxZICsgdHJpZ2dlclJlY3QuYm90dG9tICsgSEFMRl9DQVJFVDtcbiAgfSBlbHNlIGlmIChtYWluRGlyID09PSAndXAnKSB7XG4gICAgdG9wID1cbiAgICAgIHdpbmRvd1NpemUuc2Nyb2xsWSArICh0cmlnZ2VyUmVjdC50b3AgLSBmbHlvdXRTaXplLmhlaWdodCAtIEhBTEZfQ0FSRVQpO1xuICB9IGVsc2Uge1xuICAgIC8vIGxlZnQgYW5kIHJpZ2h0XG4gICAgdG9wID0gd2luZG93U2l6ZS5zY3JvbGxZICsgdHJpZ2dlclJlY3QudG9wO1xuICB9XG5cbiAgLy8gTEVGVCBPRkZTRVRcbiAgbGV0IGxlZnQ7XG4gIGlmIChtYWluRGlyID09PSAnbGVmdCcpIHtcbiAgICBsZWZ0ID1cbiAgICAgIHdpbmRvd1NpemUuc2Nyb2xsWCArICh0cmlnZ2VyUmVjdC5sZWZ0IC0gZmx5b3V0U2l6ZS53aWR0aCAtIEhBTEZfQ0FSRVQpO1xuICB9IGVsc2UgaWYgKG1haW5EaXIgPT09ICdyaWdodCcpIHtcbiAgICBsZWZ0ID0gd2luZG93U2l6ZS5zY3JvbGxYICsgdHJpZ2dlclJlY3QucmlnaHQgKyBIQUxGX0NBUkVUO1xuICB9IGVsc2Uge1xuICAgIC8vIGRvd24gYW5kIHVwXG4gICAgbGVmdCA9IHdpbmRvd1NpemUuc2Nyb2xsWCArIHRyaWdnZXJSZWN0LmxlZnQ7XG4gIH1cblxuICAvLyBBZGp1c3RzIGZvciB0aGUgcmVsYXRpdmUgcGFyZW50IGNvbnRhaW5lclxuICB0b3AgLT0gcmVsYXRpdmVPZmZzZXQueTtcbiAgbGVmdCAtPSByZWxhdGl2ZU9mZnNldC54O1xuICByZXR1cm4geyB0b3AsIGxlZnQgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udGVudHMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYmdDb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsnYmx1ZScsICdkYXJrR3JheScsICdvcmFuZ2UnLCAnd2hpdGUnXSksXG4gICAgY2FyZXQ6IFByb3BUeXBlcy5ib29sLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICBpZGVhbERpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsndXAnLCAncmlnaHQnLCAnZG93bicsICdsZWZ0J10pLFxuICAgIG9uS2V5RG93bjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvblJlc2l6ZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICByZWxhdGl2ZU9mZnNldDogUHJvcFR5cGVzLmV4YWN0KHtcbiAgICAgIHg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICB5OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIH0pLFxuICAgIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgc2hvdWxkRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuICAgIHRyaWdnZXJSZWN0OiBQcm9wVHlwZXMuZXhhY3Qoe1xuICAgICAgYm90dG9tOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgIHJpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgfSksXG4gICAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBjYXJldDogdHJ1ZSxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBmbHlvdXRPZmZzZXQ6IHtcbiAgICAgIHRvcDogdW5kZWZpbmVkLFxuICAgICAgcmlnaHQ6IHVuZGVmaW5lZCxcbiAgICAgIGJvdHRvbTogdW5kZWZpbmVkLFxuICAgICAgbGVmdDogdW5kZWZpbmVkLFxuICAgIH0sXG4gICAgY2FyZXRPZmZzZXQ6IHtcbiAgICAgIHRvcDogdW5kZWZpbmVkLFxuICAgICAgcmlnaHQ6IHVuZGVmaW5lZCxcbiAgICAgIGJvdHRvbTogdW5kZWZpbmVkLFxuICAgICAgbGVmdDogdW5kZWZpbmVkLFxuICAgIH0sXG4gICAgbWFpbkRpcjogbnVsbCxcbiAgfTtcblxuICBmbHlvdXQ6IHt8IGN1cnJlbnQ6IG51bGwgfCBSZWFjdC5FbGVtZW50UmVmPCdkaXYnPiB8fSA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuc2V0Rmx5b3V0UG9zaXRpb24odGhpcy5wcm9wcyk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5zaG91bGRGb2N1cyAmJiB0aGlzLmZseW91dC5jdXJyZW50KSB7XG4gICAgICAgIHRoaXMuZmx5b3V0LmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5wcm9wcy5vblJlc2l6ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLnByb3BzLm9uS2V5RG93bik7XG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wczogUHJvcHMpIHtcbiAgICB0aGlzLnNldEZseW91dFBvc2l0aW9uKG5leHRQcm9wcyk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5wcm9wcy5vblJlc2l6ZSk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLnByb3BzLm9uS2V5RG93bik7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgbWFpbiBkaXJlY2l0b24sIHN1YiBkaXJlY3Rpb24sIGFuZCBjb3JyZXNwb25kaW5nIG9mZnNldHMgbmVlZGVkXG4gICAqIHRvIGNvcnJlY3RseSBwb3NpdGlvbiB0aGUgb2Zmc2V0XG4gICAqL1xuICBzZXRGbHlvdXRQb3NpdGlvbiA9IChwcm9wczogUHJvcHMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBpZGVhbERpcmVjdGlvbixcbiAgICAgIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcixcbiAgICAgIHJlbGF0aXZlT2Zmc2V0LFxuICAgICAgdHJpZ2dlclJlY3QsXG4gICAgICB3aWR0aCxcbiAgICB9ID0gcHJvcHM7XG5cbiAgICAvLyBTY3JvbGwgbm90IG5lZWRlZCBmb3IgcmVsYXRpdmUgZWxlbWVudHNcbiAgICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LnNjcm9sbFggLyB3aW5kb3cuc2Nyb2xsWSBzaW5jZSBpdCdzIG5vdCBzdXBwb3J0ZWQgYnkgSUUxMVxuICAgIGNvbnN0IHNjcm9sbFggPSBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3JcbiAgICAgID8gMFxuICAgICAgOiB3aW5kb3cucGFnZVhPZmZzZXQgfHxcbiAgICAgICAgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCkgfHxcbiAgICAgICAgMDtcbiAgICBjb25zdCBzY3JvbGxZID0gcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yXG4gICAgICA/IDBcbiAgICAgIDogd2luZG93LnBhZ2VZT2Zmc2V0IHx8XG4gICAgICAgIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCkgfHxcbiAgICAgICAgMDtcblxuICAgIGNvbnN0IHdpbmRvd1NpemUgPSB7XG4gICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIHNjcm9sbFgsXG4gICAgICBzY3JvbGxZLFxuICAgIH07XG5cbiAgICBjb25zdCBmbHlvdXRTaXplID0ge1xuICAgICAgaGVpZ2h0OiB0aGlzLmZseW91dC5jdXJyZW50ID8gdGhpcy5mbHlvdXQuY3VycmVudC5jbGllbnRIZWlnaHQgOiAwLFxuICAgICAgd2lkdGg6XG4gICAgICAgIHdpZHRoIHx8ICh0aGlzLmZseW91dC5jdXJyZW50ID8gdGhpcy5mbHlvdXQuY3VycmVudC5jbGllbnRXaWR0aCA6IDApLFxuICAgIH07XG5cbiAgICAvLyBGaXJzdCBjaG9vc2Ugb25lIG9mIDQgbWFpbiBkaXJlY3Rpb25cbiAgICBjb25zdCBtYWluRGlyID0gZ2V0TWFpbkRpcihcbiAgICAgIGZseW91dFNpemUsXG4gICAgICBpZGVhbERpcmVjdGlvbixcbiAgICAgIHRyaWdnZXJSZWN0LFxuICAgICAgd2luZG93U2l6ZVxuICAgICk7XG5cbiAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIHRoZSBtYWluIGRpcmVjdGlvbiwgY2hvc2UgZnJvbSAzIGNhcmV0IHBsYWNlbWVudHMgZm9yIHRoYXQgZGlyZWN0aW9uXG4gICAgY29uc3Qgc3ViRGlyID0gZ2V0U3ViRGlyKGZseW91dFNpemUsIG1haW5EaXIsIHRyaWdnZXJSZWN0LCB3aW5kb3dTaXplKTtcblxuICAgIC8vIEdldHMgdGhlIGJhc2Ugb2Zmc2V0IHRoYXQgcG9zaXRpb25zIHRoZSBmbHlvdXQgYmFzZWQgb24gdGhlIG1haW4gZGlyZWN0aW9uIG9ubHlcbiAgICBjb25zdCBiYXNlID0gYmFzZU9mZnNldHMoXG4gICAgICByZWxhdGl2ZU9mZnNldCxcbiAgICAgIGZseW91dFNpemUsXG4gICAgICBtYWluRGlyLFxuICAgICAgdHJpZ2dlclJlY3QsXG4gICAgICB3aW5kb3dTaXplXG4gICAgKTtcblxuICAgIC8vIEdldHMgdGhlIGVkZ2Ugc2hpZnRzIGZvciB0aGUgZmx5b3V0XG4gICAgY29uc3QgZWRnZVNoaWZ0cyA9IGNhbGNFZGdlU2hpZnRzKHN1YkRpciwgdHJpZ2dlclJlY3QsIHdpbmRvd1NpemUpO1xuXG4gICAgLy8gQWRqdXN0cyBmb3IgdGhlIHN1YmRpcmVjdGlvbiBvZiB0aGUgY2FyZXRcbiAgICBjb25zdCB7IGZseW91dE9mZnNldCwgY2FyZXRPZmZzZXQgfSA9IGFkanVzdE9mZnNldHMoXG4gICAgICBiYXNlLFxuICAgICAgZWRnZVNoaWZ0cyxcbiAgICAgIGZseW91dFNpemUsXG4gICAgICBtYWluRGlyLFxuICAgICAgc3ViRGlyLFxuICAgICAgdHJpZ2dlclJlY3RcbiAgICApO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjYXJldE9mZnNldCxcbiAgICAgIGZseW91dE9mZnNldCxcbiAgICAgIG1haW5EaXIsXG4gICAgfSk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgYmdDb2xvciwgY2FyZXQsIGNoaWxkcmVuLCB3aWR0aCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGNhcmV0T2Zmc2V0LCBmbHlvdXRPZmZzZXQsIG1haW5EaXIgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAvLyBOZWVkZWQgdG8gcHJldmVudCBVSSB0aHJhc2hpbmdcbiAgICBjb25zdCB2aXNpYmlsaXR5ID0gbWFpbkRpciA9PT0gbnVsbCA/ICdoaWRkZW4nIDogJ3Zpc2libGUnO1xuICAgIGNvbnN0IGJhY2tncm91bmQgPSBgJHtiZ0NvbG9yfUJnYDtcbiAgICBjb25zdCBzdHJva2UgPSBiZ0NvbG9yID09PSAnd2hpdGUnID8gJyNlZmVmZWYnIDogbnVsbDtcbiAgICBjb25zdCBib3JkZXJDb2xvciA9IGJnQ29sb3IgPT09ICd3aGl0ZScgPyAnbGlnaHRHcmF5JyA6IGJnQ29sb3I7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5jb250YWluZXJ9XG4gICAgICAgIHN0eWxlPXt7IHN0cm9rZSwgdmlzaWJpbGl0eSwgLi4uZmx5b3V0T2Zmc2V0IH19XG4gICAgICA+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoXG4gICAgICAgICAgICBjb2xvcnNbYmFja2dyb3VuZF0sXG4gICAgICAgICAgICBjb2xvcnNbYm9yZGVyQ29sb3JdLFxuICAgICAgICAgICAgc3R5bGVzLmNvbnRlbnRzLFxuICAgICAgICAgICAgc3R5bGVzLm1heERpbWVuc2lvbnMsXG4gICAgICAgICAgICB3aWR0aCAhPT0gbnVsbCAmJiBzdHlsZXMubWluRGltZW5zaW9uc1xuICAgICAgICAgICl9XG4gICAgICAgICAgcmVmPXt0aGlzLmZseW91dH1cbiAgICAgICAgICB0YWJJbmRleD17LTF9XG4gICAgICAgID5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoXG4gICAgICAgICAgICAgIHN0eWxlcy5pbm5lckNvbnRlbnRzLFxuICAgICAgICAgICAgICBzdHlsZXMubWF4RGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgd2lkdGggIT09IG51bGwgJiYgc3R5bGVzLm1pbkRpbWVuc2lvbnNcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICBzdHlsZT17eyB3aWR0aCB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICB7Y2FyZXQgJiYgKFxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoY29sb3JzW2JnQ29sb3JdLCBzdHlsZXMuY2FyZXQpfVxuICAgICAgICAgICAgICBzdHlsZT17eyAuLi5jYXJldE9mZnNldCB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8Q2FyZXQgZGlyZWN0aW9uPXttYWluRGlyfSAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hpbGRyZW46IFJlYWN0Lk5vZGUsXG4gIG9uQ2xpY2s/OiAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHZvaWQsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3V0c2lkZUV2ZW50QmVoYXZpb3IgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHM+IHtcbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrRXZlbnQsIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tFdmVudCwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIGhhbmRsZUNsaWNrRXZlbnQgPSAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZmluZC1kb20tbm9kZVxuICAgIGNvbnN0IGVsID0gZmluZERPTU5vZGUodGhpcyk7XG4gICAgaWYgKFxuICAgICAgIXRoaXMucHJvcHMub25DbGljayB8fFxuICAgICAgIWVsIHx8XG4gICAgICAoZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgTm9kZSAmJiBlbC5jb250YWlucyhldmVudC50YXJnZXQpKVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ29udGVudHMgZnJvbSAnLi9Db250ZW50cy5qcyc7XG5pbXBvcnQgT3V0c2lkZUV2ZW50QmVoYXZpb3IgZnJvbSAnLi9iZWhhdmlvcnMvT3V0c2lkZUV2ZW50QmVoYXZpb3IuanMnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgYW5jaG9yOiBIVE1MRWxlbWVudCxcbiAgYmdDb2xvcjogJ2JsdWUnIHwgJ2RhcmtHcmF5JyB8ICdvcmFuZ2UnIHwgJ3doaXRlJyxcbiAgY2FyZXQ/OiBib29sZWFuLFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGlkZWFsRGlyZWN0aW9uPzogJ3VwJyB8ICdyaWdodCcgfCAnZG93bicgfCAnbGVmdCcsXG4gIG9uRGlzbWlzczogKCkgPT4gdm9pZCxcbiAgcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yOiBib29sZWFuLFxuICBzaG91bGRGb2N1cz86IGJvb2xlYW4sXG4gIHNpemU6ICd4cycgfCAnc20nIHwgJ21kJyB8ICdsZycgfCAneGwnIHwgbnVtYmVyIHwgbnVsbCxcbnx9O1xuXG5jb25zdCBTSVpFX1dJRFRIX01BUCA9IHtcbiAgeHM6IDE4NSxcbiAgc206IDIzMCxcbiAgbWQ6IDI4NCxcbiAgbGc6IDMyMCxcbiAgeGw6IDM3NSxcbn07XG5cbmNvbnN0IEVTQ0FQRV9LRVlfQ09ERSA9IDI3O1xuXG50eXBlIENsaWVudFJlY3QgPSB7XG4gIGJvdHRvbTogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgbGVmdDogbnVtYmVyLFxuICByaWdodDogbnVtYmVyLFxuICB0b3A6IG51bWJlcixcbiAgd2lkdGg6IG51bWJlcixcbn07XG5cbnR5cGUgU3RhdGUgPSB7fFxuICByZWxhdGl2ZU9mZnNldDoge1xuICAgIHg6IG51bWJlcixcbiAgICB5OiBudW1iZXIsXG4gIH0sXG4gIHRyaWdnZXJCb3VuZGluZ1JlY3Q6IENsaWVudFJlY3QsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udHJvbGxlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAvLyBEZWZhdWx0IHNpemUgb25seSBhcHBsaWVzIHdoZW4gc2l6ZSBpcyBvbWl0dGVkLFxuICAgIC8vIGlmIHBhc3NlZCBhcyBudWxsIGl0IHdpbGwgcmVtYWluIG51bGxcbiAgICBzaXplOiAnc20nLFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIHJlbGF0aXZlT2Zmc2V0OiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICB9LFxuICAgIHRyaWdnZXJCb3VuZGluZ1JlY3Q6IHtcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIHdpZHRoOiAwLFxuICAgIH0sXG4gIH07XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51cGRhdGVUcmlnZ2VyUmVjdCh0aGlzLnByb3BzKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzOiBQcm9wcykge1xuICAgIHRoaXMudXBkYXRlVHJpZ2dlclJlY3QobmV4dFByb3BzKTtcbiAgfVxuXG4gIGhhbmRsZUtleURvd24gPSAoZXZlbnQ6IHsga2V5Q29kZTogbnVtYmVyIH0pID0+IHtcbiAgICBjb25zdCB7IG9uRGlzbWlzcyB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gRVNDQVBFX0tFWV9DT0RFKSB7XG4gICAgICBvbkRpc21pc3MoKTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlUGFnZUNsaWNrID0gKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgIGNvbnN0IHsgYW5jaG9yLCBvbkRpc21pc3MgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIE5vZGUgJiYgIWFuY2hvci5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICBvbkRpc21pc3MoKTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgIHRoaXMudXBkYXRlVHJpZ2dlclJlY3QodGhpcy5wcm9wcyk7XG4gIH07XG5cbiAgdXBkYXRlVHJpZ2dlclJlY3QgPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBhbmNob3IsIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvciB9ID0gcHJvcHM7XG4gICAgbGV0IHRyaWdnZXJCb3VuZGluZ1JlY3Q7XG4gICAgbGV0IHJlbGF0aXZlT2Zmc2V0O1xuICAgIGlmIChhbmNob3IpIHtcbiAgICAgIHRyaWdnZXJCb3VuZGluZ1JlY3QgPSBhbmNob3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIC8vIE5lZWRlZCBmb3IgY29ycmVjdCBwb3NpdGlvbmluZyB3aXRoaW4gQ29udGVudHMuanNcbiAgICAgIHJlbGF0aXZlT2Zmc2V0ID0ge1xuICAgICAgICB4OiBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3JcbiAgICAgICAgICA/IHRyaWdnZXJCb3VuZGluZ1JlY3QubGVmdCAtIGFuY2hvci5vZmZzZXRMZWZ0XG4gICAgICAgICAgOiAwLFxuICAgICAgICB5OiBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3JcbiAgICAgICAgICA/IHRyaWdnZXJCb3VuZGluZ1JlY3QudG9wIC0gYW5jaG9yLm9mZnNldFRvcFxuICAgICAgICAgIDogMCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IHJlbGF0aXZlT2Zmc2V0LCB0cmlnZ2VyQm91bmRpbmdSZWN0IH0pO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBiZ0NvbG9yLFxuICAgICAgY2FyZXQsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGlkZWFsRGlyZWN0aW9uLFxuICAgICAgcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yLFxuICAgICAgc2hvdWxkRm9jdXMsXG4gICAgICBzaXplLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgcmVsYXRpdmVPZmZzZXQsIHRyaWdnZXJCb3VuZGluZ1JlY3QgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCB3aWR0aCA9IHR5cGVvZiBzaXplID09PSAnc3RyaW5nJyA/IFNJWkVfV0lEVEhfTUFQW3NpemVdIDogc2l6ZTtcblxuICAgIHJldHVybiAoXG4gICAgICA8T3V0c2lkZUV2ZW50QmVoYXZpb3Igb25DbGljaz17dGhpcy5oYW5kbGVQYWdlQ2xpY2t9PlxuICAgICAgICA8Q29udGVudHNcbiAgICAgICAgICBiZ0NvbG9yPXtiZ0NvbG9yfVxuICAgICAgICAgIGNhcmV0PXtjYXJldH1cbiAgICAgICAgICBpZGVhbERpcmVjdGlvbj17aWRlYWxEaXJlY3Rpb259XG4gICAgICAgICAgb25LZXlEb3duPXt0aGlzLmhhbmRsZUtleURvd259XG4gICAgICAgICAgb25SZXNpemU9e3RoaXMuaGFuZGxlUmVzaXplfVxuICAgICAgICAgIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcj17cG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yfVxuICAgICAgICAgIHJlbGF0aXZlT2Zmc2V0PXtyZWxhdGl2ZU9mZnNldH1cbiAgICAgICAgICBzaG91bGRGb2N1cz17c2hvdWxkRm9jdXN9XG4gICAgICAgICAgdHJpZ2dlclJlY3Q9e3RyaWdnZXJCb3VuZGluZ1JlY3R9XG4gICAgICAgICAgd2lkdGg9e3dpZHRofVxuICAgICAgICA+XG4gICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L0NvbnRlbnRzPlxuICAgICAgPC9PdXRzaWRlRXZlbnRCZWhhdmlvcj5cbiAgICApO1xuICB9XG59XG5cbkNvbnRyb2xsZXIucHJvcFR5cGVzID0ge1xuICBhbmNob3I6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgY29udGFpbnM6IFByb3BUeXBlcy5mdW5jLFxuICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gIH0pLFxuICBiZ0NvbG9yOiBQcm9wVHlwZXMub25lT2YoWydibHVlJywgJ2RhcmtHcmF5JywgJ29yYW5nZScsICd3aGl0ZSddKSxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBpZGVhbERpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsndXAnLCAncmlnaHQnLCAnZG93bicsICdsZWZ0J10pLFxuICBvbkRpc21pc3M6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcjogUHJvcFR5cGVzLmJvb2wsXG4gIHNob3VsZEZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgUHJvcFR5cGVzLm51bWJlcixcbiAgICBQcm9wVHlwZXMub25lT2YoWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddKSwgLy8gZGVmYXVsdDogc21cbiAgXSksXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ29udHJvbGxlciBmcm9tICcuL0NvbnRyb2xsZXIuanMnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgYW5jaG9yOiA/SFRNTEVsZW1lbnQsXG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgaWRlYWxEaXJlY3Rpb24/OiAndXAnIHwgJ3JpZ2h0JyB8ICdkb3duJyB8ICdsZWZ0JyxcbiAgb25EaXNtaXNzOiAoKSA9PiB2b2lkLFxuICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3I/OiBib29sZWFuLFxuICBjb2xvcj86ICdibHVlJyB8ICdvcmFuZ2UnIHwgJ3doaXRlJyB8ICdkYXJrR3JheScsXG4gIHNob3VsZEZvY3VzPzogYm9vbGVhbixcbiAgc2l6ZT86ICd4cycgfCAnc20nIHwgJ21kJyB8ICdsZycgfCAneGwnIHwgbnVtYmVyLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZseW91dChwcm9wczogUHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGFuY2hvcixcbiAgICBjaGlsZHJlbixcbiAgICBpZGVhbERpcmVjdGlvbixcbiAgICBvbkRpc21pc3MsXG4gICAgcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yID0gdHJ1ZSxcbiAgICBjb2xvciA9ICd3aGl0ZScsXG4gICAgc2hvdWxkRm9jdXMgPSB0cnVlLFxuICAgIHNpemUsXG4gIH0gPSBwcm9wcztcblxuICBpZiAoIWFuY2hvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8Q29udHJvbGxlclxuICAgICAgYW5jaG9yPXthbmNob3J9XG4gICAgICBiZ0NvbG9yPXtjb2xvcn1cbiAgICAgIGlkZWFsRGlyZWN0aW9uPXtpZGVhbERpcmVjdGlvbn1cbiAgICAgIG9uRGlzbWlzcz17b25EaXNtaXNzfVxuICAgICAgcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yPXtwb3NpdGlvblJlbGF0aXZlVG9BbmNob3J9XG4gICAgICBzaG91bGRGb2N1cz17c2hvdWxkRm9jdXN9XG4gICAgICBzaXplPXtzaXplfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0NvbnRyb2xsZXI+XG4gICk7XG59XG5cbkZseW91dC5wcm9wVHlwZXMgPSB7XG4gIGFuY2hvcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBjb250YWluczogUHJvcFR5cGVzLmZ1bmMsXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgfSksXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgaWRlYWxEaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ3VwJywgJ3JpZ2h0JywgJ2Rvd24nLCAnbGVmdCddKSxcbiAgb25EaXNtaXNzOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3I6IFByb3BUeXBlcy5ib29sLFxuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsnYmx1ZScsICdvcmFuZ2UnLCAnd2hpdGUnLCAnZGFya0dyYXknXSksXG4gIHNpemU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgIFByb3BUeXBlcy5udW1iZXIsXG4gICAgUHJvcFR5cGVzLm9uZU9mKFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSksIC8vIGRlZmF1bHQ6IHNtXG4gIF0pLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0dyb3VwQXZhdGFyLmNzcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBJbWFnZSBmcm9tICcuL0ltYWdlLmpzJztcbmltcG9ydCB0eXBvZ3JhcGh5IGZyb20gJy4vVHlwb2dyYXBoeS5jc3MnO1xuXG5mdW5jdGlvbiB6aXAoYSwgYikge1xuICByZXR1cm4gYS5tYXAoKGl0ZW0sIGlkeCkgPT4gW2l0ZW0sIGJbaWR4XV0pO1xufVxuXG5jb25zdCBCT1JERVJfV0lEVEggPSAyO1xuXG5jb25zdCBBVkFUQVJfU0laRVMgPSB7XG4gIHNtOiAyNCxcbiAgbWQ6IDQwLFxuICBsZzogNzIsXG59O1xuXG50eXBlIFByb3BzID0ge3xcbiAgY29sbGFib3JhdG9yczogQXJyYXk8e3xcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgc3JjPzogc3RyaW5nLFxuICB8fT4sXG4gIG91dGxpbmU/OiBib29sZWFuLFxuICBzaXplPzogJ3NtJyB8ICdtZCcgfCAnbGcnLFxufH07XG5cbmNvbnN0IGF2YXRhckxheW91dCA9IChuLCBzaXplKSA9PiB7XG4gIHN3aXRjaCAobikge1xuICAgIGNhc2UgMDpcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7IHRvcDogMCwgbGVmdDogMCwgd2lkdGg6IHNpemUsIGhlaWdodDogc2l6ZSwgdGV4dExheW91dDogJ2NlbnRlcicgfSxcbiAgICAgIF07XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHdpZHRoOiBgY2FsYyg1MCUgLSAke0JPUkRFUl9XSURUSCAvIDJ9cHgpYCxcbiAgICAgICAgICBoZWlnaHQ6IHNpemUsXG4gICAgICAgICAgdGV4dExheW91dDogJ2NlbnRlcicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogYGNhbGMoNTAlICsgJHtCT1JERVJfV0lEVEggLyAyfXB4KWAsXG4gICAgICAgICAgd2lkdGg6IGBjYWxjKDUwJSAtICR7Qk9SREVSX1dJRFRIIC8gMn1weClgLFxuICAgICAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgICAgICB0ZXh0TGF5b3V0OiAnY2VudGVyJyxcbiAgICAgICAgfSxcbiAgICAgIF07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB3aWR0aDogYGNhbGMoNTAlIC0gJHtCT1JERVJfV0lEVEggLyAyfXB4KWAsXG4gICAgICAgICAgaGVpZ2h0OiBzaXplLFxuICAgICAgICAgIHRleHRMYXlvdXQ6ICdjZW50ZXInLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IGBjYWxjKDUwJSArICR7Qk9SREVSX1dJRFRIIC8gMn1weClgLFxuICAgICAgICAgIHdpZHRoOiAnY2FsYyg1MCUpJyxcbiAgICAgICAgICBoZWlnaHQ6IGBjYWxjKDUwJSAtICR7Qk9SREVSX1dJRFRIIC8gMn1weClgLFxuICAgICAgICAgIHRleHRMYXlvdXQ6ICd0b3BMZWZ0JyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHRvcDogYGNhbGMoNTAlICsgJHtCT1JERVJfV0lEVEggLyAyfXB4KWAsXG4gICAgICAgICAgbGVmdDogYGNhbGMoNTAlICsgJHtCT1JERVJfV0lEVEggLyAyfXB4KWAsXG4gICAgICAgICAgd2lkdGg6ICdjYWxjKDUwJSknLFxuICAgICAgICAgIGhlaWdodDogYGNhbGMoNTAlIC0gJHtCT1JERVJfV0lEVEggLyAyfXB4KWAsXG4gICAgICAgICAgdGV4dExheW91dDogJ2JvdHRvbUxlZnQnLFxuICAgICAgICB9LFxuICAgICAgXTtcbiAgfVxufTtcblxuY29uc3QgZGVnVG9SYWQgPSBkZWcgPT4gZGVnICogKE1hdGguUEkgLyAxODApO1xuXG5jb25zdCBEZWZhdWx0QXZhdGFyID0gKHByb3BzOiB7fFxuICBzaXplOiBzdHJpbmcgfCBudW1iZXIsXG4gIG5hbWU6IHN0cmluZyxcbiAgdGV4dExheW91dDogJ2NlbnRlcicgfCAndG9wTGVmdCcgfCAnYm90dG9tTGVmdCcsXG58fSkgPT4ge1xuICBjb25zdCB7IHNpemUsIG5hbWUsIHRleHRMYXlvdXQgfSA9IHByb3BzO1xuXG4gIGNvbnN0IHF1YXJ0ZXJQYWRkaW5nID0gYGNhbGMoJHtNYXRoLnNpbihkZWdUb1JhZCg0NSkpfSAqICgke3NpemV9KSAvIDIpYDtcblxuICBjb25zdCBpbml0aWFsID0gKFxuICAgIDxzdmdcbiAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgICB2aWV3Qm94PVwiLTUwIC01MCAxMDAgMTAwXCJcbiAgICAgIHZlcnNpb249XCIxLjFcIlxuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIlxuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgPlxuICAgICAgPHRpdGxlPntuYW1lfTwvdGl0bGU+XG4gICAgICA8dGV4dFxuICAgICAgICBmb250U2l6ZT1cIjUwcHhcIlxuICAgICAgICBmaWxsPVwiI2ZmZlwiXG4gICAgICAgIGRvbWluYW50QmFzZWxpbmU9XCJjZW50cmFsXCJcbiAgICAgICAgdGV4dEFuY2hvcj1cIm1pZGRsZVwiXG4gICAgICAgIGNsYXNzTmFtZT17W1xuICAgICAgICAgIHR5cG9ncmFwaHkuYW50aWFsaWFzZWQsXG4gICAgICAgICAgdHlwb2dyYXBoeS5zYW5zU2VyaWYsXG4gICAgICAgICAgdHlwb2dyYXBoeS5sZWFkaW5nU21hbGwsXG4gICAgICAgICAgdHlwb2dyYXBoeS5mb250V2VpZ2h0Qm9sZCxcbiAgICAgICAgXS5qb2luKCcgJyl9XG4gICAgICA+XG4gICAgICAgIHtuYW1lID8gWy4uLm5hbWVdWzBdLnRvVXBwZXJDYXNlKCkgOiAnJ31cbiAgICAgIDwvdGV4dD5cbiAgICA8L3N2Zz5cbiAgKTtcbiAgc3dpdGNoICh0ZXh0TGF5b3V0KSB7XG4gICAgY2FzZSAnYm90dG9tTGVmdCc6XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Qm94XG4gICAgICAgICAgYXJpYS1sYWJlbD17bmFtZX1cbiAgICAgICAgICBjb2xvcj1cImdyYXlcIlxuICAgICAgICAgIGhlaWdodD1cIjEwMCVcIlxuICAgICAgICAgIGRpc3BsYXk9XCJmbGV4XCJcbiAgICAgICAgICBhbGlnbkl0ZW1zPVwiZW5kXCJcbiAgICAgICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7XG4gICAgICAgICAgICBfX3N0eWxlOiB7XG4gICAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IHF1YXJ0ZXJQYWRkaW5nLFxuICAgICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IHF1YXJ0ZXJQYWRkaW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAge2luaXRpYWx9XG4gICAgICAgIDwvQm94PlxuICAgICAgKTtcbiAgICBjYXNlICd0b3BMZWZ0JzpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxCb3hcbiAgICAgICAgICBhcmlhLWxhYmVsPXtuYW1lfVxuICAgICAgICAgIGNvbG9yPVwiZ3JheVwiXG4gICAgICAgICAgaGVpZ2h0PVwiMTAwJVwiXG4gICAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICAgIGFsaWduSXRlbXM9XCJzdGFydFwiXG4gICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17e1xuICAgICAgICAgICAgX19zdHlsZToge1xuICAgICAgICAgICAgICBwYWRkaW5nVG9wOiBxdWFydGVyUGFkZGluZyxcbiAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiBxdWFydGVyUGFkZGluZyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIHtpbml0aWFsfVxuICAgICAgICA8L0JveD5cbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxCb3hcbiAgICAgICAgICBhcmlhLWxhYmVsPXtuYW1lfVxuICAgICAgICAgIGNvbG9yPVwiZ3JheVwiXG4gICAgICAgICAgaGVpZ2h0PVwiMTAwJVwiXG4gICAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICAgIGFsaWduSXRlbXM9XCJjZW50ZXJcIlxuICAgICAgICAgIGp1c3RpZnlDb250ZW50PVwiY2VudGVyXCJcbiAgICAgICAgPlxuICAgICAgICAgIHtpbml0aWFsfVxuICAgICAgICA8L0JveD5cbiAgICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEdyb3VwQXZhdGFyKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7IGNvbGxhYm9yYXRvcnMsIG91dGxpbmUsIHNpemUgfSA9IHByb3BzO1xuICBjb25zdCBhdmF0YXJXaWR0aCA9IHNpemUgPyBBVkFUQVJfU0laRVNbc2l6ZV0gOiAnMTAwJSc7XG4gIGNvbnN0IGF2YXRhckhlaWdodCA9IHNpemUgPyBBVkFUQVJfU0laRVNbc2l6ZV0gOiAnJztcbiAgY29uc3QgcG9zaXRpb25zID0gYXZhdGFyTGF5b3V0KGNvbGxhYm9yYXRvcnMubGVuZ3RoLCBhdmF0YXJXaWR0aCk7XG4gIHJldHVybiAoXG4gICAgPEJveFxuICAgICAgY29sb3I9XCJ3aGl0ZVwiXG4gICAgICBvdmVyZmxvdz1cImhpZGRlblwiXG4gICAgICBzaGFwZT1cImNpcmNsZVwiXG4gICAgICB3aWR0aD17YXZhdGFyV2lkdGh9XG4gICAgICBoZWlnaHQ9e2F2YXRhckhlaWdodH1cbiAgICAgIHBvc2l0aW9uPVwicmVsYXRpdmVcIlxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17e1xuICAgICAgICBfX3N0eWxlOiB7XG4gICAgICAgICAgLi4uKG91dGxpbmUgPyB7IGJveFNoYWRvdzogJzAgMCAwIDJweCAjZmZmJyB9IDoge30pLFxuICAgICAgICAgIC8vIHdpbGxDaGFuZ2U6IHRyYW5zZm9ybSBmaXhlcyBhIHN0cmFuZ2UgYmVoYXZpb3Igd2hlcmUgdGhlIGJvcmRlciBvZiB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAvLyBhcmUgbm90IHByb3Blcmx5IHRyaW1tZWQgZXZlbiB0aG91Z2ggb3ZlcmZsb3c6IGhpZGRlbiBpcyBzZXRcbiAgICAgICAgICB3aWxsQ2hhbmdlOiAndHJhbnNmb3JtJyxcbiAgICAgICAgfSxcbiAgICAgIH19XG4gICAgPlxuICAgICAgPEJveCBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7IF9fc3R5bGU6IHsgcGFkZGluZ0JvdHRvbTogJzEwMCUnIH0gfX0gLz5cbiAgICAgIHt6aXAocG9zaXRpb25zLCBjb2xsYWJvcmF0b3JzKS5tYXAoXG4gICAgICAgIChbcG9zaXRpb24sIGNvbGxhYm9yYXRvciA9IHsgbmFtZTogJycsIHNyYzogdW5kZWZpbmVkIH1dLCBpZHgpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHRvcCwgbGVmdCwgdGV4dExheW91dCB9ID0gcG9zaXRpb247XG4gICAgICAgICAgY29uc3QgeyBuYW1lLCBzcmMgfSA9IGNvbGxhYm9yYXRvcjtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEJveFxuICAgICAgICAgICAgICBrZXk9e2lkeH1cbiAgICAgICAgICAgICAgcG9zaXRpb249XCJhYnNvbHV0ZVwiXG4gICAgICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyB0b3AsIGxlZnQgfSB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7c3JjID8gKFxuICAgICAgICAgICAgICAgIDxJbWFnZVxuICAgICAgICAgICAgICAgICAgYWx0PXtuYW1lfVxuICAgICAgICAgICAgICAgICAgY29sb3I9XCIjRUZFRkVGXCJcbiAgICAgICAgICAgICAgICAgIHNyYz17c3JjfVxuICAgICAgICAgICAgICAgICAgbmF0dXJhbFdpZHRoPXsxfVxuICAgICAgICAgICAgICAgICAgbmF0dXJhbEhlaWdodD17MX1cbiAgICAgICAgICAgICAgICAgIGZpdD1cImNvdmVyXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgIDxEZWZhdWx0QXZhdGFyXG4gICAgICAgICAgICAgICAgICBuYW1lPXtuYW1lfVxuICAgICAgICAgICAgICAgICAgdGV4dExheW91dD17dGV4dExheW91dH1cbiAgICAgICAgICAgICAgICAgIHNpemU9e2hlaWdodH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLndhc2h9IC8+XG4gICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICApfVxuICAgIDwvQm94PlxuICApO1xufVxuXG5Hcm91cEF2YXRhci5wcm9wVHlwZXMgPSB7XG4gIGNvbGxhYm9yYXRvcnM6IFByb3BUeXBlcy5hcnJheU9mKFxuICAgIFByb3BUeXBlcy5leGFjdCh7XG4gICAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgICBzcmM6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgfSlcbiAgKS5pc1JlcXVpcmVkLFxuICBvdXRsaW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnc20nLCAnbWQnLCAnbGcnXSksXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgY29sb3JzIGZyb20gJy4vQ29sb3JzLmNzcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vSGVhZGluZy5jc3MnO1xuaW1wb3J0IHR5cG9ncmFwaHkgZnJvbSAnLi9UeXBvZ3JhcGh5LmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY2Nlc3NpYmlsaXR5TGV2ZWw/OiAxIHwgMiB8IDMgfCA0IHwgNSB8IDYsXG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgY29sb3I/OlxuICAgIHwgJ2JsdWUnXG4gICAgfCAnZGFya0dyYXknXG4gICAgfCAnZWdncGxhbnQnXG4gICAgfCAnZ3JheSdcbiAgICB8ICdncmVlbidcbiAgICB8ICdsaWdodEdyYXknXG4gICAgfCAnbWFyb29uJ1xuICAgIHwgJ21pZG5pZ2h0J1xuICAgIHwgJ25hdnknXG4gICAgfCAnb2xpdmUnXG4gICAgfCAnb3JhbmdlJ1xuICAgIHwgJ29yY2hpZCdcbiAgICB8ICdwaW5lJ1xuICAgIHwgJ3B1cnBsZSdcbiAgICB8ICdyZWQnXG4gICAgfCAnd2F0ZXJtZWxvbidcbiAgICB8ICd3aGl0ZScsXG4gIGlkPzogc3RyaW5nLFxuICBsZ1NpemU/OiAneHMnIHwgJ3NtJyB8ICdtZCcgfCAnbGcnIHwgJ3hsJyxcbiAgbWRTaXplPzogJ3hzJyB8ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCcsXG4gIG92ZXJmbG93PzogJ25vcm1hbCcgfCAnYnJlYWtXb3JkJyxcbiAgc2l6ZT86ICd4cycgfCAnc20nIHwgJ21kJyB8ICdsZycgfCAneGwnLFxuICBzbVNpemU/OiAneHMnIHwgJ3NtJyB8ICdtZCcgfCAnbGcnIHwgJ3hsJyxcbiAgdHJ1bmNhdGU/OiBib29sZWFuLFxufH07XG5cbmNvbnN0IGRlZmF1bHRIZWFkaW5nTGV2ZWxzID0ge1xuICB4czogNSxcbiAgc206IDQsXG4gIG1kOiAzLFxuICBsZzogMixcbiAgeGw6IDEsXG59O1xuXG5jb25zdCBTSVpFX1NDQUxFOiB7IFtzaXplOiA/c3RyaW5nXTogbnVtYmVyIH0gPSB7XG4gIHhzOiAxLFxuICBzbTogMixcbiAgbWQ6IDMsXG4gIGxnOiA0LFxuICB4bDogNSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhlYWRpbmcocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBhY2Nlc3NpYmlsaXR5TGV2ZWwsXG4gICAgY2hpbGRyZW4sXG4gICAgY29sb3IgPSAnZGFya0dyYXknLFxuICAgIGlkID0gbnVsbCxcbiAgICBsZ1NpemUsXG4gICAgbWRTaXplLFxuICAgIG92ZXJmbG93ID0gJ2JyZWFrV29yZCcsXG4gICAgc2l6ZSA9ICdtZCcsXG4gICAgc21TaXplLFxuICAgIHRydW5jYXRlID0gZmFsc2UsXG4gIH0gPSBwcm9wcztcblxuICBjb25zdCBjcyA9IGN4KFxuICAgIHN0eWxlcy5IZWFkaW5nLFxuICAgIHN0eWxlc1tgZm9udFNpemUke1NJWkVfU0NBTEVbc2l6ZV19YF0sXG4gICAgc21TaXplICYmIHN0eWxlc1tgc21Gb250U2l6ZSR7U0laRV9TQ0FMRVtzbVNpemVdfWBdLFxuICAgIG1kU2l6ZSAmJiBzdHlsZXNbYG1kRm9udFNpemUke1NJWkVfU0NBTEVbbWRTaXplXX1gXSxcbiAgICBsZ1NpemUgJiYgc3R5bGVzW2BsZ0ZvbnRTaXplJHtTSVpFX1NDQUxFW2xnU2l6ZV19YF0sXG4gICAgY29sb3JzW2NvbG9yXSxcbiAgICBvdmVyZmxvdyA9PT0gJ2JyZWFrV29yZCcgJiYgdHlwb2dyYXBoeS5icmVha1dvcmQsXG4gICAgdHJ1bmNhdGUgJiYgdHlwb2dyYXBoeS50cnVuY2F0ZVxuICApO1xuXG4gIGNvbnN0IGhlYWRpbmdMZXZlbCA9IGFjY2Vzc2liaWxpdHlMZXZlbCB8fCBkZWZhdWx0SGVhZGluZ0xldmVsc1tzaXplXTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgYGgke2hlYWRpbmdMZXZlbH1gLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogY3MsXG4gICAgICBpZCxcbiAgICAgIC4uLih0cnVuY2F0ZSAmJiB0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnXG4gICAgICAgID8geyB0aXRsZTogY2hpbGRyZW4gfVxuICAgICAgICA6IG51bGwpLFxuICAgIH0sXG4gICAgY2hpbGRyZW5cbiAgKTtcbn1cblxuSGVhZGluZy5wcm9wVHlwZXMgPSB7XG4gIGFjY2Vzc2liaWxpdHlMZXZlbDogUHJvcFR5cGVzLm9uZU9mKFsxLCAyLCAzLCA0LCA1LCA2XSksXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ2JsdWUnLFxuICAgICdkYXJrR3JheScsXG4gICAgJ2VnZ3BsYW50JyxcbiAgICAnZ3JheScsXG4gICAgJ2dyZWVuJyxcbiAgICAnbGlnaHRHcmF5JyxcbiAgICAnbWFyb29uJyxcbiAgICAnbWlkbmlnaHQnLFxuICAgICduYXZ5JyxcbiAgICAnb2xpdmUnLFxuICAgICdvcmFuZ2UnLFxuICAgICdvcmNoaWQnLFxuICAgICdwaW5lJyxcbiAgICAncHVycGxlJyxcbiAgICAncmVkJyxcbiAgICAnd2F0ZXJtZWxvbicsXG4gICAgJ3doaXRlJyxcbiAgXSksXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBvdmVyZmxvdzogUHJvcFR5cGVzLm9uZU9mKFsnbm9ybWFsJywgJ2JyZWFrV29yZCddKSxcbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSksXG4gIHNtU2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSksXG4gIG1kU2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSksXG4gIGxnU2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSksXG4gIHRydW5jYXRlOiBQcm9wVHlwZXMuYm9vbCxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuL0ljb24uanMnO1xuaW1wb3J0IGljb25zIGZyb20gJy4vaWNvbnMvaW5kZXguanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1BvZy5jc3MnO1xuXG5jb25zdCBTSVpFX05BTUVfVE9fUElYRUwgPSB7XG4gIHhzOiAyNCxcbiAgc206IDMyLFxuICBtZDogNDAsXG4gIGxnOiA0OCxcbiAgeGw6IDU2LFxufTtcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFjdGl2ZT86IGJvb2xlYW4sXG4gIGJnQ29sb3I/OlxuICAgIHwgJ3RyYW5zcGFyZW50J1xuICAgIHwgJ3RyYW5zcGFyZW50RGFya0dyYXknXG4gICAgfCAnZ3JheSdcbiAgICB8ICdsaWdodEdyYXknXG4gICAgfCAnd2hpdGUnLFxuICBmb2N1c2VkPzogYm9vbGVhbixcbiAgaG92ZXJlZD86IGJvb2xlYW4sXG4gIGljb25Db2xvcj86ICdncmF5JyB8ICdkYXJrR3JheScgfCAncmVkJyB8ICdibHVlJyB8ICd3aGl0ZScsXG4gIGljb246ICRLZXlzPHR5cGVvZiBpY29ucz4sXG4gIHNpemU/OiAkS2V5czx0eXBlb2YgU0laRV9OQU1FX1RPX1BJWEVMPixcbnx9O1xuXG5jb25zdCBkZWZhdWx0SWNvbkJ1dHRvbkljb25Db2xvcnMgPSB7XG4gIHRyYW5zcGFyZW50OiAnZ3JheScsXG4gIGdyYXk6ICd3aGl0ZScsXG4gIGxpZ2h0R3JheTogJ2dyYXknLFxuICB3aGl0ZTogJ2dyYXknLFxuICB0cmFuc3BhcmVudERhcmtHcmF5OiAnd2hpdGUnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUG9nKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7XG4gICAgYWN0aXZlID0gZmFsc2UsXG4gICAgYmdDb2xvciA9ICd0cmFuc3BhcmVudCcsXG4gICAgZm9jdXNlZCA9IGZhbHNlLFxuICAgIGhvdmVyZWQgPSBmYWxzZSxcbiAgICBpY29uQ29sb3IgPSBkZWZhdWx0SWNvbkJ1dHRvbkljb25Db2xvcnNbYmdDb2xvcl0sXG4gICAgaWNvbixcbiAgICBzaXplID0gJ21kJyxcbiAgfSA9IHByb3BzO1xuXG4gIGNvbnN0IGljb25TaXplID0gU0laRV9OQU1FX1RPX1BJWEVMW3NpemVdIC8gMjtcblxuICBjb25zdCBpbmxpbmVTdHlsZSA9IHtcbiAgICBoZWlnaHQ6IFNJWkVfTkFNRV9UT19QSVhFTFtzaXplXSxcbiAgICB3aWR0aDogU0laRV9OQU1FX1RPX1BJWEVMW3NpemVdLFxuICB9O1xuXG4gIGNvbnN0IGNsYXNzZXMgPSBjbGFzc25hbWVzKHN0eWxlcy5wb2csIHN0eWxlc1tiZ0NvbG9yXSwge1xuICAgIFtzdHlsZXMuYWN0aXZlXTogYWN0aXZlLFxuICAgIFtzdHlsZXMuZm9jdXNlZF06IGZvY3VzZWQsXG4gICAgW3N0eWxlcy5ob3ZlcmVkXTogaG92ZXJlZCAmJiAhZm9jdXNlZCAmJiAhYWN0aXZlLFxuICB9KTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzfSBzdHlsZT17aW5saW5lU3R5bGV9PlxuICAgICAgPEJveCBzaGFwZT1cImNpcmNsZVwiPlxuICAgICAgICB7LypcbiAgICAgICAgICBXZSdyZSBleHBsaWNpdGx5IHNldHRpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgbGFiZWwgb24gdGhlIEljb24gc2luY2Ugd2VcbiAgICAgICAgICBhbHJlYWR5IGhhdmUgYW4gYXJpYS1sYWJlbCBvbiB0aGUgYnV0dG9uIGNvbnRhaW5lci5cbiAgICAgICAgICBUaGlzIGlzIHNpbWlsYXIgdG8gaGF2aW5nIGVtcHR5IGBhbHRgIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvYWNjZXNzaWJpbGl0eS10aXAtZW1wdHktYWx0LWF0dHJpYnV0ZXNcbiAgICAgICAgKi99XG4gICAgICAgIDxJY29uXG4gICAgICAgICAgYWNjZXNzaWJpbGl0eUxhYmVsPVwiXCJcbiAgICAgICAgICBjb2xvcj17aWNvbkNvbG9yfVxuICAgICAgICAgIGljb249e2ljb259XG4gICAgICAgICAgc2l6ZT17aWNvblNpemV9XG4gICAgICAgIC8+XG4gICAgICA8L0JveD5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuUG9nLnByb3BUeXBlcyA9IHtcbiAgYWN0aXZlOiBQcm9wVHlwZXMuYm9vbCxcbiAgYmdDb2xvcjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAndHJhbnNwYXJlbnQnLFxuICAgICd0cmFuc3BhcmVudERhcmtHcmF5JyxcbiAgICAnZ3JheScsXG4gICAgJ2xpZ2h0R3JheScsXG4gICAgJ3doaXRlJyxcbiAgXSksXG4gIGZvY3VzZWQ6IFByb3BUeXBlcy5ib29sLFxuICBob3ZlcmVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgaWNvbkNvbG9yOiBQcm9wVHlwZXMub25lT2YoWydncmF5JywgJ2RhcmtHcmF5JywgJ3JlZCcsICdibHVlJywgJ3doaXRlJ10pLFxuICBpY29uOiBQcm9wVHlwZXMub25lT2YoT2JqZWN0LmtleXMoaWNvbnMpKS5pc1JlcXVpcmVkLFxuICBzaXplOiBQcm9wVHlwZXMub25lT2YoT2JqZWN0LmtleXMoU0laRV9OQU1FX1RPX1BJWEVMKSksXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vSWNvbkJ1dHRvbi5jc3MnO1xuaW1wb3J0IGljb25zIGZyb20gJy4vaWNvbnMvaW5kZXguanMnO1xuaW1wb3J0IFBvZyBmcm9tICcuL1BvZy5qcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY2Nlc3NpYmlsaXR5RXhwYW5kZWQ/OiBib29sZWFuLFxuICBhY2Nlc3NpYmlsaXR5SGFzcG9wdXA/OiBib29sZWFuLFxuICBhY2Nlc3NpYmlsaXR5TGFiZWw6IHN0cmluZyxcbiAgYmdDb2xvcj86XG4gICAgfCAndHJhbnNwYXJlbnQnXG4gICAgfCAndHJhbnNwYXJlbnREYXJrR3JheSdcbiAgICB8ICdncmF5J1xuICAgIHwgJ2xpZ2h0R3JheSdcbiAgICB8ICd3aGl0ZScsXG4gIGljb25Db2xvcj86ICdncmF5JyB8ICdkYXJrR3JheScgfCAncmVkJyB8ICdibHVlJyB8ICd3aGl0ZScsXG4gIGljb246ICRLZXlzPHR5cGVvZiBpY29ucz4sXG4gIG9uQ2xpY2s/OiAoeyBldmVudDogU3ludGhldGljTW91c2VFdmVudDw+IH0pID0+IHZvaWQsXG4gIHNpemU/OiAneHMnIHwgJ3NtJyB8ICdtZCcgfCAnbGcnIHwgJ3hsJyxcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgYWN0aXZlOiBib29sZWFuLFxuICBmb2N1c2VkOiBib29sZWFuLFxuICBob3ZlcmVkOiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEljb25CdXR0b24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYWNjZXNzaWJpbGl0eUV4cGFuZGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBhY2Nlc3NpYmlsaXR5SGFzcG9wdXA6IFByb3BUeXBlcy5ib29sLFxuICAgIGFjY2Vzc2liaWxpdHlMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGJnQ29sb3I6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgICAndHJhbnNwYXJlbnQnLFxuICAgICAgJ3RyYW5zcGFyZW50RGFya0dyYXknLFxuICAgICAgJ2dyYXknLFxuICAgICAgJ2xpZ2h0R3JheScsXG4gICAgICAnd2hpdGUnLFxuICAgIF0pLFxuICAgIGljb246IFByb3BUeXBlcy5vbmVPZihPYmplY3Qua2V5cyhpY29ucykpLmlzUmVxdWlyZWQsXG4gICAgaWNvbkNvbG9yOiBQcm9wVHlwZXMub25lT2YoWydncmF5JywgJ2RhcmtHcmF5JywgJ3JlZCcsICdibHVlJywgJ3doaXRlJ10pLFxuICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10pLFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgZm9jdXNlZDogZmFsc2UsXG4gICAgaG92ZXJlZDogZmFsc2UsXG4gIH07XG5cbiAgaGFuZGxlQmx1ciA9ICgpID0+IHRoaXMuc2V0U3RhdGUoeyBmb2N1c2VkOiBmYWxzZSB9KTtcblxuICBoYW5kbGVGb2N1cyA9ICgpID0+IHRoaXMuc2V0U3RhdGUoeyBmb2N1c2VkOiB0cnVlIH0pO1xuXG4gIGhhbmRsZU1vdXNlRG93biA9ICgpID0+IHRoaXMuc2V0U3RhdGUoeyBhY3RpdmU6IHRydWUgfSk7XG5cbiAgaGFuZGxlTW91c2VFbnRlciA9ICgpID0+IHRoaXMuc2V0U3RhdGUoeyBob3ZlcmVkOiB0cnVlIH0pO1xuXG4gIGhhbmRsZU1vdXNlTGVhdmUgPSAoKSA9PiB0aGlzLnNldFN0YXRlKHsgYWN0aXZlOiBmYWxzZSwgaG92ZXJlZDogZmFsc2UgfSk7XG5cbiAgaGFuZGxlTW91c2VVcCA9ICgpID0+IHRoaXMuc2V0U3RhdGUoeyBhY3RpdmU6IGZhbHNlIH0pO1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBhY2Nlc3NpYmlsaXR5RXhwYW5kZWQsXG4gICAgICBhY2Nlc3NpYmlsaXR5SGFzcG9wdXAsXG4gICAgICBhY2Nlc3NpYmlsaXR5TGFiZWwsXG4gICAgICBiZ0NvbG9yLFxuICAgICAgaWNvbkNvbG9yLFxuICAgICAgaWNvbixcbiAgICAgIHNpemUsXG4gICAgICBvbkNsaWNrLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgeyBhY3RpdmUsIGZvY3VzZWQsIGhvdmVyZWQgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGJ1dHRvblxuICAgICAgICBhcmlhLWV4cGFuZGVkPXthY2Nlc3NpYmlsaXR5RXhwYW5kZWR9XG4gICAgICAgIGFyaWEtaGFzcG9wdXA9e2FjY2Vzc2liaWxpdHlIYXNwb3B1cH1cbiAgICAgICAgYXJpYS1sYWJlbD17YWNjZXNzaWJpbGl0eUxhYmVsfVxuICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5idXR0b259XG4gICAgICAgIG9uQmx1cj17dGhpcy5oYW5kbGVCbHVyfVxuICAgICAgICBvbkNsaWNrPXtldmVudCA9PiBvbkNsaWNrICYmIG9uQ2xpY2soeyBldmVudCB9KX1cbiAgICAgICAgb25Gb2N1cz17dGhpcy5oYW5kbGVGb2N1c31cbiAgICAgICAgb25Nb3VzZURvd249e3RoaXMuaGFuZGxlTW91c2VEb3dufVxuICAgICAgICBvbk1vdXNlRW50ZXI9e3RoaXMuaGFuZGxlTW91c2VFbnRlcn1cbiAgICAgICAgb25Nb3VzZUxlYXZlPXt0aGlzLmhhbmRsZU1vdXNlTGVhdmV9XG4gICAgICAgIG9uTW91c2VVcD17dGhpcy5oYW5kbGVNb3VzZVVwfVxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgID5cbiAgICAgICAgPFBvZ1xuICAgICAgICAgIGFjdGl2ZT17YWN0aXZlfVxuICAgICAgICAgIGJnQ29sb3I9e2JnQ29sb3J9XG4gICAgICAgICAgZm9jdXNlZD17Zm9jdXNlZH1cbiAgICAgICAgICBob3ZlcmVkPXtob3ZlcmVkfVxuICAgICAgICAgIGljb25Db2xvcj17aWNvbkNvbG9yfVxuICAgICAgICAgIGljb249e2ljb259XG4gICAgICAgICAgc2l6ZT17c2l6ZX1cbiAgICAgICAgLz5cbiAgICAgIDwvYnV0dG9uPlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0xhYmVsLmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGh0bWxGb3I6IHN0cmluZyxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMYWJlbChwcm9wczogUHJvcHMpIHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgaHRtbEZvciB9ID0gcHJvcHM7XG5cbiAgcmV0dXJuIChcbiAgICA8bGFiZWwgY2xhc3NOYW1lPXtzdHlsZXMubGFiZWx9IGh0bWxGb3I9e2h0bWxGb3J9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvbGFiZWw+XG4gICk7XG59XG5cbkxhYmVsLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBodG1sRm9yOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbjogUmVhY3QuTm9kZSxcbnx9O1xudHlwZSBTdGF0ZSA9IHt8XG4gIG1vdW50ZWQ6IGJvb2xlYW4sXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRlID0ge1xuICAgIG1vdW50ZWQ6IGZhbHNlLFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KSB7XG4gICAgICB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdVc2luZyBMYXllciB3aXRob3V0IGRvY3VtZW50IHByZXNlbnQuIENoaWxkcmVuIHdpbGwgbm90IGJlIHJlbmRlcmVkLidcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBtb3VudGVkOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgIH1cbiAgfVxuXG4gIGVsOiBIVE1MRGl2RWxlbWVudDtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5tb3VudGVkICYmIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgdGhpcy5lbCk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE1hc2sgZnJvbSAnLi9NYXNrLmpzJztcblxuLypcbiAgTXVjaCBvZiB0aGUgbWF0aCBhbmQgdW5kZXJzdGFuZGluZyBhYm91dCB0aGlzIGNvbXBvbmVudCBjb21lcyBmcm9tIEB2amVhdXgnc1xuICBleGNlbGxlbnQgYmxvZyBwb3N0IG9uIGltYWdlIHJlc2l6aW5nLlxuXG4gIGh0dHA6Ly9ibG9nLnZqZXV4LmNvbS8yMDEzL2ltYWdlL2Nzcy1jb250YWluZXItYW5kLWNvdmVyLmh0bWxcblxuICBJIGhpZ2hseSByZWNvbW1lbmQgeW91IHJlYWQgdGhhdCBmaXJzdCBiZWZvcmUgY29udGludWluZyBvbiByZWFkaW5nLlxuKi9cblxuY29uc3QgYXNwZWN0UmF0aW8gPSAod2lkdGgsIGhlaWdodCkgPT4gd2lkdGggLyBoZWlnaHQ7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGNvbnRlbnRBc3BlY3RSYXRpbzogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgd2lkdGg6IG51bWJlcixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMZXR0ZXJib3goe1xuICBjaGlsZHJlbixcbiAgY29udGVudEFzcGVjdFJhdGlvLFxuICBoZWlnaHQsXG4gIHdpZHRoLFxufTogUHJvcHMpIHtcbiAgY29uc3Qgdmlld3BvcnRBc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvKHdpZHRoLCBoZWlnaHQpO1xuXG4gIGxldCBjb250ZW50SGVpZ2h0O1xuICBsZXQgY29udGVudFdpZHRoO1xuXG4gIGlmIChjb250ZW50QXNwZWN0UmF0aW8gPCB2aWV3cG9ydEFzcGVjdFJhdGlvKSB7XG4gICAgY29udGVudFdpZHRoID0gd2lkdGg7XG4gICAgY29udGVudEhlaWdodCA9IHdpZHRoIC8gY29udGVudEFzcGVjdFJhdGlvO1xuICB9IGVsc2Uge1xuICAgIGNvbnRlbnRXaWR0aCA9IGhlaWdodCAqIGNvbnRlbnRBc3BlY3RSYXRpbztcbiAgICBjb250ZW50SGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG5cbiAgY29uc3Qgb2Zmc2V0VG9wID0gKGNvbnRlbnRIZWlnaHQgLSBoZWlnaHQpIC8gLTI7XG4gIGNvbnN0IG9mZnNldExlZnQgPSAoY29udGVudFdpZHRoIC0gd2lkdGgpIC8gLTI7XG5cbiAgcmV0dXJuIChcbiAgICA8TWFzayB3aWR0aD17d2lkdGh9IGhlaWdodD17aGVpZ2h0fT5cbiAgICAgIDxkaXYgc3R5bGU9e3sgbWFyZ2luVG9wOiBvZmZzZXRUb3AsIG1hcmdpbkxlZnQ6IG9mZnNldExlZnQgfX0+XG4gICAgICAgIDxNYXNrIHdpZHRoPXtjb250ZW50V2lkdGh9IGhlaWdodD17Y29udGVudEhlaWdodH0+XG4gICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L01hc2s+XG4gICAgICA8L2Rpdj5cbiAgICA8L01hc2s+XG4gICk7XG59XG5cbkxldHRlcmJveC5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgY29udGVudEFzcGVjdFJhdGlvOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0xpbmsuY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgaHJlZjogc3RyaW5nLFxuICBpbmxpbmU/OiBib29sZWFuLFxuICBvbkNsaWNrPzogKHsgZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8PiB9KSA9PiB2b2lkLFxuICB0YXJnZXQ/OiBudWxsIHwgJ3NlbGYnIHwgJ2JsYW5rJyxcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgZW5hYmxlRm9jdXNTdHlsZXM6IGJvb2xlYW4sXG58fTtcblxuY29uc3QgVEFCX0tFWV9DT0RFID0gOTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluayBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcbiAgICBocmVmOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgaW5saW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICB0YXJnZXQ6IFByb3BUeXBlcy5vbmVPZihbbnVsbCwgJ3NlbGYnLCAnYmxhbmsnXSksXG4gIH07XG5cbiAgc3RhdGU6IFN0YXRlID0ge1xuICAgIGVuYWJsZUZvY3VzU3R5bGVzOiB0cnVlLFxuICB9O1xuXG4gIGhhbmRsZUNsaWNrID0gKGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PD4pID0+IHtcbiAgICBjb25zdCB7IGhyZWYsIG9uQ2xpY2sgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKG9uQ2xpY2sgJiYgaHJlZikge1xuICAgICAgb25DbGljayh7IGV2ZW50IH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVNb3VzZURvd24gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBocmVmLCB0YXJnZXQgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHRhcmdldCA9PT0gJ2JsYW5rJyAmJiBocmVmKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZW5hYmxlRm9jdXNTdHlsZXM6IGZhbHNlIH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVLZXlVcCA9IChldmVudDogU3ludGhldGljS2V5Ym9hcmRFdmVudDw+KSA9PiB7XG4gICAgY29uc3QgeyBocmVmLCB0YXJnZXQgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHRhcmdldCA9PT0gJ2JsYW5rJyAmJiBldmVudC5rZXlDb2RlID09PSBUQUJfS0VZX0NPREUgJiYgaHJlZikge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVuYWJsZUZvY3VzU3R5bGVzOiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgaW5saW5lID0gZmFsc2UsIHRhcmdldCA9IG51bGwsIGhyZWYgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgcmVsID0gdGFyZ2V0ID09PSAnYmxhbmsnID8gJ25vb3BlbmVyIG5vcmVmZXJyZXInIDogbnVsbDtcbiAgICBjb25zdCBsaW5rVGFyZ2V0ID0gdGFyZ2V0ID8gYF8ke3RhcmdldH1gIDogbnVsbDtcblxuICAgIHJldHVybiAoXG4gICAgICA8YVxuICAgICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICAgIHN0eWxlcy5saW5rLFxuICAgICAgICAgIHRoaXMuc3RhdGUuZW5hYmxlRm9jdXNTdHlsZXMgPyBzdHlsZXMuYWNjZXNzaWJsZUZvY3VzU3R5bGUgOiAnJyxcbiAgICAgICAgICBpbmxpbmUgPyAnJyA6IHN0eWxlcy5ibG9ja1xuICAgICAgICApfVxuICAgICAgICBocmVmPXtocmVmfVxuICAgICAgICBvbk1vdXNlRG93bj17dGhpcy5oYW5kbGVNb3VzZURvd259XG4gICAgICAgIG9uS2V5VXA9e3RoaXMuaGFuZGxlS2V5VXB9XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9XG4gICAgICAgIHJlbD17cmVsfVxuICAgICAgICB0YXJnZXQ9e2xpbmtUYXJnZXR9XG4gICAgICA+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvYT5cbiAgICApO1xuICB9XG59XG4iLCIvKipcbiAqIGRlYm91bmNlIHByZXZlbnRzIGEgcGFydGljdWxhciBmdW5jdGlvbiBmcm9tIGJlaW5nIGNhbGxlZCB1bnRpbCBhZnRlciBhIGdpdmVuXG4gKiBjb29sZG93biBwZXJpb2QgKGRlZmF1bHQgMTAwbXMpLiBFdmVyeSB0aW1lIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQsIGl0IHJlc2V0c1xuICogdGhlIGNvb2xkb3duLlxuICovXG5cbi8vIEBmbG93XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWJvdW5jZShcbiAgZm46ICguLi5hcmdzOiAqKSA9PiB2b2lkLFxuICB0aHJlc2hob2xkOiBudW1iZXIgPSAxMDBcbikge1xuICBsZXQgZGVmZXJUaW1lcjogVGltZW91dElEIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3QgZGVib3VuY2VkID0gKC4uLmFyZ3M6ICopID0+IHtcbiAgICBpZiAoZGVmZXJUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KGRlZmVyVGltZXIpO1xuICAgIH1cblxuICAgIGRlZmVyVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRlZmVyVGltZXIgPSBudWxsO1xuICAgICAgZm4oLi4uYXJncyk7XG4gICAgfSwgdGhyZXNoaG9sZCk7XG4gIH07XG5cbiAgZGVib3VuY2VkLmNsZWFyVGltZW91dCA9ICgpID0+IHtcbiAgICBpZiAoZGVmZXJUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KGRlZmVyVGltZXIpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZGVib3VuY2VkO1xufVxuIiwiLyoqXG4gKiBGZXRjaEl0ZW1zIGlzIGEgbG9naWMgY29tcG9uZW50IHRoYXQgcmVuZGVycyBubyBjb250ZW50IGl0c2VsZi4gSXRzIGpvYlxuICogaXMgdG8gbWFuYWdlIHdoZW4gdGhlIGdpdmVuIGZldGNoTW9yZSBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBiYXNlZCBvblxuICogdGhlIGdpdmVuIHNjcm9sbC9zaXplIHByb3BzLlxuICpcbiAqIFdoaWxlIG5vIGVsZW1lbnQgaXMgYWN0dWFsbHkgcGFzc2VkIHRvIEZldGNoSXRlbXMsIGl0IGlzIGludGVuZGVkIHRvIGJlIHVzZWRcbiAqIGluIGNvbmp1bmN0aW9uIHdpdGggYSBsYXJnZSBzY3JvbGwgY29udGFpbmVyIHRoYXQgdXNlcyBhc3luYyBmZXRjaGluZyB0b1xuICogbG9hZCBhbmQgcmVuZGVyIGFkZGl0aW9uYWwgZGF0YS4gQmFzZWQgb24gdGhlIGhlaWdodCBvZiB0aGlzIGNvbnRhaW5lciBhbmRcbiAqIGl0cyBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiwgRmV0Y2hJdGVtcyBpcyByZXNwb25zaWJsZSBmb3IgdHJpZ2dlcmluZyBmdXR1cmVcbiAqIGZldGNoIGNhbGxzLlxuICovXG5cbi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG50eXBlIFByb3BzID0ge1xuICBjb250YWluZXJIZWlnaHQ6IG51bWJlcixcbiAgaXNBdEVuZD86IGJvb2xlYW4sXG4gIGlzRmV0Y2hpbmc6IGJvb2xlYW4sXG4gIGZldGNoTW9yZT86ICgpID0+IHZvaWQsXG4gIHNjcm9sbEhlaWdodDogbnVtYmVyLFxuICBzY3JvbGxUb3A6IG51bWJlcixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZldGNoSXRlbXMgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PFByb3BzPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgY29udGFpbmVySGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgaXNBdEVuZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgaXNGZXRjaGluZzogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgICBmZXRjaE1vcmU6IFByb3BUeXBlcy5mdW5jLFxuICAgIHNjcm9sbEhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIHNjcm9sbFRvcDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICB9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHNldFRpbWVvdXQodGhpcy5jaGVjayk7XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgY2hlY2sgPSAoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGFpbmVySGVpZ2h0LFxuICAgICAgaXNBdEVuZCxcbiAgICAgIGlzRmV0Y2hpbmcsXG4gICAgICBmZXRjaE1vcmUsXG4gICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICBzY3JvbGxUb3AsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoaXNBdEVuZCB8fCBpc0ZldGNoaW5nIHx8ICFmZXRjaE1vcmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2Nyb2xsQnVmZmVyID0gY29udGFpbmVySGVpZ2h0ICogMztcblxuICAgIGlmIChzY3JvbGxUb3AgKyBzY3JvbGxCdWZmZXIgPiBzY3JvbGxIZWlnaHQpIHtcbiAgICAgIGZldGNoTW9yZSgpO1xuICAgIH1cbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbiIsIi8qKlxuICogU2Nyb2xsQ29udGFpbmVyIGlzIGEgcGFzcy10aHJvdWdoIGNvbXBvbmVudCB0aGF0IHNpbXBseSBzZXRzIHVwIGFuIG9uU2Nyb2xsXG4gKiBoYW5kbGVyIG9uIHRoZSBnaXZlbiBzY3JvbGxDb250YWluZXIgZWxlbWVudCAob3IgdGhlIGVsZW1lbnQgdGhhdCBpc1xuICogcmV0dXJuZWQgYXMgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIHNjcm9sbENvbnRhaW5lciBtZXRob2QpLiBUaGlzIGFsbG93cyBmb3JcbiAqIHRoZSBldmVudCBsaXN0ZW5lciBzdWJzY3JpcHRpb24gb2YgdGhlIHNjcm9sbENvbnRhaW5lciB0byBiZSBtYW5hZ2VkIGluc2lkZVxuICogdGhlIFJlYWN0IGxpZmVjeWNsZSB3aXRob3V0IGFkZGluZyBibG9hdCB0byBNYXNvbnJ5IG9yIG90aGVyIG9uU2Nyb2xsXG4gKiBzdWJzY3JpYmVycy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBDb21wb25lbnQgcmVuZGVycyBpdHMgY2hpbGRyZW4gd2l0aG91dCBjcmVhdGluZyBhbnlcbiAqIGFkZGl0aW9uYWwgY29udGVudC4gQWxzbyBub3RlIHRoYXQsIHdoaWxlIHRoZSBjb21wb25lbnQgaXMgYnVpbHQgdG8gbWFuYWdlXG4gKiBvblNjcm9sbCBpbnNpZGUgb2YgdGhlIFJlYWN0IGxpZmVjeWNsZSwgaXQgZG9lc24ndCBjaGFuZ2Ugb25TY3JvbGwgZXZlbnRzXG4gKiBvciB0aGUgQVBJIGF0IGFsbCwgc28gaXQgY291bGQgZWFzaWx5IGJlIGFkYXB0ZWQgdG8gb3RoZXIgZXZlbnQgdHlwZXMuXG4gKi9cblxuLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIG9uU2Nyb2xsOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkLFxuICBzY3JvbGxDb250YWluZXI6ID9IVE1MRWxlbWVudCB8ICgoKSA9PiA/SFRNTEVsZW1lbnQpLFxufH07XG5cbmZ1bmN0aW9uIGdldFNjcm9sbENvbnRhaW5lcihzY3JvbGxDb250YWluZXIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzY3JvbGxDb250YWluZXIgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcm9sbENvbnRhaW5lcigpXG4gICAgOiBzY3JvbGxDb250YWluZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjcm9sbENvbnRhaW5lciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcz4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuICAgIG9uU2Nyb2xsOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHNjcm9sbENvbnRhaW5lcjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKVxuICAgICAgLmlzUmVxdWlyZWQsXG4gIH07XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyID0gZ2V0U2Nyb2xsQ29udGFpbmVyKHRoaXMucHJvcHMuc2Nyb2xsQ29udGFpbmVyKTtcbiAgICBpZiAoc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLnVwZGF0ZVNjcm9sbENvbnRhaW5lcihzY3JvbGxDb250YWluZXIpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICBjb25zdCBuZXh0U2Nyb2xsQ29udGFpbmVyID0gZ2V0U2Nyb2xsQ29udGFpbmVyKHRoaXMucHJvcHMuc2Nyb2xsQ29udGFpbmVyKTtcbiAgICBpZiAobmV4dFNjcm9sbENvbnRhaW5lciAmJiBuZXh0U2Nyb2xsQ29udGFpbmVyICE9PSB0aGlzLnNjcm9sbENvbnRhaW5lcikge1xuICAgICAgdGhpcy51cGRhdGVTY3JvbGxDb250YWluZXIobmV4dFNjcm9sbENvbnRhaW5lcik7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLnNjcm9sbENvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0U2Nyb2xsQ29udGFpbmVyUmVmID0gKCkgPT4gdGhpcy5zY3JvbGxDb250YWluZXI7XG5cbiAgaGFuZGxlU2Nyb2xsID0gKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgIHRoaXMucHJvcHMub25TY3JvbGwoZXZlbnQpO1xuICB9O1xuXG4gIHVwZGF0ZVNjcm9sbENvbnRhaW5lcihzY3JvbGxDb250YWluZXI6IEhUTUxFbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICAvLyBjbGVhbnVwIGV4aXN0aW5nIHNjcm9sbCBjb250YWluZXIgaWYgaXQgZXhpc3RzXG4gICAgICB0aGlzLnNjcm9sbENvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCk7XG4gICAgfVxuICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyID0gc2Nyb2xsQ29udGFpbmVyO1xuICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgfVxuXG4gIHNjcm9sbENvbnRhaW5lcjogP0hUTUxFbGVtZW50O1xuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfVxufVxuIiwiLyoqXG4gKiB0aHJvdHRsZSBsaW1pdHMgdGhlIG51bWJlciBvZiB0aW1lcyBhIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgdG8gYVxuICogZ2l2ZW4gdGhyZXNoaG9sZCAoMTAwbXMgYnkgZGVmYXVsdCkuIFRoZSBmdW5jdGlvbiBpcyBhbHdheXMgY2FsbGVkXG4gKiBvbiB0aGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgZWRnZS5cbiAqL1xuXG4vLyBAZmxvd1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGhyb3R0bGUoXG4gIGZuOiAoLi4uYXJnczogKikgPT4gdm9pZCxcbiAgdGhyZXNoaG9sZDogbnVtYmVyID0gMTAwXG4pIHtcbiAgbGV0IGxhc3Q6IG51bWJlciB8IHZvaWQ7XG4gIGxldCBkZWZlclRpbWVyOiBUaW1lb3V0SUQgfCB2b2lkO1xuICBjb25zdCB0aHJvdHRsZWQgPSAoLi4uYXJnczogKikgPT4ge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKGxhc3QgIT09IHVuZGVmaW5lZCAmJiBub3cgLSBsYXN0IDwgdGhyZXNoaG9sZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGRlZmVyVGltZXIpO1xuICAgICAgZGVmZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsYXN0ID0gbm93O1xuICAgICAgICBmbiguLi5hcmdzKTtcbiAgICAgIH0sIHRocmVzaGhvbGQgLSAobm93IC0gbGFzdCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gbm93O1xuICAgICAgZm4oLi4uYXJncyk7XG4gICAgfVxuICB9O1xuXG4gIHRocm90dGxlZC5jbGVhclRpbWVvdXQgPSAoKSA9PiB7XG4gICAgaWYgKGRlZmVyVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChkZWZlclRpbWVyKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRocm90dGxlZDtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IENhY2hlIH0gZnJvbSAnLi9DYWNoZS5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lYXN1cmVtZW50U3RvcmU8VDoge30gfCAkUmVhZE9ubHlBcnJheTxtaXhlZD4sIFY+XG4gIGltcGxlbWVudHMgQ2FjaGU8VCwgVj4ge1xuICBtYXA6IFdlYWtNYXA8VCwgVj4gPSBuZXcgV2Vha01hcCgpO1xuXG4gIGdldChrZXk6IFQpOiA/ViB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmdldChrZXkpO1xuICB9XG5cbiAgaGFzKGtleTogVCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXMoa2V5KTtcbiAgfVxuXG4gIHNldChrZXk6IFQsIHZhbHVlOiBWKTogdm9pZCB7XG4gICAgdGhpcy5tYXAuc2V0KGtleSwgdmFsdWUpO1xuICB9XG5cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5tYXAgPSBuZXcgV2Vha01hcCgpO1xuICB9XG59XG4iLCIvKipcbiAqIE1lYXN1cmluZyBzY3JvbGwgcG9zaXRpb25zLCBlbGVtZW50IGhlaWdodHMsIGV0YyBpcyBkaWZmZXJlbnQgYmV0d2VlblxuICogZGlmZmVyZW50IGJyb3dzZXJzIGFuZCB0aGUgd2luZG93IG9iamVjdCB2cyBvdGhlciBET00gbm9kZXMuIFRoZXNlXG4gKiB1dGlscyBhYnN0cmFjdCBhd2F5IHRoZXNlIGRpZmZlcmVuY2VzLlxuICovXG5cbi8vIEBmbG93XG5leHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudEhlaWdodChlbGVtZW50OiBIVE1MRWxlbWVudCk6IG51bWJlciB7XG4gIHJldHVybiBlbGVtZW50ID09PSB3aW5kb3cgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiBlbGVtZW50LmNsaWVudEhlaWdodDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbFBvcygpIHtcbiAgaWYgKHdpbmRvdy5zY3JvbGxZICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlclxuICAgIHJldHVybiB3aW5kb3cuc2Nyb2xsWTtcbiAgfVxuICBpZiAoXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIC8vIElFIHN1cHBvcnQuXG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWxhdGl2ZVNjcm9sbFRvcChlbGVtZW50OiBIVE1MRWxlbWVudCk6IG51bWJlciB7XG4gIHJldHVybiBlbGVtZW50ID09PSB3aW5kb3dcbiAgICA/IGdldFdpbmRvd1Njcm9sbFBvcygpXG4gICAgOiBlbGVtZW50LnNjcm9sbFRvcCAtIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsSGVpZ2h0KGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogbnVtYmVyIHtcbiAgcmV0dXJuIGVsZW1lbnQgPT09IHdpbmRvdyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbiAgICA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHRcbiAgICA6IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogbnVtYmVyIHtcbiAgcmV0dXJuIGVsZW1lbnQgPT09IHdpbmRvdyA/IGdldFdpbmRvd1Njcm9sbFBvcygpIDogZWxlbWVudC5zY3JvbGxUb3A7XG59XG4iLCIvLyBAZmxvd1xuZXhwb3J0IGNvbnN0IERlZmF1bHRMYXlvdXRTeW1ib2wgPSBTeW1ib2woJ2RlZmF1bHQnKTtcbmV4cG9ydCBjb25zdCBVbmlmb3JtUm93TGF5b3V0U3ltYm9sID0gU3ltYm9sKCd1bmlmb3JtUm93Jyk7XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBDYWNoZSB9IGZyb20gJy4vQ2FjaGUuanMnO1xuXG5leHBvcnQgdHlwZSBQb3NpdGlvbiA9IHtcbiAgdG9wOiBudW1iZXIsXG4gIGxlZnQ6IG51bWJlcixcbiAgd2lkdGg6IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXIsXG59O1xuXG5jb25zdCBtaW5kZXggPSBhcnIgPT4ge1xuICBsZXQgaWR4ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoYXJyW2ldIDwgYXJyW2lkeF0pIHtcbiAgICAgIGlkeCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpZHg7XG59O1xuXG5jb25zdCBvZmZzY3JlZW4gPSAod2lkdGgsIGhlaWdodCA9IEluZmluaXR5KSA9PiAoe1xuICB0b3A6IC05OTk5LFxuICBsZWZ0OiAtOTk5OSxcbiAgd2lkdGgsXG4gIGhlaWdodCxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCA8VD4oe1xuICBjYWNoZSxcbiAgY29sdW1uV2lkdGggPSAyMzYsXG4gIGd1dHRlciA9IDE0LFxuICBtaW5Db2xzID0gMixcbiAgd2lkdGgsXG59OiB7fFxuICBjb2x1bW5XaWR0aD86IG51bWJlcixcbiAgZ3V0dGVyPzogbnVtYmVyLFxuICBjYWNoZTogQ2FjaGU8VCwgbnVtYmVyPixcbiAgbWluQ29scz86IG51bWJlcixcbiAgd2lkdGg/OiA/bnVtYmVyLFxufH0pID0+IChpdGVtczogQXJyYXk8Kj4pOiBBcnJheTxQb3NpdGlvbj4gPT4ge1xuICBpZiAod2lkdGggPT0gbnVsbCkge1xuICAgIHJldHVybiBpdGVtcy5tYXAoKCkgPT4gb2Zmc2NyZWVuKGNvbHVtbldpZHRoKSk7XG4gIH1cblxuICBjb25zdCBjb2x1bW5XaWR0aEFuZEd1dHRlciA9IGNvbHVtbldpZHRoICsgZ3V0dGVyO1xuICBjb25zdCBjb2x1bW5Db3VudCA9IE1hdGgubWF4KFxuICAgIE1hdGguZmxvb3IoKHdpZHRoICsgZ3V0dGVyKSAvIGNvbHVtbldpZHRoQW5kR3V0dGVyKSxcbiAgICBtaW5Db2xzXG4gICk7XG4gIC8vIHRoZSB0b3RhbCBoZWlnaHQgb2YgZWFjaCBjb2x1bW5cbiAgY29uc3QgaGVpZ2h0cyA9IG5ldyBBcnJheShjb2x1bW5Db3VudCkuZmlsbCgwKTtcbiAgY29uc3QgY2VudGVyT2Zmc2V0ID0gTWF0aC5tYXgoXG4gICAgTWF0aC5mbG9vcigod2lkdGggLSBjb2x1bW5XaWR0aEFuZEd1dHRlciAqIGNvbHVtbkNvdW50ICsgZ3V0dGVyKSAvIDIpLFxuICAgIDBcbiAgKTtcblxuICByZXR1cm4gaXRlbXMucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBhY2M7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FjaGUuZ2V0KGl0ZW0pO1xuICAgIGxldCBwb3NpdGlvbjtcblxuICAgIGlmIChoZWlnaHQgPT0gbnVsbCkge1xuICAgICAgcG9zaXRpb24gPSBvZmZzY3JlZW4oY29sdW1uV2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHRBbmRHdXR0ZXIgPSBoZWlnaHQgKyBndXR0ZXI7XG4gICAgICBjb25zdCBjb2wgPSBtaW5kZXgoaGVpZ2h0cyk7XG4gICAgICBjb25zdCB0b3AgPSBoZWlnaHRzW2NvbF07XG4gICAgICBjb25zdCBsZWZ0ID0gY29sICogY29sdW1uV2lkdGhBbmRHdXR0ZXIgKyBjZW50ZXJPZmZzZXQ7XG5cbiAgICAgIGhlaWdodHNbY29sXSArPSBoZWlnaHRBbmRHdXR0ZXI7XG4gICAgICBwb3NpdGlvbiA9IHsgdG9wLCBsZWZ0LCB3aWR0aDogY29sdW1uV2lkdGgsIGhlaWdodCB9O1xuICAgIH1cbiAgICBwb3NpdGlvbnMucHVzaChwb3NpdGlvbik7XG4gICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgfSwgW10pO1xufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IENhY2hlIH0gZnJvbSAnLi9DYWNoZS5qcyc7XG5cbnR5cGUgUG9zaXRpb24gPSB7IHRvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH07XG5cbmNvbnN0IG9mZnNjcmVlbiA9ICh3aWR0aCwgaGVpZ2h0ID0gSW5maW5pdHkpID0+ICh7XG4gIHRvcDogLTk5OTksXG4gIGxlZnQ6IC05OTk5LFxuICB3aWR0aCxcbiAgaGVpZ2h0LFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IDxUPih7XG4gIGNhY2hlLFxuICBjb2x1bW5XaWR0aCA9IDIzNixcbiAgZ3V0dGVyID0gMTQsXG4gIHdpZHRoLFxuICBtaW5Db2xzID0gMyxcbn06IHt8XG4gIGNhY2hlOiBDYWNoZTxULCBudW1iZXI+LFxuICBjb2x1bW5XaWR0aD86IG51bWJlcixcbiAgZ3V0dGVyPzogbnVtYmVyLFxuICB3aWR0aD86ID9udW1iZXIsXG4gIG1pbkNvbHM/OiBudW1iZXIsXG58fSkgPT4gKGl0ZW1zOiBBcnJheTxUPik6IEFycmF5PFBvc2l0aW9uPiA9PiB7XG4gIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcCgoKSA9PiBvZmZzY3JlZW4oY29sdW1uV2lkdGgpKTtcbiAgfVxuXG4gIGNvbnN0IGNvbHVtbldpZHRoQW5kR3V0dGVyID0gY29sdW1uV2lkdGggKyBndXR0ZXI7XG4gIGNvbnN0IGNvbHVtbkNvdW50ID0gTWF0aC5tYXgoXG4gICAgTWF0aC5mbG9vcigod2lkdGggKyBndXR0ZXIpIC8gY29sdW1uV2lkdGhBbmRHdXR0ZXIpLFxuICAgIG1pbkNvbHNcbiAgKTtcblxuICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgY29uc3QgaGVpZ2h0cyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBsZXQgcG9zaXRpb247XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FjaGUuZ2V0KGl0ZW1zW2ldKTtcblxuICAgIGlmIChoZWlnaHQgPT0gbnVsbCkge1xuICAgICAgcG9zaXRpb24gPSBvZmZzY3JlZW4oY29sdW1uV2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb2x1bW4gPSBpICUgY29sdW1uQ291bnQ7XG4gICAgICBjb25zdCByb3cgPSBNYXRoLmZsb29yKGkgLyBjb2x1bW5Db3VudCk7XG5cbiAgICAgIGlmIChjb2x1bW4gPT09IDAgfHwgaGVpZ2h0ID4gaGVpZ2h0c1tyb3ddKSB7XG4gICAgICAgIGhlaWdodHNbcm93XSA9IGhlaWdodDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9wID1cbiAgICAgICAgcm93ID4gMFxuICAgICAgICAgID8gaGVpZ2h0cy5zbGljZSgwLCByb3cpLnJlZHVjZSgoc3VtLCB5KSA9PiBzdW0gKyB5ICsgZ3V0dGVyLCAwKVxuICAgICAgICAgIDogMDtcblxuICAgICAgcG9zaXRpb24gPSB7XG4gICAgICAgIHRvcCxcbiAgICAgICAgbGVmdDogY29sdW1uICogY29sdW1uV2lkdGhBbmRHdXR0ZXIsXG4gICAgICAgIHdpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgfTtcbiAgICB9XG4gICAgcG9zaXRpb25zLnB1c2gocG9zaXRpb24pO1xuICB9XG4gIHJldHVybiBwb3NpdGlvbnM7XG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgQ2FjaGUgfSBmcm9tICcuL0NhY2hlLmpzJztcblxudHlwZSBQb3NpdGlvbiA9IHsgdG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfTtcblxuY29uc3QgbWluZGV4ID0gYXJyID0+IHtcbiAgbGV0IGlkeCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGFycltpXSA8IGFycltpZHhdKSB7XG4gICAgICBpZHggPSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaWR4O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgPFQ+KHtcbiAgZ3V0dGVyID0gMCxcbiAgY2FjaGUsXG4gIG1pbkNvbHMgPSAyLFxuICBpZGVhbENvbHVtbldpZHRoID0gMjQwLFxuICB3aWR0aCxcbn06IHt8XG4gIGd1dHRlcj86IG51bWJlcixcbiAgY2FjaGU6IENhY2hlPFQsIG51bWJlcj4sXG4gIG1pbkNvbHM/OiBudW1iZXIsXG4gIGlkZWFsQ29sdW1uV2lkdGg/OiBudW1iZXIsXG4gIHdpZHRoPzogP251bWJlcixcbnx9KSA9PiB7XG4gIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIChpdGVtczogQXJyYXk8bWl4ZWQ+KTogQXJyYXk8UG9zaXRpb24+ID0+XG4gICAgICBpdGVtcy5tYXAoKCkgPT4gKHtcbiAgICAgICAgdG9wOiBJbmZpbml0eSxcbiAgICAgICAgbGVmdDogSW5maW5pdHksXG4gICAgICAgIHdpZHRoOiBJbmZpbml0eSxcbiAgICAgICAgaGVpZ2h0OiBJbmZpbml0eSxcbiAgICAgIH0pKTtcbiAgfVxuXG4gIC8vIFwiVGhpcyBpcyBraW5kIG9mIGNyYXp5IVwiIC0geW91XG4gIC8vIFllcywgaW5kZWVkLiBUaGUgXCJndWVzc2luZ1wiIGhlcmUgaXMgbWVhbnQgdG8gcmVwbGljYXRlIHRoZSBwYXNzIHRoYXQgdGhlXG4gIC8vIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIHRha2VzIHdpdGggQ1NTLlxuICBjb25zdCBjb2xndWVzcyA9IE1hdGguZmxvb3Iod2lkdGggLyBpZGVhbENvbHVtbldpZHRoKTtcbiAgY29uc3QgY29sdW1uQ291bnQgPSBNYXRoLm1heChcbiAgICBNYXRoLmZsb29yKCh3aWR0aCAtIGNvbGd1ZXNzICogZ3V0dGVyKSAvIGlkZWFsQ29sdW1uV2lkdGgpLFxuICAgIG1pbkNvbHNcbiAgKTtcbiAgY29uc3QgY29sdW1uV2lkdGggPSBNYXRoLmZsb29yKHdpZHRoIC8gY29sdW1uQ291bnQpO1xuXG4gIHJldHVybiAoaXRlbXM6IEFycmF5PFQ+KSA9PiB7XG4gICAgLy8gdGhlIHRvdGFsIGhlaWdodCBvZiBlYWNoIGNvbHVtblxuICAgIGNvbnN0IGhlaWdodHMgPSBuZXcgQXJyYXkoY29sdW1uQ291bnQpLmZpbGwoMCk7XG5cbiAgICByZXR1cm4gaXRlbXMucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IGFjYztcbiAgICAgIGNvbnN0IGhlaWdodCA9IGNhY2hlLmdldChpdGVtKTtcbiAgICAgIGxldCBwb3NpdGlvbjtcblxuICAgICAgaWYgKGhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgIHBvc2l0aW9uID0ge1xuICAgICAgICAgIHRvcDogSW5maW5pdHksXG4gICAgICAgICAgbGVmdDogSW5maW5pdHksXG4gICAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICAgIGhlaWdodDogSW5maW5pdHksXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2wgPSBtaW5kZXgoaGVpZ2h0cyk7XG4gICAgICAgIGNvbnN0IHRvcCA9IGhlaWdodHNbY29sXTtcbiAgICAgICAgY29uc3QgbGVmdCA9IGNvbCAqIGNvbHVtbldpZHRoICsgZ3V0dGVyIC8gMjtcblxuICAgICAgICBoZWlnaHRzW2NvbF0gKz0gaGVpZ2h0O1xuICAgICAgICBwb3NpdGlvbiA9IHtcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB3aWR0aDogY29sdW1uV2lkdGggLSBndXR0ZXIsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBwb3NpdGlvbnMucHVzaChwb3NpdGlvbik7XG4gICAgICByZXR1cm4gcG9zaXRpb25zO1xuICAgIH0sIFtdKTtcbiAgfTtcbn07XG4iLCIvLyBAZmxvd1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFzb25yeUxheW91dCB7fVxuIiwiLy8gQGZsb3dcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVuaWZvcm1Sb3dMYXlvdXQge31cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJy4vZGVib3VuY2UuanMnO1xuaW1wb3J0IEZldGNoSXRlbXMgZnJvbSAnLi9GZXRjaEl0ZW1zLmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9NYXNvbnJ5LmNzcyc7XG5pbXBvcnQgU2Nyb2xsQ29udGFpbmVyIGZyb20gJy4vU2Nyb2xsQ29udGFpbmVyLmpzJztcbmltcG9ydCB0aHJvdHRsZSBmcm9tICcuL3Rocm90dGxlLmpzJztcbmltcG9ydCB0eXBlIHsgQ2FjaGUgfSBmcm9tICcuL0NhY2hlLmpzJztcbmltcG9ydCBNZWFzdXJlbWVudFN0b3JlIGZyb20gJy4vTWVhc3VyZW1lbnRTdG9yZS5qcyc7XG5pbXBvcnQge1xuICBnZXRFbGVtZW50SGVpZ2h0LFxuICBnZXRSZWxhdGl2ZVNjcm9sbFRvcCxcbiAgZ2V0U2Nyb2xsUG9zLFxufSBmcm9tICcuL3Njcm9sbFV0aWxzLmpzJztcbmltcG9ydCB7XG4gIERlZmF1bHRMYXlvdXRTeW1ib2wsXG4gIFVuaWZvcm1Sb3dMYXlvdXRTeW1ib2wsXG59IGZyb20gJy4vbGVnYWN5TGF5b3V0U3ltYm9scy5qcyc7XG5pbXBvcnQgZGVmYXVsdExheW91dCBmcm9tICcuL2RlZmF1bHRMYXlvdXQuanMnO1xuaW1wb3J0IHVuaWZvcm1Sb3dMYXlvdXQgZnJvbSAnLi91bmlmb3JtUm93TGF5b3V0LmpzJztcbmltcG9ydCBmdWxsV2lkdGhMYXlvdXQgZnJvbSAnLi9mdWxsV2lkdGhMYXlvdXQuanMnO1xuaW1wb3J0IExlZ2FjeU1hc29ucnlMYXlvdXQgZnJvbSAnLi9sYXlvdXRzL01hc29ucnlMYXlvdXQuanMnO1xuaW1wb3J0IExlZ2FjeVVuaWZvcm1Sb3dMYXlvdXQgZnJvbSAnLi9sYXlvdXRzL1VuaWZvcm1Sb3dMYXlvdXQuanMnO1xuXG50eXBlIExheW91dCA9XG4gIHwgdHlwZW9mIERlZmF1bHRMYXlvdXRTeW1ib2xcbiAgfCB0eXBlb2YgVW5pZm9ybVJvd0xheW91dFN5bWJvbFxuICB8IExlZ2FjeU1hc29ucnlMYXlvdXRcbiAgfCBMZWdhY3lVbmlmb3JtUm93TGF5b3V0O1xuXG50eXBlIFByb3BzPFQ+ID0ge3xcbiAgY29sdW1uV2lkdGg/OiBudW1iZXIsXG4gIGNvbXA6IFJlYWN0LkNvbXBvbmVudFR5cGU8e1xuICAgIGRhdGE6IFQsXG4gICAgaXRlbUlkeDogbnVtYmVyLFxuICAgIGlzTWVhc3VyaW5nOiBib29sZWFuLFxuICB9PixcbiAgZmxleGlibGU/OiBib29sZWFuLFxuICBndXR0ZXJXaWR0aD86IG51bWJlcixcbiAgaXRlbXM6IEFycmF5PFQ+LFxuICBtZWFzdXJlbWVudFN0b3JlOiBDYWNoZTxULCAqPixcbiAgbWluQ29sczogbnVtYmVyLFxuICBsYXlvdXQ/OiBMYXlvdXQsXG4gIC8vIFN1cHBvcnQgbGVnYWN5IGxvYWRJdGVtcyB1c2FnZS5cbiAgLy8gVE9ETzogU2ltcGxpZnkgbm9uIGZhbHNleSBmbG93dHlwZS5cbiAgbG9hZEl0ZW1zPzpcbiAgICB8IGZhbHNlXG4gICAgfCAoKFxuICAgICAgICA/e1xuICAgICAgICAgIGZyb206IG51bWJlcixcbiAgICAgICAgfVxuICAgICAgKSA9PiB2b2lkIHwgYm9vbGVhbiB8IHt9KSxcbiAgc2Nyb2xsQ29udGFpbmVyPzogKCkgPT4gSFRNTEVsZW1lbnQsXG4gIHZpcnR1YWxCb3VuZHNUb3A/OiBudW1iZXIsXG4gIHZpcnR1YWxCb3VuZHNCb3R0b20/OiBudW1iZXIsXG4gIHZpcnR1YWxpemU/OiBib29sZWFuLFxufH07XG5cbnR5cGUgU3RhdGU8VD4gPSB7fFxuICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzOiBib29sZWFuLFxuICBpc0ZldGNoaW5nOiBib29sZWFuLFxuICBpdGVtczogQXJyYXk8VD4sXG4gIHNjcm9sbFRvcDogbnVtYmVyLFxuICB3aWR0aDogP251bWJlcixcbnx9O1xuXG5jb25zdCBSRVNJWkVfREVCT1VOQ0UgPSAzMDA7XG4vLyBNdWx0aXBsaWVkIGFnYWluc3QgY29udGFpbmVyIGhlaWdodC5cbi8vIFRoZSBhbW91bnQgb2YgZXh0cmEgYnVmZmVyIHNwYWNlIGZvciBwb3B1bGF0aW5nIHZpc2libGUgaXRlbXMuXG5jb25zdCBWSVJUVUFMX0JVRkZFUl9GQUNUT1IgPSAwLjc7XG5cbmNvbnN0IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uID0gbiA9PiAobiAhPT0gSW5maW5pdHkgPyBuIDogdW5kZWZpbmVkKTtcblxuLyoqXG4gKiBOT1RFOiBUaGlzIGlzIHRvIGJlIHJlcGxhY2VkIGJ5IE1hc29ucnlJbmZpbml0ZUJldGEgd2hlbiBpdCBpcyByZWFkeVxuICogTk9URTogUGxlYXNlIGRvIG5vdCBtb2RpZnkgdGhpcyBvciBtYWtlIHN1cmUgY2hhbmdlcyBpbiBoZXJlIGFyZSBhbHNvXG4gKiAgICAgICByZXBsaWNhdGVkIGluIE1hc29ucnlCZXRhLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXNvbnJ5PFQ+IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzPFQ+LCBTdGF0ZTxUPj4ge1xuICBzdGF0aWMgY3JlYXRlTWVhc3VyZW1lbnRTdG9yZSgpIHtcbiAgICAvLyAkRmxvd0ZpeE1lOiBuZXcgZXJyb3JzIGZvdW5kIGZyb20gZmxvdyAwLjk2IHVwZ3JhZGVcbiAgICByZXR1cm4gbmV3IE1lYXN1cmVtZW50U3RvcmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxheXMgcmVzaXplIGhhbmRsaW5nIGluIGNhc2UgdGhlIHNjcm9sbCBjb250YWluZXIgaXMgc3RpbGwgYmVpbmcgcmVzaXplZC5cbiAgICovXG4gIGhhbmRsZVJlc2l6ZSA9IGRlYm91bmNlKCgpID0+IHtcbiAgICBpZiAodGhpcy5ncmlkV3JhcHBlcikge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHdpZHRoOiB0aGlzLmdyaWRXcmFwcGVyLmNsaWVudFdpZHRoIH0pO1xuICAgIH1cbiAgfSwgUkVTSVpFX0RFQk9VTkNFKTtcblxuICB1cGRhdGVTY3JvbGxQb3NpdGlvbiA9IHRocm90dGxlKCgpID0+IHtcbiAgICBpZiAoIXRoaXMuc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lciA9IHRoaXMuc2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbENvbnRhaW5lclJlZigpO1xuXG4gICAgaWYgKCFzY3JvbGxDb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNjcm9sbFRvcDogZ2V0U2Nyb2xsUG9zKHNjcm9sbENvbnRhaW5lciksXG4gICAgfSk7XG4gIH0pO1xuXG4gIG1lYXN1cmVDb250YWluZXJBc3luYyA9IGRlYm91bmNlKCgpID0+IHtcbiAgICB0aGlzLm1lYXN1cmVDb250YWluZXIoKTtcbiAgfSwgMCk7XG5cbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJlZmVycmVkL3RhcmdldCBpdGVtIHdpZHRoLiBJZiBgZmxleGlibGVgIGlzIHNldCwgdGhlIGl0ZW0gd2lkdGggd2lsbFxuICAgICAqIGdyb3cgdG8gZmlsbCBjb2x1bW4gc3BhY2UsIGFuZCBzaHJpbmsgdG8gZml0IGlmIGJlbG93IG1pbiBjb2x1bW5zLlxuICAgICAqL1xuICAgIGNvbHVtbldpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbXBvbmVudCB0byByZW5kZXIuXG4gICAgICovXG4gICAgLyogZXNsaW50IHJlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzOiAwICovXG4gICAgY29tcDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmVmZXJyZWQvdGFyZ2V0IGl0ZW0gd2lkdGguIEl0ZW0gd2lkdGggd2lsbCBncm93IHRvIGZpbGxcbiAgICAgKiBjb2x1bW4gc3BhY2UsIGFuZCBzaHJpbmsgdG8gZml0IGlmIGJlbG93IG1pbiBjb2x1bW5zLlxuICAgICAqL1xuICAgIGZsZXhpYmxlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbW91bnQgb2Ygc3BhY2UgYmV0d2VlbiBlYWNoIGl0ZW0uXG4gICAgICovXG4gICAgZ3V0dGVyV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBhbGwgb2JqZWN0cyB0byBkaXNwbGF5IGluIHRoZSBncmlkLlxuICAgICAqL1xuICAgIGl0ZW1zOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe30pKS5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogTWVhc3VyZW1lbnQgU3RvcmVcbiAgICAgKi9cbiAgICBtZWFzdXJlbWVudFN0b3JlOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihNZWFzdXJlbWVudFN0b3JlKSxcblxuICAgIC8qKlxuICAgICAqIExheW91dCBzeXN0ZW0gdG8gdXNlIGZvciBpdGVtc1xuICAgICAqL1xuICAgIGxheW91dDogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuaW5zdGFuY2VPZihMZWdhY3lNYXNvbnJ5TGF5b3V0KSxcbiAgICAgIFByb3BUeXBlcy5pbnN0YW5jZU9mKExlZ2FjeVVuaWZvcm1Sb3dMYXlvdXQpLFxuICAgICAgUHJvcFR5cGVzLnN5bWJvbCxcbiAgICBdKSxcblxuICAgIC8qKlxuICAgICAqIEEgY2FsbGJhY2sgd2hpY2ggdGhlIGdyaWQgY2FsbHMgd2hlbiB3ZSBuZWVkIHRvIGxvYWQgbW9yZSBpdGVtcyBhcyB0aGUgdXNlciBzY3JvbGxzLlxuICAgICAqIFRoZSBjYWxsYmFjayBzaG91bGQgdXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgaXRlbXMsIGFuZCBwYXNzIHRob3NlIGluIGFzIHByb3BzXG4gICAgICogdG8gdGhpcyBjb21wb25lbnQuXG4gICAgICovXG4gICAgbG9hZEl0ZW1zOiBQcm9wVHlwZXMuZnVuYyxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gbnVtYmVyIG9mIGNvbHVtbnMgdG8gZGlzcGxheS5cbiAgICAgKi9cbiAgICBtaW5Db2xzOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCB0aGUgZ3JpZCBjYWxscyB0byBnZXQgdGhlIHNjcm9sbCBjb250YWluZXIuXG4gICAgICogVGhpcyBpcyByZXF1aXJlZCBpZiB0aGUgZ3JpZCBpcyBleHBlY3RlZCB0byBiZSBzY3JvbGxhYmxlLlxuICAgICAqL1xuICAgIHNjcm9sbENvbnRhaW5lcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byB1c2UgYWN0dWFsIHZpcnR1YWxpemF0aW9uXG4gICAgICovXG4gICAgdmlydHVhbGl6ZTogUHJvcFR5cGVzLmJvb2wsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb2x1bW5XaWR0aDogMjM2LFxuICAgIC8vICRGbG93Rml4TWU6IG5ldyBlcnJvcnMgZm91bmQgZnJvbSBmbG93IDAuOTYgdXBncmFkZVxuICAgIG1lYXN1cmVtZW50U3RvcmU6IG5ldyBNZWFzdXJlbWVudFN0b3JlKCksXG4gICAgbWluQ29sczogMyxcbiAgICBsYXlvdXQ6IERlZmF1bHRMYXlvdXRTeW1ib2wsXG4gICAgbG9hZEl0ZW1zOiAoKSA9PiB7fSxcbiAgICB2aXJ0dWFsaXplOiBmYWxzZSxcbiAgfTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHM8VD4pIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLmNvbnRhaW5lckhlaWdodCA9IDA7XG4gICAgdGhpcy5jb250YWluZXJPZmZzZXQgPSAwO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHM6IHByb3BzLml0ZW1zLnNvbWUoXG4gICAgICAgIGl0ZW0gPT4gISFpdGVtICYmICFwcm9wcy5tZWFzdXJlbWVudFN0b3JlLmhhcyhpdGVtKVxuICAgICAgKSxcbiAgICAgIGlzRmV0Y2hpbmc6IGZhbHNlLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLXVudXNlZC1zdGF0ZVxuICAgICAgaXRlbXM6IHByb3BzLml0ZW1zLFxuICAgICAgc2Nyb2xsVG9wOiAwLFxuICAgICAgd2lkdGg6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgaG9va3MgYWZ0ZXIgdGhlIGNvbXBvbmVudCBtb3VudHMuXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVSZXNpemUpO1xuXG4gICAgdGhpcy5tZWFzdXJlQ29udGFpbmVyKCk7XG5cbiAgICBsZXQgeyBzY3JvbGxUb3AgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHRoaXMuc2Nyb2xsQ29udGFpbmVyICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lciA9IHRoaXMuc2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbENvbnRhaW5lclJlZigpO1xuICAgICAgaWYgKHNjcm9sbENvbnRhaW5lcikge1xuICAgICAgICBzY3JvbGxUb3AgPSBnZXRTY3JvbGxQb3Moc2Nyb2xsQ29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHByZXZTdGF0ZSA9PiAoe1xuICAgICAgc2Nyb2xsVG9wLFxuICAgICAgd2lkdGg6IHRoaXMuZ3JpZFdyYXBwZXIgPyB0aGlzLmdyaWRXcmFwcGVyLmNsaWVudFdpZHRoIDogcHJldlN0YXRlLndpZHRoLFxuICAgIH0pKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IFByb3BzPFQ+LCBwcmV2U3RhdGU6IFN0YXRlPFQ+KSB7XG4gICAgY29uc3QgeyBpdGVtcywgbWVhc3VyZW1lbnRTdG9yZSB9ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMubWVhc3VyZUNvbnRhaW5lckFzeW5jKCk7XG5cbiAgICBpZiAocHJldlN0YXRlLndpZHRoICE9IG51bGwgJiYgdGhpcy5zdGF0ZS53aWR0aCAhPT0gcHJldlN0YXRlLndpZHRoKSB7XG4gICAgICBtZWFzdXJlbWVudFN0b3JlLnJlc2V0KCk7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSB3aGV0aGVyIHdlIHN0aWxsIGhhdmUgcGVuZGluZyBtZWFzdXJlbWVudHNcbiAgICBjb25zdCBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzID0gaXRlbXMuc29tZShcbiAgICAgIGl0ZW0gPT4gISFpdGVtICYmICFtZWFzdXJlbWVudFN0b3JlLmhhcyhpdGVtKVxuICAgICk7XG4gICAgaWYgKFxuICAgICAgaGFzUGVuZGluZ01lYXN1cmVtZW50cyB8fFxuICAgICAgaGFzUGVuZGluZ01lYXN1cmVtZW50cyAhPT0gdGhpcy5zdGF0ZS5oYXNQZW5kaW5nTWVhc3VyZW1lbnRzIHx8XG4gICAgICBwcmV2U3RhdGUud2lkdGggPT0gbnVsbFxuICAgICkge1xuICAgICAgdGhpcy5pbnNlcnRBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBsaXN0ZW5lcnMgd2hlbiB1bm1vdW50aW5nLlxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuaW5zZXJ0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuaW5zZXJ0QW5pbWF0aW9uRnJhbWUpO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBhc3luYyBtZXRob2RzIGFyZSBjYW5jZWxsZWQuXG4gICAgdGhpcy5tZWFzdXJlQ29udGFpbmVyQXN5bmMuY2xlYXJUaW1lb3V0KCk7XG4gICAgdGhpcy5oYW5kbGVSZXNpemUuY2xlYXJUaW1lb3V0KCk7XG4gICAgdGhpcy51cGRhdGVTY3JvbGxQb3NpdGlvbi5jbGVhclRpbWVvdXQoKTtcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzOiBQcm9wczxUPiwgc3RhdGU6IFN0YXRlPFQ+KSB7XG4gICAgY29uc3QgeyBpdGVtcywgbWVhc3VyZW1lbnRTdG9yZSB9ID0gcHJvcHM7XG4gICAgLy8gd2hlbmV2ZXIgd2UncmUgcmVjZWl2aW5nIG5ldyBwcm9wcywgZGV0ZXJtaW5lIHdoZXRoZXIgYW55IGl0ZW1zIG5lZWQgdG8gYmUgbWVhc3VyZWRcbiAgICAvLyBUT0RPIC0gd2Ugc2hvdWxkIHRyZWF0IGl0ZW1zIGFzIGltbXV0YWJsZVxuICAgIGNvbnN0IGhhc1BlbmRpbmdNZWFzdXJlbWVudHMgPSBpdGVtcy5zb21lKFxuICAgICAgaXRlbSA9PiAhbWVhc3VyZW1lbnRTdG9yZS5oYXMoaXRlbSlcbiAgICApO1xuXG4gICAgLy8gU2hhbGxvdyBjb21wYXJlIGFsbCBpdGVtcywgaWYgYW55IGNoYW5nZSByZWZsb3cgdGhlIGdyaWQuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIG91ciBjdXJyZW50IHByb3BzIGFuZCBldmVyeXRoaW5nIG1hdGNoZXMuXG4gICAgICAvLyBJZiB3ZSBoaXQgdGhpcyBjYXNlIGl0IG1lYW5zIHdlIG5lZWQgdG8gaW5zZXJ0IG5ldyBpdGVtcy5cbiAgICAgIGlmIChzdGF0ZS5pdGVtc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGFzUGVuZGluZ01lYXN1cmVtZW50cyxcbiAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgZ3JpZCBpdGVtcyB3aGVuOlxuICAgICAgaWYgKFxuICAgICAgICAvLyBBbiBpdGVtIG9iamVjdCByZWYgZG9lcyBub3QgbWF0Y2guXG4gICAgICAgIGl0ZW1zW2ldICE9PSBzdGF0ZS5pdGVtc1tpXSB8fFxuICAgICAgICAvLyBPciBsZXNzIGl0ZW1zIHRoYW4gd2UgY3VycmVudGx5IGhhdmUgYXJlIHBhc3NlZCBpbi5cbiAgICAgICAgaXRlbXMubGVuZ3RoIDwgc3RhdGUuaXRlbXMubGVuZ3RoXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzLFxuICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgIGlzRmV0Y2hpbmc6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlc2V0IGl0ZW1zIGlmIG5ldyBpdGVtcyBhcnJheSBpcyBlbXB0eS5cbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwICYmIHN0YXRlLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMsXG4gICAgICAgIGl0ZW1zLFxuICAgICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChoYXNQZW5kaW5nTWVhc3VyZW1lbnRzICE9PSBzdGF0ZS5oYXNQZW5kaW5nTWVhc3VyZW1lbnRzKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgd2UgYWx3YXlzIHVwZGF0ZSBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzLFxuICAgICAgICBpdGVtcyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIG51bGwgdG8gaW5kaWNhdGUgbm8gY2hhbmdlIHRvIHN0YXRlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc2V0R3JpZFdyYXBwZXJSZWYgPSAocmVmOiA/SFRNTEVsZW1lbnQpID0+IHtcbiAgICB0aGlzLmdyaWRXcmFwcGVyID0gcmVmO1xuICB9O1xuXG4gIHNldFNjcm9sbENvbnRhaW5lclJlZiA9IChyZWY6ID9TY3JvbGxDb250YWluZXIpID0+IHtcbiAgICB0aGlzLnNjcm9sbENvbnRhaW5lciA9IHJlZjtcbiAgfTtcblxuICBmZXRjaE1vcmUgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBsb2FkSXRlbXMgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKGxvYWRJdGVtcyAmJiB0eXBlb2YgbG9hZEl0ZW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKFxuICAgICAgICB7XG4gICAgICAgICAgaXNGZXRjaGluZzogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4gbG9hZEl0ZW1zKHsgZnJvbTogdGhpcy5wcm9wcy5pdGVtcy5sZW5ndGggfSlcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnRhaW5lckhlaWdodDogbnVtYmVyO1xuXG4gIGNvbnRhaW5lck9mZnNldDogbnVtYmVyO1xuXG4gIGdyaWRXcmFwcGVyOiA/SFRNTEVsZW1lbnQ7XG5cbiAgaW5zZXJ0QW5pbWF0aW9uRnJhbWU6IEFuaW1hdGlvbkZyYW1lSUQ7XG5cbiAgbWVhc3VyZVRpbWVvdXQ6IFRpbWVvdXRJRDtcblxuICBzY3JvbGxDb250YWluZXI6ID9TY3JvbGxDb250YWluZXI7XG5cbiAgbWVhc3VyZUNvbnRhaW5lcigpIHtcbiAgICBpZiAodGhpcy5zY3JvbGxDb250YWluZXIgIT0gbnVsbCkge1xuICAgICAgY29uc3QgeyBzY3JvbGxDb250YWluZXIgfSA9IHRoaXM7XG4gICAgICBjb25zdCBzY3JvbGxDb250YWluZXJSZWYgPSBzY3JvbGxDb250YWluZXIuZ2V0U2Nyb2xsQ29udGFpbmVyUmVmKCk7XG4gICAgICBpZiAoc2Nyb2xsQ29udGFpbmVyUmVmKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVySGVpZ2h0ID0gZ2V0RWxlbWVudEhlaWdodChzY3JvbGxDb250YWluZXJSZWYpO1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMuZ3JpZFdyYXBwZXI7XG4gICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgY29uc3QgcmVsYXRpdmVTY3JvbGxUb3AgPSBnZXRSZWxhdGl2ZVNjcm9sbFRvcChzY3JvbGxDb250YWluZXJSZWYpO1xuICAgICAgICAgIHRoaXMuY29udGFpbmVyT2Zmc2V0ID1cbiAgICAgICAgICAgIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHJlbGF0aXZlU2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIG1lYXN1cmVtZW50cy9wb3NpdGlvbnMgYW5kIGZvcmNlIGEgcmVmbG93IG9mIHRoZSBlbnRpcmUgZ3JpZC5cbiAgICogT25seSB1c2UgdGhpcyBpZiBhYnNvbHV0ZWx5IG5lY2Vzc2FyeSAtIGV4OiBXZSBuZWVkIHRvIHJlZmxvdyBpdGVtcyBpZiB0aGVcbiAgICogbnVtYmVyIG9mIGNvbHVtbnMgd2Ugd291bGQgZGlzcGxheSBzaG91bGQgY2hhbmdlIGFmdGVyIGEgcmVzaXplLlxuICAgKi9cbiAgcmVmbG93KCkge1xuICAgIHRoaXMucHJvcHMubWVhc3VyZW1lbnRTdG9yZS5yZXNldCgpO1xuICAgIHRoaXMubWVhc3VyZUNvbnRhaW5lcigpO1xuICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIHJlbmRlck1hc29ucnlDb21wb25lbnQgPSAoaXRlbURhdGE6IFQsIGlkeDogbnVtYmVyLCBwb3NpdGlvbjogKikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbXA6IENvbXBvbmVudCxcbiAgICAgIHZpcnR1YWxpemUsXG4gICAgICB2aXJ0dWFsQm91bmRzVG9wLFxuICAgICAgdmlydHVhbEJvdW5kc0JvdHRvbSxcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHRvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCB9ID0gcG9zaXRpb247XG5cbiAgICBsZXQgaXNWaXNpYmxlO1xuICAgIGlmICh0aGlzLnByb3BzLnNjcm9sbENvbnRhaW5lcikge1xuICAgICAgY29uc3QgdmlydHVhbEJ1ZmZlciA9IHRoaXMuY29udGFpbmVySGVpZ2h0ICogVklSVFVBTF9CVUZGRVJfRkFDVE9SO1xuICAgICAgY29uc3Qgb2Zmc2V0U2Nyb2xsUG9zID0gdGhpcy5zdGF0ZS5zY3JvbGxUb3AgLSB0aGlzLmNvbnRhaW5lck9mZnNldDtcbiAgICAgIGNvbnN0IHZpZXdwb3J0VG9wID0gdmlydHVhbEJvdW5kc1RvcFxuICAgICAgICA/IG9mZnNldFNjcm9sbFBvcyAtIHZpcnR1YWxCb3VuZHNUb3BcbiAgICAgICAgOiBvZmZzZXRTY3JvbGxQb3MgLSB2aXJ0dWFsQnVmZmVyO1xuICAgICAgY29uc3Qgdmlld3BvcnRCb3R0b20gPSB2aXJ0dWFsQm91bmRzQm90dG9tXG4gICAgICAgID8gb2Zmc2V0U2Nyb2xsUG9zICsgdGhpcy5jb250YWluZXJIZWlnaHQgKyB2aXJ0dWFsQm91bmRzQm90dG9tXG4gICAgICAgIDogb2Zmc2V0U2Nyb2xsUG9zICsgdGhpcy5jb250YWluZXJIZWlnaHQgKyB2aXJ0dWFsQnVmZmVyO1xuXG4gICAgICBpc1Zpc2libGUgPSAhKFxuICAgICAgICBwb3NpdGlvbi50b3AgKyBwb3NpdGlvbi5oZWlnaHQgPCB2aWV3cG9ydFRvcCB8fFxuICAgICAgICBwb3NpdGlvbi50b3AgPiB2aWV3cG9ydEJvdHRvbVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgbm8gc2Nyb2xsIGNvbnRhaW5lciBpcyBwYXNzZWQgaW4sIGl0ZW1zIHNob3VsZCBhbHdheXMgYmUgdmlzaWJsZVxuICAgICAgaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtQ29tcG9uZW50ID0gKFxuICAgICAgPGRpdlxuICAgICAgICBrZXk9e2BpdGVtLSR7aWR4fWB9XG4gICAgICAgIGNsYXNzTmFtZT17W3N0eWxlcy5NYXNvbnJ5X19JdGVtLCBzdHlsZXMuTWFzb25yeV9fSXRlbV9fTW91bnRlZF0uam9pbihcbiAgICAgICAgICAnICdcbiAgICAgICAgKX1cbiAgICAgICAgZGF0YS1ncmlkLWl0ZW1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7bGVmdH1weCkgdHJhbnNsYXRlWSgke3RvcH1weClgLFxuICAgICAgICAgIFdlYmtpdFRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtsZWZ0fXB4KSB0cmFuc2xhdGVZKCR7dG9wfXB4KWAsXG4gICAgICAgICAgd2lkdGg6IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uKHdpZHRoKSxcbiAgICAgICAgICBoZWlnaHQ6IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uKGhlaWdodCksXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIDxDb21wb25lbnQgZGF0YT17aXRlbURhdGF9IGl0ZW1JZHg9e2lkeH0gaXNNZWFzdXJpbmc9e2ZhbHNlfSAvPlxuICAgICAgPC9kaXY+XG4gICAgKTtcblxuICAgIHJldHVybiB2aXJ0dWFsaXplID8gKGlzVmlzaWJsZSAmJiBpdGVtQ29tcG9uZW50KSB8fCBudWxsIDogaXRlbUNvbXBvbmVudDtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29sdW1uV2lkdGgsXG4gICAgICBjb21wOiBDb21wb25lbnQsXG4gICAgICBmbGV4aWJsZSxcbiAgICAgIGd1dHRlcldpZHRoOiBndXR0ZXIsXG4gICAgICBtZWFzdXJlbWVudFN0b3JlLFxuICAgICAgaXRlbXMsXG4gICAgICBtaW5Db2xzLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgaGFzUGVuZGluZ01lYXN1cmVtZW50cywgd2lkdGggfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBsZXQgbGF5b3V0O1xuICAgIGlmIChmbGV4aWJsZSAmJiB3aWR0aCAhPT0gbnVsbCkge1xuICAgICAgbGF5b3V0ID0gZnVsbFdpZHRoTGF5b3V0KHtcbiAgICAgICAgZ3V0dGVyLFxuICAgICAgICBjYWNoZTogbWVhc3VyZW1lbnRTdG9yZSxcbiAgICAgICAgbWluQ29scyxcbiAgICAgICAgaWRlYWxDb2x1bW5XaWR0aDogY29sdW1uV2lkdGgsXG4gICAgICAgIHdpZHRoLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRoaXMucHJvcHMubGF5b3V0ID09PSBVbmlmb3JtUm93TGF5b3V0U3ltYm9sIHx8XG4gICAgICB0aGlzLnByb3BzLmxheW91dCBpbnN0YW5jZW9mIExlZ2FjeVVuaWZvcm1Sb3dMYXlvdXRcbiAgICApIHtcbiAgICAgIGxheW91dCA9IHVuaWZvcm1Sb3dMYXlvdXQoe1xuICAgICAgICBjYWNoZTogbWVhc3VyZW1lbnRTdG9yZSxcbiAgICAgICAgY29sdW1uV2lkdGgsXG4gICAgICAgIGd1dHRlcixcbiAgICAgICAgbWluQ29scyxcbiAgICAgICAgd2lkdGgsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5b3V0ID0gZGVmYXVsdExheW91dCh7XG4gICAgICAgIGNhY2hlOiBtZWFzdXJlbWVudFN0b3JlLFxuICAgICAgICBjb2x1bW5XaWR0aCxcbiAgICAgICAgZ3V0dGVyLFxuICAgICAgICBtaW5Db2xzLFxuICAgICAgICB3aWR0aCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCBncmlkQm9keTtcbiAgICBpZiAod2lkdGggPT0gbnVsbCAmJiBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzKSB7XG4gICAgICAvLyBXaGVuIGh5cmRhdGluZyBmcm9tIGEgc2VydmVyIHJlbmRlciwgd2UgZG9uJ3QgaGF2ZSB0aGUgd2lkdGggb2YgdGhlIGdyaWRcbiAgICAgIC8vIGFuZCB0aGUgbWVhc3VyZW1lbnQgc3RvcmUgaXMgZW1wdHlcbiAgICAgIGdyaWRCb2R5ID0gKFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuTWFzb25yeX1cbiAgICAgICAgICBzdHlsZT17eyBoZWlnaHQ6IDAsIHdpZHRoOiAnMTAwJScgfX1cbiAgICAgICAgICByZWY9e3RoaXMuc2V0R3JpZFdyYXBwZXJSZWZ9XG4gICAgICAgID5cbiAgICAgICAgICB7aXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbSkubWFwKChpdGVtLCBpKSA9PiAoXG4gICAgICAgICAgICA8ZGl2IC8vIGtlZXAgdGhpcyBpbiBzeW5jIHdpdGggcmVuZGVyTWFzb25yeUNvbXBvbmVudFxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJzdGF0aWNcIlxuICAgICAgICAgICAgICBkYXRhLWdyaWQtaXRlbVxuICAgICAgICAgICAgICBrZXk9e2l9XG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwcHgpIHRyYW5zbGF0ZVkoMHB4KScsXG4gICAgICAgICAgICAgICAgV2Via2l0VHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwcHgpIHRyYW5zbGF0ZVkoMHB4KScsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGZsZXhpYmxlXG4gICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgOiBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbihjb2x1bW5XaWR0aCksIC8vIHdlIGNhbid0IHNldCBhIHdpZHRoIGZvciBzZXJ2ZXIgcmVuZGVyZWQgZmxleGlibGUgaXRlbXNcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgcmVmPXtlbCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVsICYmICFmbGV4aWJsZSkge1xuICAgICAgICAgICAgICAgICAgLy8gb25seSBtZWFzdXJlIGZsZXhpYmxlIGl0ZW1zIG9uIGNsaWVudFxuICAgICAgICAgICAgICAgICAgbWVhc3VyZW1lbnRTdG9yZS5zZXQoaXRlbSwgZWwuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxDb21wb25lbnQgZGF0YT17aXRlbX0gaXRlbUlkeD17aX0gaXNNZWFzdXJpbmc9e2ZhbHNlfSAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID09IG51bGwpIHtcbiAgICAgIC8vIFdoZW4gdGhlIHdpZHRoIGlzIGVtcHR5ICh1c3VhbGx5IGFmdGVyIGEgcmUtbW91bnQpIHJlbmRlciBhbiBlbXB0eVxuICAgICAgLy8gZGl2IHRvIGNvbGxlY3QgdGhlIHdpZHRoIGZvciBsYXlvdXRcbiAgICAgIGdyaWRCb2R5ID0gPGRpdiBzdHlsZT17eyB3aWR0aDogJzEwMCUnIH19IHJlZj17dGhpcy5zZXRHcmlkV3JhcHBlclJlZn0gLz47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZ1bGwgbGF5b3V0IGlzIHBvc3NpYmxlXG4gICAgICBjb25zdCBpdGVtc1RvUmVuZGVyID0gaXRlbXMuZmlsdGVyKFxuICAgICAgICBpdGVtID0+IGl0ZW0gJiYgbWVhc3VyZW1lbnRTdG9yZS5oYXMoaXRlbSlcbiAgICAgICk7XG4gICAgICBjb25zdCBpdGVtc1RvTWVhc3VyZSA9IGl0ZW1zXG4gICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtICYmICFtZWFzdXJlbWVudFN0b3JlLmhhcyhpdGVtKSlcbiAgICAgICAgLnNsaWNlKDAsIG1pbkNvbHMpO1xuXG4gICAgICBjb25zdCBwb3NpdGlvbnMgPSBsYXlvdXQoaXRlbXNUb1JlbmRlcik7XG4gICAgICBjb25zdCBtZWFzdXJpbmdQb3NpdGlvbnMgPSBsYXlvdXQoaXRlbXNUb01lYXN1cmUpO1xuICAgICAgLy8gTWF0aC5tYXgoKSA9PT0gLUluZmluaXR5IHdoZW4gdGhlcmUgYXJlIG5vIHBvc2l0aW9uc1xuICAgICAgY29uc3QgaGVpZ2h0ID0gcG9zaXRpb25zLmxlbmd0aFxuICAgICAgICA/IE1hdGgubWF4KC4uLnBvc2l0aW9ucy5tYXAocG9zID0+IHBvcy50b3AgKyBwb3MuaGVpZ2h0KSlcbiAgICAgICAgOiAwO1xuICAgICAgZ3JpZEJvZHkgPSAoXG4gICAgICAgIDxkaXYgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJyB9fSByZWY9e3RoaXMuc2V0R3JpZFdyYXBwZXJSZWZ9PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuTWFzb25yeX0gc3R5bGU9e3sgaGVpZ2h0LCB3aWR0aCB9fT5cbiAgICAgICAgICAgIHtpdGVtc1RvUmVuZGVyLm1hcCgoaXRlbSwgaSkgPT5cbiAgICAgICAgICAgICAgdGhpcy5yZW5kZXJNYXNvbnJ5Q29tcG9uZW50KGl0ZW0sIGksIHBvc2l0aW9uc1tpXSlcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5NYXNvbnJ5fSBzdHlsZT17eyB3aWR0aCB9fT5cbiAgICAgICAgICAgIHtpdGVtc1RvTWVhc3VyZS5tYXAoKGRhdGEsIGkpID0+IHtcbiAgICAgICAgICAgICAgLy8gaXRlbXNUb01lYXN1cmUgaXMgYWx3YXlzIHRoZSBsZW5ndGggb2YgbWluQ29scywgc28gaSB3aWxsIGFsd2F5cyBiZSAwLi5taW5Db2xzLmxlbmd0aFxuICAgICAgICAgICAgICAvLyB3ZSBub3JtYWxpemUgdGhlIGluZGV4IGhlcmUgcmVsYXRpdmUgdG8gdGhlIGl0ZW0gbGlzdCBhcyBhIHdob2xlIHNvIHRoYXQgaXRlbUlkeCBpcyBjb3JyZWN0XG4gICAgICAgICAgICAgIC8vIGFuZCBzbyB0aGF0IFJlYWN0IGRvZXNudCByZXVzZSB0aGUgbWVhc3VyZW1lbnQgbm9kZXNcbiAgICAgICAgICAgICAgY29uc3QgbWVhc3VyZW1lbnRJbmRleCA9IGl0ZW1zVG9SZW5kZXIubGVuZ3RoICsgaTtcbiAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBtZWFzdXJpbmdQb3NpdGlvbnNbaV07XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAga2V5PXtgbWVhc3VyaW5nLSR7bWVhc3VyZW1lbnRJbmRleH1gfVxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uKHBvc2l0aW9uLnRvcCksXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uKHBvc2l0aW9uLmxlZnQpLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbGF5b3V0TnVtYmVyVG9Dc3NEaW1lbnNpb24ocG9zaXRpb24ud2lkdGgpLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uKHBvc2l0aW9uLmhlaWdodCksXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgcmVmPXtlbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgICAgICAgIG1lYXN1cmVtZW50U3RvcmUuc2V0KGRhdGEsIGVsLmNsaWVudEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPENvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICBkYXRhPXtkYXRhfVxuICAgICAgICAgICAgICAgICAgICBpdGVtSWR4PXttZWFzdXJlbWVudEluZGV4fVxuICAgICAgICAgICAgICAgICAgICBpc01lYXN1cmluZ1xuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pfVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAge3RoaXMuc2Nyb2xsQ29udGFpbmVyICYmIChcbiAgICAgICAgICAgIDxGZXRjaEl0ZW1zXG4gICAgICAgICAgICAgIGNvbnRhaW5lckhlaWdodD17dGhpcy5jb250YWluZXJIZWlnaHR9XG4gICAgICAgICAgICAgIGZldGNoTW9yZT17dGhpcy5mZXRjaE1vcmV9XG4gICAgICAgICAgICAgIGlzRmV0Y2hpbmc9e1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaXNGZXRjaGluZyB8fCB0aGlzLnN0YXRlLmhhc1BlbmRpbmdNZWFzdXJlbWVudHNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgICAgICAgc2Nyb2xsVG9wPXt0aGlzLnN0YXRlLnNjcm9sbFRvcH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnByb3BzLnNjcm9sbENvbnRhaW5lciA/IChcbiAgICAgIDxTY3JvbGxDb250YWluZXJcbiAgICAgICAgcmVmPXt0aGlzLnNldFNjcm9sbENvbnRhaW5lclJlZn1cbiAgICAgICAgb25TY3JvbGw9e3RoaXMudXBkYXRlU2Nyb2xsUG9zaXRpb259XG4gICAgICAgIHNjcm9sbENvbnRhaW5lcj17dGhpcy5wcm9wcy5zY3JvbGxDb250YWluZXJ9XG4gICAgICA+XG4gICAgICAgIHtncmlkQm9keX1cbiAgICAgIDwvU2Nyb2xsQ29udGFpbmVyPlxuICAgICkgOiAoXG4gICAgICBncmlkQm9keVxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJy4vZGVib3VuY2UuanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL01hc29ucnkuY3NzJztcbmltcG9ydCBTY3JvbGxDb250YWluZXIgZnJvbSAnLi9TY3JvbGxDb250YWluZXIuanMnO1xuaW1wb3J0IHRocm90dGxlIGZyb20gJy4vdGhyb3R0bGUuanMnO1xuaW1wb3J0IHR5cGUgeyBDYWNoZSB9IGZyb20gJy4vQ2FjaGUuanMnO1xuaW1wb3J0IE1lYXN1cmVtZW50U3RvcmUgZnJvbSAnLi9NZWFzdXJlbWVudFN0b3JlLmpzJztcbmltcG9ydCB7XG4gIGdldEVsZW1lbnRIZWlnaHQsXG4gIGdldFJlbGF0aXZlU2Nyb2xsVG9wLFxuICBnZXRTY3JvbGxQb3MsXG59IGZyb20gJy4vc2Nyb2xsVXRpbHMuanMnO1xuaW1wb3J0IHtcbiAgRGVmYXVsdExheW91dFN5bWJvbCxcbiAgVW5pZm9ybVJvd0xheW91dFN5bWJvbCxcbn0gZnJvbSAnLi9sZWdhY3lMYXlvdXRTeW1ib2xzLmpzJztcbmltcG9ydCBkZWZhdWx0TGF5b3V0LCB7IHR5cGUgUG9zaXRpb24gfSBmcm9tICcuL2RlZmF1bHRMYXlvdXQuanMnO1xuaW1wb3J0IHVuaWZvcm1Sb3dMYXlvdXQgZnJvbSAnLi91bmlmb3JtUm93TGF5b3V0LmpzJztcbmltcG9ydCBmdWxsV2lkdGhMYXlvdXQgZnJvbSAnLi9mdWxsV2lkdGhMYXlvdXQuanMnO1xuaW1wb3J0IExlZ2FjeU1hc29ucnlMYXlvdXQgZnJvbSAnLi9sYXlvdXRzL01hc29ucnlMYXlvdXQuanMnO1xuaW1wb3J0IExlZ2FjeVVuaWZvcm1Sb3dMYXlvdXQgZnJvbSAnLi9sYXlvdXRzL1VuaWZvcm1Sb3dMYXlvdXQuanMnO1xuXG50eXBlIExheW91dCA9XG4gIHwgdHlwZW9mIERlZmF1bHRMYXlvdXRTeW1ib2xcbiAgfCB0eXBlb2YgVW5pZm9ybVJvd0xheW91dFN5bWJvbFxuICB8IExlZ2FjeU1hc29ucnlMYXlvdXRcbiAgfCBMZWdhY3lVbmlmb3JtUm93TGF5b3V0O1xuXG5leHBvcnQgdHlwZSBNZWFzdXJlbWVudFN0YXRlID0gJ2lkbGUnIHwgJ21lYXN1cmluZyc7XG5cbmV4cG9ydCB0eXBlIFByb3BzPFQ+ID0ge3xcbiAgY29sdW1uV2lkdGg/OiBudW1iZXIsXG4gIGNvbXA6IFJlYWN0LkNvbXBvbmVudFR5cGU8e1xuICAgIGRhdGE6IFQsXG4gICAgaXRlbUlkeDogbnVtYmVyLFxuICAgIGlzTWVhc3VyaW5nOiBib29sZWFuLFxuICB9PixcbiAgZmxleGlibGU/OiBib29sZWFuLFxuICBndXR0ZXJXaWR0aD86IG51bWJlcixcbiAgaXRlbXM6IEFycmF5PFQ+LFxuICBtZWFzdXJlbWVudFN0b3JlOiBDYWNoZTxULCAqPixcbiAgbWluQ29sczogbnVtYmVyLFxuICAvLyBDb250ZW50IGxheWVyIGFuZCBWaWV3cG9ydCBsYXllciBpcyBhcyBkZWZpbmVkIGluIENvbGxlY3Rpb24uXG4gIG9uVmlydHVhbGl6YXRpb25XaW5kb3dVcGRhdGU/OiAoXG4gICAgY29udGVudDogUG9zaXRpb24sXG4gICAgdmlld3BvcnQ6IFBvc2l0aW9uXG4gICkgPT4gdm9pZCxcbiAgb25BdXRvTWVhc3VyaW5nVXBkYXRlPzogKHN0YXRlOiBNZWFzdXJlbWVudFN0YXRlKSA9PiB2b2lkLFxuICBsYXlvdXQ/OiBMYXlvdXQsXG4gIC8vIFN1cHBvcnQgbGVnYWN5IGxvYWRJdGVtcyB1c2FnZS5cbiAgLy8gVE9ETzogU2ltcGxpZnkgbm9uIGZhbHNleSBmbG93dHlwZS5cbiAgbG9hZEl0ZW1zPzpcbiAgICB8IGZhbHNlXG4gICAgfCAoKFxuICAgICAgICA/e1xuICAgICAgICAgIGZyb206IG51bWJlcixcbiAgICAgICAgfVxuICAgICAgKSA9PiB2b2lkIHwgYm9vbGVhbiB8IHt9KSxcbiAgc2Nyb2xsQ29udGFpbmVyPzogKCkgPT4gSFRNTEVsZW1lbnQsXG4gIHZpcnR1YWxCb3VuZHNUb3A/OiBudW1iZXIsXG4gIHZpcnR1YWxCb3VuZHNCb3R0b20/OiBudW1iZXIsXG4gIHZpcnR1YWxpemU/OiBib29sZWFuLFxufH07XG5cbnR5cGUgU3RhdGU8VD4gPSB7fFxuICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzOiBib29sZWFuLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgaXRlbXM6IEFycmF5PFQ+LFxuICBpdGVtc1RvTWVhc3VyZTogQXJyYXk8VD4sXG4gIGl0ZW1zVG9SZW5kZXI6IEFycmF5PFQ+LFxuICBtZWFzdXJpbmdQb3NpdGlvbnM6IEFycmF5PFBvc2l0aW9uPixcbiAgcmVuZGVyUG9zaXRpb25zOiBBcnJheTxQb3NpdGlvbj4sXG4gIHNjcm9sbFRvcDogbnVtYmVyLFxuICB3aWR0aDogP251bWJlcixcbnx9O1xuXG5jb25zdCBSRVNJWkVfREVCT1VOQ0UgPSAzMDA7XG4vLyBNdWx0aXBsaWVkIGFnYWluc3QgY29udGFpbmVyIGhlaWdodC5cbi8vIFRoZSBhbW91bnQgb2YgZXh0cmEgYnVmZmVyIHNwYWNlIGZvciBwb3B1bGF0aW5nIHZpc2libGUgaXRlbXMuXG5jb25zdCBWSVJUVUFMX0JVRkZFUl9GQUNUT1IgPSAwLjc7XG5cbmNvbnN0IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uID0gbiA9PiAobiAhPT0gSW5maW5pdHkgPyBuIDogdW5kZWZpbmVkKTtcblxuZnVuY3Rpb24gbGF5b3V0Q2xhc3M8VD4oXG4gIHtcbiAgICBjb2x1bW5XaWR0aCxcbiAgICBmbGV4aWJsZSxcbiAgICBndXR0ZXJXaWR0aDogZ3V0dGVyLFxuICAgIGxheW91dCxcbiAgICBtZWFzdXJlbWVudFN0b3JlLFxuICAgIG1pbkNvbHMsXG4gIH06IFByb3BzPFQ+LFxuICB7IHdpZHRoIH06IFN0YXRlPFQ+XG4pIHtcbiAgaWYgKGZsZXhpYmxlICYmIHdpZHRoICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bGxXaWR0aExheW91dCh7XG4gICAgICBndXR0ZXIsXG4gICAgICBjYWNoZTogbWVhc3VyZW1lbnRTdG9yZSxcbiAgICAgIG1pbkNvbHMsXG4gICAgICBpZGVhbENvbHVtbldpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgIHdpZHRoLFxuICAgIH0pO1xuICB9XG4gIGlmIChcbiAgICBsYXlvdXQgPT09IFVuaWZvcm1Sb3dMYXlvdXRTeW1ib2wgfHxcbiAgICBsYXlvdXQgaW5zdGFuY2VvZiBMZWdhY3lVbmlmb3JtUm93TGF5b3V0XG4gICkge1xuICAgIHJldHVybiB1bmlmb3JtUm93TGF5b3V0KHtcbiAgICAgIGNhY2hlOiBtZWFzdXJlbWVudFN0b3JlLFxuICAgICAgY29sdW1uV2lkdGgsXG4gICAgICBndXR0ZXIsXG4gICAgICBtaW5Db2xzLFxuICAgICAgd2lkdGgsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRMYXlvdXQoe1xuICAgIGNhY2hlOiBtZWFzdXJlbWVudFN0b3JlLFxuICAgIGNvbHVtbldpZHRoLFxuICAgIGd1dHRlcixcbiAgICBtaW5Db2xzLFxuICAgIHdpZHRoLFxuICB9KTtcbn1cblxuZnVuY3Rpb24gc3RhdGVzRm9yUmVuZGVyaW5nPFQ+KHByb3BzOiBQcm9wczxUPiwgc3RhdGU6IFN0YXRlPFQ+KSB7XG4gIGNvbnN0IHsgbWVhc3VyZW1lbnRTdG9yZSwgbWluQ29scyB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgaXRlbXMgfSA9IHN0YXRlO1xuXG4gIC8vIEZ1bGwgbGF5b3V0IGlzIHBvc3NpYmxlXG4gIGNvbnN0IGl0ZW1zVG9SZW5kZXIgPSBpdGVtcy5maWx0ZXIoXG4gICAgaXRlbSA9PiBpdGVtICYmIG1lYXN1cmVtZW50U3RvcmUuaGFzKGl0ZW0pXG4gICk7XG5cbiAgY29uc3QgbGF5b3V0ID0gbGF5b3V0Q2xhc3MocHJvcHMsIHN0YXRlKTtcbiAgY29uc3QgcmVuZGVyUG9zaXRpb25zID0gbGF5b3V0KGl0ZW1zVG9SZW5kZXIpO1xuICAvLyBNYXRoLm1heCgpID09PSAtSW5maW5pdHkgd2hlbiB0aGVyZSBhcmUgbm8gcmVuZGVyUG9zaXRpb25zXG4gIGNvbnN0IGhlaWdodCA9IHJlbmRlclBvc2l0aW9ucy5sZW5ndGhcbiAgICA/IE1hdGgubWF4KC4uLnJlbmRlclBvc2l0aW9ucy5tYXAocG9zID0+IHBvcy50b3AgKyBwb3MuaGVpZ2h0KSlcbiAgICA6IDA7XG5cbiAgLy8gJEZsb3dJc3N1ZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNjE1MVxuICBjb25zdCBpdGVtc1RvTWVhc3VyZSA9IGl0ZW1zXG4gICAgLmZpbHRlcihpdGVtID0+IGl0ZW0gJiYgIW1lYXN1cmVtZW50U3RvcmUuaGFzKGl0ZW0pKVxuICAgIC5zbGljZSgwLCBtaW5Db2xzKTtcbiAgY29uc3QgbWVhc3VyaW5nUG9zaXRpb25zID0gbGF5b3V0KGl0ZW1zVG9NZWFzdXJlKTtcblxuICByZXR1cm4ge1xuICAgIGhlaWdodCxcbiAgICBpdGVtc1RvUmVuZGVyLFxuICAgIGl0ZW1zVG9NZWFzdXJlLFxuICAgIG1lYXN1cmluZ1Bvc2l0aW9ucyxcbiAgICByZW5kZXJQb3NpdGlvbnMsXG4gIH07XG59XG5cbi8qKlxuICogVGhlIHdpbGwgYmUgdGhlIG5ldyBNYXNvbnJ5QmV0YSB0aGF0IHdpbGwgbm90IGhhdmUgYW55IGZldGNoaW5nIGNvbmNlcm5zLlxuICpcbiAqIEZvciBub3csIGl0IGRpZmZlcnMgd2l0aCBNYXNvbnJ5IG9ubHkgYnkgbm90IGhhdmluZyBhbnkgZmV0Y2hpbmcgbG9naWMuXG4gKlxuICogSXQgaXMgaW4gYmV0YSB1bnRpbCBpdCBjYW4gYmUgYmF0dGxlIHRlc3RlZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFzb25yeUJldGE8VD4gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8XG4gIFByb3BzPFQ+LFxuICBTdGF0ZTxUPlxuPiB7XG4gIC8qKlxuICAgKiBEZWxheXMgcmVzaXplIGhhbmRsaW5nIGluIGNhc2UgdGhlIHNjcm9sbCBjb250YWluZXIgaXMgc3RpbGwgYmVpbmcgcmVzaXplZC5cbiAgICovXG4gIGhhbmRsZVJlc2l6ZSA9IGRlYm91bmNlKCgpID0+IHtcbiAgICBpZiAodGhpcy5ncmlkV3JhcHBlcikge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHdpZHRoOiB0aGlzLmdyaWRXcmFwcGVyLmNsaWVudFdpZHRoIH0pO1xuICAgIH1cbiAgfSwgUkVTSVpFX0RFQk9VTkNFKTtcblxuICB1cGRhdGVTY3JvbGxQb3NpdGlvbiA9IHRocm90dGxlKCgpID0+IHtcbiAgICBpZiAoIXRoaXMuc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lciA9IHRoaXMuc2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbENvbnRhaW5lclJlZigpO1xuXG4gICAgaWYgKCFzY3JvbGxDb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNjcm9sbFRvcDogZ2V0U2Nyb2xsUG9zKHNjcm9sbENvbnRhaW5lciksXG4gICAgfSk7XG5cbiAgICB0aGlzLmhhbmRsZVZpcnR1YWxpemF0aW9uV2luZG93VXBkYXRlKCk7XG4gIH0pO1xuXG4gIG1lYXN1cmVDb250YWluZXJBc3luYyA9IGRlYm91bmNlKCgpID0+IHtcbiAgICB0aGlzLm1lYXN1cmVDb250YWluZXIoKTtcbiAgfSwgMCk7XG5cbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJlZmVycmVkL3RhcmdldCBpdGVtIHdpZHRoLiBJZiBgZmxleGlibGVgIGlzIHNldCwgdGhlIGl0ZW0gd2lkdGggd2lsbFxuICAgICAqIGdyb3cgdG8gZmlsbCBjb2x1bW4gc3BhY2UsIGFuZCBzaHJpbmsgdG8gZml0IGlmIGJlbG93IG1pbiBjb2x1bW5zLlxuICAgICAqL1xuICAgIGNvbHVtbldpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbXBvbmVudCB0byByZW5kZXIuXG4gICAgICovXG4gICAgLyogZXNsaW50IHJlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzOiAwICovXG4gICAgY29tcDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmVmZXJyZWQvdGFyZ2V0IGl0ZW0gd2lkdGguIEl0ZW0gd2lkdGggd2lsbCBncm93IHRvIGZpbGxcbiAgICAgKiBjb2x1bW4gc3BhY2UsIGFuZCBzaHJpbmsgdG8gZml0IGlmIGJlbG93IG1pbiBjb2x1bW5zLlxuICAgICAqL1xuICAgIGZsZXhpYmxlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbW91bnQgb2Ygc3BhY2UgYmV0d2VlbiBlYWNoIGl0ZW0uXG4gICAgICovXG4gICAgZ3V0dGVyV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBhbGwgb2JqZWN0cyB0byBkaXNwbGF5IGluIHRoZSBncmlkLlxuICAgICAqL1xuICAgIGl0ZW1zOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe30pKS5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogTWVhc3VyZW1lbnQgU3RvcmVcbiAgICAgKi9cbiAgICBtZWFzdXJlbWVudFN0b3JlOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihNZWFzdXJlbWVudFN0b3JlKSxcblxuICAgIC8qKlxuICAgICAqIExheW91dCBzeXN0ZW0gdG8gdXNlIGZvciBpdGVtc1xuICAgICAqL1xuICAgIGxheW91dDogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuaW5zdGFuY2VPZihMZWdhY3lNYXNvbnJ5TGF5b3V0KSxcbiAgICAgIFByb3BUeXBlcy5pbnN0YW5jZU9mKExlZ2FjeVVuaWZvcm1Sb3dMYXlvdXQpLFxuICAgICAgUHJvcFR5cGVzLnN5bWJvbCxcbiAgICBdKSxcblxuICAgIC8qKlxuICAgICAqIEEgY2FsbGJhY2sgd2hpY2ggdGhlIGdyaWQgY2FsbHMgd2hlbiB3ZSBuZWVkIHRvIGxvYWQgbW9yZSBpdGVtcyBhcyB0aGUgdXNlciBzY3JvbGxzLlxuICAgICAqIFRoZSBjYWxsYmFjayBzaG91bGQgdXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgaXRlbXMsIGFuZCBwYXNzIHRob3NlIGluIGFzIHByb3BzXG4gICAgICogdG8gdGhpcyBjb21wb25lbnQuXG4gICAgICovXG4gICAgbG9hZEl0ZW1zOiBQcm9wVHlwZXMuZnVuYyxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gbnVtYmVyIG9mIGNvbHVtbnMgdG8gZGlzcGxheS5cbiAgICAgKi9cbiAgICBtaW5Db2xzOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCB0aGUgZ3JpZCBjYWxscyB0byBnZXQgdGhlIHNjcm9sbCBjb250YWluZXIuXG4gICAgICogVGhpcyBpcyByZXF1aXJlZCBpZiB0aGUgZ3JpZCBpcyBleHBlY3RlZCB0byBiZSBzY3JvbGxhYmxlLlxuICAgICAqL1xuICAgIHNjcm9sbENvbnRhaW5lcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byB1c2UgYWN0dWFsIHZpcnR1YWxpemF0aW9uXG4gICAgICovXG4gICAgdmlydHVhbGl6ZTogUHJvcFR5cGVzLmJvb2wsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb2x1bW5XaWR0aDogMjM2LFxuICAgIC8vICRGbG93Rml4TWU6IG5ldyBlcnJvcnMgZm91bmQgZnJvbSBmbG93IDAuOTYgdXBncmFkZVxuICAgIG1lYXN1cmVtZW50U3RvcmU6IG5ldyBNZWFzdXJlbWVudFN0b3JlKCksXG4gICAgbWluQ29sczogMyxcbiAgICBsYXlvdXQ6IERlZmF1bHRMYXlvdXRTeW1ib2wsXG4gICAgbG9hZEl0ZW1zOiAoKSA9PiB7fSxcbiAgICB2aXJ0dWFsaXplOiBmYWxzZSxcbiAgfTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHM8VD4pIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLmNvbnRhaW5lckhlaWdodCA9IDA7XG4gICAgdGhpcy5jb250YWluZXJPZmZzZXQgPSAwO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHM6IHByb3BzLml0ZW1zLnNvbWUoXG4gICAgICAgIGl0ZW0gPT4gISFpdGVtICYmICFwcm9wcy5tZWFzdXJlbWVudFN0b3JlLmhhcyhpdGVtKVxuICAgICAgKSxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIGl0ZW1zVG9SZW5kZXI6IFtdLFxuICAgICAgaXRlbXNUb01lYXN1cmU6IFtdLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLXVudXNlZC1zdGF0ZVxuICAgICAgaXRlbXM6IHByb3BzLml0ZW1zLFxuICAgICAgbWVhc3VyaW5nUG9zaXRpb25zOiBbXSxcbiAgICAgIHJlbmRlclBvc2l0aW9uczogW10sXG4gICAgICBzY3JvbGxUb3A6IDAsXG4gICAgICB3aWR0aDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBob29rcyBhZnRlciB0aGUgY29tcG9uZW50IG1vdW50cy5cbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XG5cbiAgICB0aGlzLm1lYXN1cmVDb250YWluZXIoKTtcblxuICAgIGxldCB7IHNjcm9sbFRvcCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodGhpcy5zY3JvbGxDb250YWluZXIgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyID0gdGhpcy5zY3JvbGxDb250YWluZXIuZ2V0U2Nyb2xsQ29udGFpbmVyUmVmKCk7XG4gICAgICBpZiAoc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICAgIHNjcm9sbFRvcCA9IGdldFNjcm9sbFBvcyhzY3JvbGxDb250YWluZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUocHJldlN0YXRlID0+IHtcbiAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5ncmlkV3JhcHBlclxuICAgICAgICA/IHRoaXMuZ3JpZFdyYXBwZXIuY2xpZW50V2lkdGhcbiAgICAgICAgOiBwcmV2U3RhdGUud2lkdGg7XG4gICAgICBjb25zdCBzdGF0ZVdpdGhXaWR0aCA9IHsgLi4udGhpcy5zdGF0ZSwgd2lkdGggfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjcm9sbFRvcCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIC4uLnN0YXRlc0ZvclJlbmRlcmluZyh0aGlzLnByb3BzLCBzdGF0ZVdpdGhXaWR0aCksXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gbmVlZCB0byBtYWtlIHN1cmUgcGFyZW50IGNvbXBvbmVudCBoYXMgdGhlIGNvcnJlY3QgcGVuZGluZyBtZWFzdXJlbWVudCB2YWx1ZVxuICAgIHRoaXMuaGFuZGxlT25BdXRvTWVhc3VyaW5nVXBkYXRlKFxuICAgICAgdGhpcy5zdGF0ZS5oYXNQZW5kaW5nTWVhc3VyZW1lbnRzID8gJ21lYXN1cmluZycgOiAnaWRsZSdcbiAgICApO1xuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogUHJvcHM8VD4sIHByZXZTdGF0ZTogU3RhdGU8VD4pIHtcbiAgICBjb25zdCB7IGl0ZW1zLCBtZWFzdXJlbWVudFN0b3JlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgdGhpcy5tZWFzdXJlQ29udGFpbmVyQXN5bmMoKTtcblxuICAgIGlmIChwcmV2U3RhdGUud2lkdGggIT0gbnVsbCAmJiB0aGlzLnN0YXRlLndpZHRoICE9PSBwcmV2U3RhdGUud2lkdGgpIHtcbiAgICAgIG1lYXN1cmVtZW50U3RvcmUucmVzZXQoKTtcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIHdoZXRoZXIgd2Ugc3RpbGwgaGF2ZSBwZW5kaW5nIG1lYXN1cmVtZW50c1xuICAgIGNvbnN0IGhhc1BlbmRpbmdNZWFzdXJlbWVudHMgPSBpdGVtcy5zb21lKFxuICAgICAgaXRlbSA9PiAhIWl0ZW0gJiYgIW1lYXN1cmVtZW50U3RvcmUuaGFzKGl0ZW0pXG4gICAgKTtcblxuICAgIGlmIChoYXNQZW5kaW5nTWVhc3VyZW1lbnRzICYmICFwcmV2U3RhdGUuaGFzUGVuZGluZ01lYXN1cmVtZW50cykge1xuICAgICAgdGhpcy5oYW5kbGVPbkF1dG9NZWFzdXJpbmdVcGRhdGUoJ21lYXN1cmluZycpO1xuICAgIH0gZWxzZSBpZiAoIWhhc1BlbmRpbmdNZWFzdXJlbWVudHMgJiYgcHJldlN0YXRlLmhhc1BlbmRpbmdNZWFzdXJlbWVudHMpIHtcbiAgICAgIHRoaXMuaGFuZGxlT25BdXRvTWVhc3VyaW5nVXBkYXRlKCdpZGxlJyk7XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlVmlydHVhbGl6YXRpb25XaW5kb3dVcGRhdGUoKTtcblxuICAgIGlmIChcbiAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMgfHxcbiAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMgIT09IHRoaXMuc3RhdGUuaGFzUGVuZGluZ01lYXN1cmVtZW50cyB8fFxuICAgICAgcHJldlN0YXRlLndpZHRoID09IG51bGxcbiAgICApIHtcbiAgICAgIHRoaXMuaW5zZXJ0QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBjb25zdCByZW5kZXJpbmdTdGF0ZXMgPSBzdGF0ZXNGb3JSZW5kZXJpbmcodGhpcy5wcm9wcywgdGhpcy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMsXG4gICAgICAgICAgLi4ucmVuZGVyaW5nU3RhdGVzLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaGFzUGVuZGluZ01lYXN1cmVtZW50cyB8fCBwcmV2U3RhdGUuaXRlbXMgIT09IGl0ZW1zKSB7XG4gICAgICB0aGlzLmluc2VydEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVuZGVyaW5nU3RhdGVzID0gc3RhdGVzRm9yUmVuZGVyaW5nKHRoaXMucHJvcHMsIHRoaXMuc3RhdGUpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgLi4ucmVuZGVyaW5nU3RhdGVzIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBsaXN0ZW5lcnMgd2hlbiB1bm1vdW50aW5nLlxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuaW5zZXJ0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuaW5zZXJ0QW5pbWF0aW9uRnJhbWUpO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBhc3luYyBtZXRob2RzIGFyZSBjYW5jZWxsZWQuXG4gICAgdGhpcy5tZWFzdXJlQ29udGFpbmVyQXN5bmMuY2xlYXJUaW1lb3V0KCk7XG4gICAgdGhpcy5oYW5kbGVSZXNpemUuY2xlYXJUaW1lb3V0KCk7XG4gICAgdGhpcy51cGRhdGVTY3JvbGxQb3NpdGlvbi5jbGVhclRpbWVvdXQoKTtcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzOiBQcm9wczxUPiwgc3RhdGU6IFN0YXRlPFQ+KSB7XG4gICAgY29uc3QgeyBpdGVtcywgbWVhc3VyZW1lbnRTdG9yZSB9ID0gcHJvcHM7XG4gICAgLy8gd2hlbmV2ZXIgd2UncmUgcmVjZWl2aW5nIG5ldyBwcm9wcywgZGV0ZXJtaW5lIHdoZXRoZXIgYW55IGl0ZW1zIG5lZWQgdG8gYmUgbWVhc3VyZWRcbiAgICAvLyBUT0RPIC0gd2Ugc2hvdWxkIHRyZWF0IGl0ZW1zIGFzIGltbXV0YWJsZVxuICAgIGNvbnN0IGhhc1BlbmRpbmdNZWFzdXJlbWVudHMgPSBpdGVtcy5zb21lKFxuICAgICAgaXRlbSA9PiBpdGVtICYmICFtZWFzdXJlbWVudFN0b3JlLmhhcyhpdGVtKVxuICAgICk7XG5cbiAgICBjb25zdCBuZXdTdGF0ZTogU3RhdGU8VD4gPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMsXG4gICAgICBpdGVtcyxcbiAgICB9O1xuXG4gICAgLy8gU2hhbGxvdyBjb21wYXJlIGFsbCBpdGVtcywgaWYgYW55IGNoYW5nZSByZWZsb3cgdGhlIGdyaWQuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIG91ciBjdXJyZW50IHByb3BzIGFuZCBldmVyeXRoaW5nIG1hdGNoZXMuXG4gICAgICAvLyBJZiB3ZSBoaXQgdGhpcyBjYXNlIGl0IG1lYW5zIHdlIG5lZWQgdG8gaW5zZXJ0IG5ldyBpdGVtcy5cbiAgICAgIGlmIChzdGF0ZS5pdGVtc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGFzUGVuZGluZ01lYXN1cmVtZW50cyxcbiAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICAuLi5zdGF0ZXNGb3JSZW5kZXJpbmcocHJvcHMsIG5ld1N0YXRlKSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgZ3JpZCBpdGVtcyB3aGVuOlxuICAgICAgaWYgKFxuICAgICAgICAvLyBBbiBpdGVtIG9iamVjdCByZWYgZG9lcyBub3QgbWF0Y2guXG4gICAgICAgIGl0ZW1zW2ldICE9PSBzdGF0ZS5pdGVtc1tpXSB8fFxuICAgICAgICAvLyBPciBsZXNzIGl0ZW1zIHRoYW4gd2UgY3VycmVudGx5IGhhdmUgYXJlIHBhc3NlZCBpbi5cbiAgICAgICAgaXRlbXMubGVuZ3RoIDwgc3RhdGUuaXRlbXMubGVuZ3RoXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzLFxuICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgIC4uLnN0YXRlc0ZvclJlbmRlcmluZyhwcm9wcywgbmV3U3RhdGUpLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlc2V0IGl0ZW1zIGlmIG5ldyBpdGVtcyBhcnJheSBpcyBlbXB0eS5cbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwICYmIHN0YXRlLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMsXG4gICAgICAgIGl0ZW1zLFxuICAgICAgICAuLi5zdGF0ZXNGb3JSZW5kZXJpbmcocHJvcHMsIG5ld1N0YXRlKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChoYXNQZW5kaW5nTWVhc3VyZW1lbnRzICE9PSBzdGF0ZS5oYXNQZW5kaW5nTWVhc3VyZW1lbnRzKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgd2UgYWx3YXlzIHVwZGF0ZSBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzLFxuICAgICAgICBpdGVtcyxcbiAgICAgICAgLi4uc3RhdGVzRm9yUmVuZGVyaW5nKHByb3BzLCBuZXdTdGF0ZSksXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFJldHVybiBudWxsIHRvIGluZGljYXRlIG5vIGNoYW5nZSB0byBzdGF0ZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHNldEdyaWRXcmFwcGVyUmVmID0gKHJlZjogP0hUTUxFbGVtZW50KSA9PiB7XG4gICAgdGhpcy5ncmlkV3JhcHBlciA9IHJlZjtcbiAgfTtcblxuICBzZXRTY3JvbGxDb250YWluZXJSZWYgPSAocmVmOiA/U2Nyb2xsQ29udGFpbmVyKSA9PiB7XG4gICAgdGhpcy5zY3JvbGxDb250YWluZXIgPSByZWY7XG4gIH07XG5cbiAgaGFuZGxlVmlydHVhbGl6YXRpb25XaW5kb3dVcGRhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiB0aGlzLnByb3BzLm9uVmlydHVhbGl6YXRpb25XaW5kb3dVcGRhdGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHRoaXMuY29udGFpbmVySGVpZ2h0XG4gICAgKSB7XG4gICAgICBjb25zdCB2aWV3cG9ydCA9IHtcbiAgICAgICAgdG9wOiB0aGlzLnN0YXRlLnNjcm9sbFRvcCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmNvbnRhaW5lckhlaWdodCxcbiAgICAgICAgd2lkdGg6IHdpZHRoIHx8IDAsXG4gICAgICB9O1xuICAgICAgY29uc3QgY29udGVudCA9IHtcbiAgICAgICAgdG9wOiB0aGlzLmNvbnRhaW5lck9mZnNldCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB3aWR0aDogd2lkdGggfHwgMCxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMucHJvcHMub25WaXJ0dWFsaXphdGlvbldpbmRvd1VwZGF0ZShjb250ZW50LCB2aWV3cG9ydCk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZU9uQXV0b01lYXN1cmluZ1VwZGF0ZSA9IChzdGF0ZTogTWVhc3VyZW1lbnRTdGF0ZSkgPT4ge1xuICAgIGlmICh0aGlzLnByb3BzLm9uQXV0b01lYXN1cmluZ1VwZGF0ZSkge1xuICAgICAgdGhpcy5wcm9wcy5vbkF1dG9NZWFzdXJpbmdVcGRhdGUoc3RhdGUpO1xuICAgIH1cbiAgfTtcblxuICBjb250YWluZXJIZWlnaHQ6IG51bWJlcjtcblxuICBjb250YWluZXJPZmZzZXQ6IG51bWJlcjtcblxuICBncmlkV3JhcHBlcjogP0hUTUxFbGVtZW50O1xuXG4gIGluc2VydEFuaW1hdGlvbkZyYW1lOiBBbmltYXRpb25GcmFtZUlEO1xuXG4gIG1lYXN1cmVUaW1lb3V0OiBUaW1lb3V0SUQ7XG5cbiAgc2Nyb2xsQ29udGFpbmVyOiA/U2Nyb2xsQ29udGFpbmVyO1xuXG4gIG1lYXN1cmVDb250YWluZXIoKSB7XG4gICAgaWYgKHRoaXMuc2Nyb2xsQ29udGFpbmVyICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgc2Nyb2xsQ29udGFpbmVyIH0gPSB0aGlzO1xuICAgICAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyUmVmID0gc2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbENvbnRhaW5lclJlZigpO1xuICAgICAgaWYgKHNjcm9sbENvbnRhaW5lclJlZikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckhlaWdodCA9IGdldEVsZW1lbnRIZWlnaHQoc2Nyb2xsQ29udGFpbmVyUmVmKTtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmdyaWRXcmFwcGVyO1xuICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgIGNvbnN0IHJlbGF0aXZlU2Nyb2xsVG9wID0gZ2V0UmVsYXRpdmVTY3JvbGxUb3Aoc2Nyb2xsQ29udGFpbmVyUmVmKTtcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lck9mZnNldCA9XG4gICAgICAgICAgICBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyByZWxhdGl2ZVNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBtZWFzdXJlbWVudHMvcG9zaXRpb25zIGFuZCBmb3JjZSBhIHJlZmxvdyBvZiB0aGUgZW50aXJlIGdyaWQuXG4gICAqIE9ubHkgdXNlIHRoaXMgaWYgYWJzb2x1dGVseSBuZWNlc3NhcnkgLSBleDogV2UgbmVlZCB0byByZWZsb3cgaXRlbXMgaWYgdGhlXG4gICAqIG51bWJlciBvZiBjb2x1bW5zIHdlIHdvdWxkIGRpc3BsYXkgc2hvdWxkIGNoYW5nZSBhZnRlciBhIHJlc2l6ZS5cbiAgICovXG4gIHJlZmxvdygpIHtcbiAgICB0aGlzLnByb3BzLm1lYXN1cmVtZW50U3RvcmUucmVzZXQoKTtcbiAgICB0aGlzLm1lYXN1cmVDb250YWluZXIoKTtcbiAgICB0aGlzLmhhbmRsZVZpcnR1YWxpemF0aW9uV2luZG93VXBkYXRlKCk7XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAgcmVuZGVyTWFzb25yeUNvbXBvbmVudCA9IChpdGVtRGF0YTogVCwgaWR4OiBudW1iZXIsIHBvc2l0aW9uOiAqKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY29tcDogQ29tcG9uZW50LFxuICAgICAgdmlydHVhbGl6ZSxcbiAgICAgIHZpcnR1YWxCb3VuZHNUb3AsXG4gICAgICB2aXJ0dWFsQm91bmRzQm90dG9tLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0IH0gPSBwb3NpdGlvbjtcblxuICAgIGxldCBpc1Zpc2libGU7XG4gICAgaWYgKHRoaXMucHJvcHMuc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICBjb25zdCB2aXJ0dWFsQnVmZmVyID0gdGhpcy5jb250YWluZXJIZWlnaHQgKiBWSVJUVUFMX0JVRkZFUl9GQUNUT1I7XG4gICAgICBjb25zdCBvZmZzZXRTY3JvbGxQb3MgPSB0aGlzLnN0YXRlLnNjcm9sbFRvcCAtIHRoaXMuY29udGFpbmVyT2Zmc2V0O1xuICAgICAgY29uc3Qgdmlld3BvcnRUb3AgPSB2aXJ0dWFsQm91bmRzVG9wXG4gICAgICAgID8gb2Zmc2V0U2Nyb2xsUG9zIC0gdmlydHVhbEJvdW5kc1RvcFxuICAgICAgICA6IG9mZnNldFNjcm9sbFBvcyAtIHZpcnR1YWxCdWZmZXI7XG4gICAgICBjb25zdCB2aWV3cG9ydEJvdHRvbSA9IHZpcnR1YWxCb3VuZHNCb3R0b21cbiAgICAgICAgPyBvZmZzZXRTY3JvbGxQb3MgKyB0aGlzLmNvbnRhaW5lckhlaWdodCArIHZpcnR1YWxCb3VuZHNCb3R0b21cbiAgICAgICAgOiBvZmZzZXRTY3JvbGxQb3MgKyB0aGlzLmNvbnRhaW5lckhlaWdodCArIHZpcnR1YWxCdWZmZXI7XG5cbiAgICAgIGlzVmlzaWJsZSA9ICEoXG4gICAgICAgIHBvc2l0aW9uLnRvcCArIHBvc2l0aW9uLmhlaWdodCA8IHZpZXdwb3J0VG9wIHx8XG4gICAgICAgIHBvc2l0aW9uLnRvcCA+IHZpZXdwb3J0Qm90dG9tXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBubyBzY3JvbGwgY29udGFpbmVyIGlzIHBhc3NlZCBpbiwgaXRlbXMgc2hvdWxkIGFsd2F5cyBiZSB2aXNpYmxlXG4gICAgICBpc1Zpc2libGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1Db21wb25lbnQgPSAoXG4gICAgICA8ZGl2XG4gICAgICAgIGtleT17YGl0ZW0tJHtpZHh9YH1cbiAgICAgICAgY2xhc3NOYW1lPXtbc3R5bGVzLk1hc29ucnlfX0l0ZW0sIHN0eWxlcy5NYXNvbnJ5X19JdGVtX19Nb3VudGVkXS5qb2luKFxuICAgICAgICAgICcgJ1xuICAgICAgICApfVxuICAgICAgICBkYXRhLWdyaWQtaXRlbVxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtsZWZ0fXB4KSB0cmFuc2xhdGVZKCR7dG9wfXB4KWAsXG4gICAgICAgICAgV2Via2l0VHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke2xlZnR9cHgpIHRyYW5zbGF0ZVkoJHt0b3B9cHgpYCxcbiAgICAgICAgICB3aWR0aDogbGF5b3V0TnVtYmVyVG9Dc3NEaW1lbnNpb24od2lkdGgpLFxuICAgICAgICAgIGhlaWdodDogbGF5b3V0TnVtYmVyVG9Dc3NEaW1lbnNpb24oaGVpZ2h0KSxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgPENvbXBvbmVudCBkYXRhPXtpdGVtRGF0YX0gaXRlbUlkeD17aWR4fSBpc01lYXN1cmluZz17ZmFsc2V9IC8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuXG4gICAgcmV0dXJuIHZpcnR1YWxpemUgPyAoaXNWaXNpYmxlICYmIGl0ZW1Db21wb25lbnQpIHx8IG51bGwgOiBpdGVtQ29tcG9uZW50O1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb2x1bW5XaWR0aCxcbiAgICAgIGNvbXA6IENvbXBvbmVudCxcbiAgICAgIGZsZXhpYmxlLFxuICAgICAgbWVhc3VyZW1lbnRTdG9yZSxcbiAgICAgIGl0ZW1zLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMsXG4gICAgICBoZWlnaHQsXG4gICAgICBpdGVtc1RvTWVhc3VyZSxcbiAgICAgIGl0ZW1zVG9SZW5kZXIsXG4gICAgICBtZWFzdXJpbmdQb3NpdGlvbnMsXG4gICAgICByZW5kZXJQb3NpdGlvbnMsXG4gICAgICB3aWR0aCxcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgZ3JpZEJvZHk7XG4gICAgaWYgKHdpZHRoID09IG51bGwgJiYgaGFzUGVuZGluZ01lYXN1cmVtZW50cykge1xuICAgICAgLy8gV2hlbiBoeXJkYXRpbmcgZnJvbSBhIHNlcnZlciByZW5kZXIsIHdlIGRvbid0IGhhdmUgdGhlIHdpZHRoIG9mIHRoZSBncmlkXG4gICAgICAvLyBhbmQgdGhlIG1lYXN1cmVtZW50IHN0b3JlIGlzIGVtcHR5XG4gICAgICBncmlkQm9keSA9IChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLk1hc29ucnl9XG4gICAgICAgICAgc3R5bGU9e3sgaGVpZ2h0OiAwLCB3aWR0aDogJzEwMCUnIH19XG4gICAgICAgICAgcmVmPXt0aGlzLnNldEdyaWRXcmFwcGVyUmVmfVxuICAgICAgICA+XG4gICAgICAgICAge2l0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0pLm1hcCgoaXRlbSwgaSkgPT4gKFxuICAgICAgICAgICAgPGRpdiAvLyBrZWVwIHRoaXMgaW4gc3luYyB3aXRoIHJlbmRlck1hc29ucnlDb21wb25lbnRcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwic3RhdGljXCJcbiAgICAgICAgICAgICAgZGF0YS1ncmlkLWl0ZW1cbiAgICAgICAgICAgICAga2V5PXtpfVxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMHB4KSB0cmFuc2xhdGVZKDBweCknLFxuICAgICAgICAgICAgICAgIFdlYmtpdFRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMHB4KSB0cmFuc2xhdGVZKDBweCknLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBmbGV4aWJsZVxuICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgIDogbGF5b3V0TnVtYmVyVG9Dc3NEaW1lbnNpb24oY29sdW1uV2lkdGgpLCAvLyB3ZSBjYW4ndCBzZXQgYSB3aWR0aCBmb3Igc2VydmVyIHJlbmRlcmVkIGZsZXhpYmxlIGl0ZW1zXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIHJlZj17ZWwgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbCAmJiAhZmxleGlibGUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIG9ubHkgbWVhc3VyZSBmbGV4aWJsZSBpdGVtcyBvbiBjbGllbnRcbiAgICAgICAgICAgICAgICAgIG1lYXN1cmVtZW50U3RvcmUuc2V0KGl0ZW0sIGVsLmNsaWVudEhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8Q29tcG9uZW50IGRhdGE9e2l0ZW19IGl0ZW1JZHg9e2l9IGlzTWVhc3VyaW5nPXtmYWxzZX0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICkpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgICAvLyBXaGVuIHRoZSB3aWR0aCBpcyBlbXB0eSAodXN1YWxseSBhZnRlciBhIHJlLW1vdW50KSByZW5kZXIgYW4gZW1wdHlcbiAgICAgIC8vIGRpdiB0byBjb2xsZWN0IHRoZSB3aWR0aCBmb3IgbGF5b3V0XG4gICAgICBncmlkQm9keSA9IDxkaXYgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJyB9fSByZWY9e3RoaXMuc2V0R3JpZFdyYXBwZXJSZWZ9IC8+O1xuICAgIH0gZWxzZSB7XG4gICAgICBncmlkQm9keSA9IChcbiAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogJzEwMCUnIH19IHJlZj17dGhpcy5zZXRHcmlkV3JhcHBlclJlZn0+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5NYXNvbnJ5fSBzdHlsZT17eyBoZWlnaHQsIHdpZHRoIH19PlxuICAgICAgICAgICAge2l0ZW1zVG9SZW5kZXIubWFwKChpdGVtLCBpKSA9PlxuICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIHRoaXMgaXMgdGhlIHJpZ2h0IGRlZmluaXRpb24sIGl0IGFuIEFycmF5PFQ+XG4gICAgICAgICAgICAgIHRoaXMucmVuZGVyTWFzb25yeUNvbXBvbmVudChpdGVtLCBpLCByZW5kZXJQb3NpdGlvbnNbaV0pXG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuTWFzb25yeX0gc3R5bGU9e3sgd2lkdGggfX0+XG4gICAgICAgICAgICB7aXRlbXNUb01lYXN1cmUubWFwKChkYXRhLCBpKSA9PiB7XG4gICAgICAgICAgICAgIC8vIGl0ZW1zVG9NZWFzdXJlIGlzIGFsd2F5cyB0aGUgbGVuZ3RoIG9mIG1pbkNvbHMsIHNvIGkgd2lsbCBhbHdheXMgYmUgMC4ubWluQ29scy5sZW5ndGhcbiAgICAgICAgICAgICAgLy8gd2Ugbm9ybWFsaXplIHRoZSBpbmRleCBoZXJlIHJlbGF0aXZlIHRvIHRoZSBpdGVtIGxpc3QgYXMgYSB3aG9sZSBzbyB0aGF0IGl0ZW1JZHggaXMgY29ycmVjdFxuICAgICAgICAgICAgICAvLyBhbmQgc28gdGhhdCBSZWFjdCBkb2VzbnQgcmV1c2UgdGhlIG1lYXN1cmVtZW50IG5vZGVzXG4gICAgICAgICAgICAgIGNvbnN0IG1lYXN1cmVtZW50SW5kZXggPSBpdGVtc1RvUmVuZGVyLmxlbmd0aCArIGk7XG4gICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gbWVhc3VyaW5nUG9zaXRpb25zW2ldO1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgIGtleT17YG1lYXN1cmluZy0ke21lYXN1cmVtZW50SW5kZXh9YH1cbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbihwb3NpdGlvbi50b3ApLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbihwb3NpdGlvbi5sZWZ0KSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uKHBvc2l0aW9uLndpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbihwb3NpdGlvbi5oZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgIHJlZj17ZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlbWVudFN0b3JlLnNldChkYXRhLCBlbC5jbGllbnRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxDb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgZGF0YT17ZGF0YX1cbiAgICAgICAgICAgICAgICAgICAgaXRlbUlkeD17bWVhc3VyZW1lbnRJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgaXNNZWFzdXJpbmdcbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnByb3BzLnNjcm9sbENvbnRhaW5lciA/IChcbiAgICAgIDxTY3JvbGxDb250YWluZXJcbiAgICAgICAgcmVmPXt0aGlzLnNldFNjcm9sbENvbnRhaW5lclJlZn1cbiAgICAgICAgb25TY3JvbGw9e3RoaXMudXBkYXRlU2Nyb2xsUG9zaXRpb259XG4gICAgICAgIHNjcm9sbENvbnRhaW5lcj17dGhpcy5wcm9wcy5zY3JvbGxDb250YWluZXJ9XG4gICAgICA+XG4gICAgICAgIHtncmlkQm9keX1cbiAgICAgIDwvU2Nyb2xsQ29udGFpbmVyPlxuICAgICkgOiAoXG4gICAgICBncmlkQm9keVxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRmV0Y2hJdGVtcyBmcm9tICcuL0ZldGNoSXRlbXMuanMnO1xuaW1wb3J0IE1lYXN1cmVtZW50U3RvcmUgZnJvbSAnLi9NZWFzdXJlbWVudFN0b3JlLmpzJztcbmltcG9ydCBNYXNvbnJ5LCB7IHR5cGUgUHJvcHMsIHR5cGUgTWVhc3VyZW1lbnRTdGF0ZSB9IGZyb20gJy4vTWFzb25yeUJldGEuanMnO1xuaW1wb3J0IHsgdHlwZSBQb3NpdGlvbiB9IGZyb20gJy4vZGVmYXVsdExheW91dC5qcyc7XG5cbnR5cGUgU3RhdGU8VD4gPSB7fFxuICBjb250YWluZXJIZWlnaHQ6IG51bWJlcixcbiAgaGFzUGVuZGluZ01lYXN1cmVtZW50czogYm9vbGVhbixcbiAgaXNGZXRjaGluZzogYm9vbGVhbixcbiAgaXRlbXM6IEFycmF5PFQ+LFxuICBzY3JvbGxUb3A6IG51bWJlcixcbiAgc2Nyb2xsSGVpZ2h0OiBudW1iZXIsXG58fTtcblxuLyoqXG4gKiBUaGlzIE1hc29ucnlJbmZpbml0ZUJldGEgaXMgYmFja3dhcmQgY29tcGF0aWJsZSB3aXRoIE1hc29ucnkgYW5kXG4gKiBzZXJ2ZXMgdG8gaGVscCB3aXRoIG1pZ3JhdGluZyB0byBhIE1hc3JvbnkgdGhhdCBkb2Vzbid0IGhhdmVcbiAqIHRoZSBzY3JvbCBmZXRjaCBjb25jZXJucy5cbiAqXG4gKiBJdCBpcyBpbiBiZXRhIHNvIHRoYXQgaXQgY2FuIGJlIGJhdHRsZSB0ZXN0ZWQuXG4gKlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXNvbnJ5SW5maW5pdGVCZXRhPFQ+IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFxuICBQcm9wczxUPixcbiAgU3RhdGU8VD5cbj4ge1xuICBzdGF0aWMgY3JlYXRlTWVhc3VyZW1lbnRTdG9yZSgpIHtcbiAgICAvLyAkRmxvd0ZpeE1lOiBuZXcgZXJyb3JzIGZvdW5kIGZyb20gZmxvdyAwLjk2IHVwZ3JhZGVcbiAgICByZXR1cm4gbmV3IE1lYXN1cmVtZW50U3RvcmUoKTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSBNYXNvbnJ5LmRlZmF1bHRQcm9wcztcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHM8VD4pIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgY29udGFpbmVySGVpZ2h0OiAwLFxuICAgICAgaGFzUGVuZGluZ01lYXN1cmVtZW50czogZmFsc2UsXG4gICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby11bnVzZWQtc3RhdGVcbiAgICAgIGl0ZW1zOiBwcm9wcy5pdGVtcyxcbiAgICAgIHNjcm9sbFRvcDogMCxcbiAgICAgIHNjcm9sbEhlaWdodDogMCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnRlbnQgbGF5ZXIgYW5kIFZpZXdwb3J0IGxheWVyIGlzIGFzIGRlZmluZWQgaW4gQ29sbGVjdGlvbi5cbiAgICovXG4gIG9uVmlydHVhbGl6YXRpb25XaW5kb3dVcGRhdGUgPSAoY29udGVudDogUG9zaXRpb24sIHZpZXdwb3J0OiBQb3NpdGlvbikgPT4ge1xuICAgIGNvbnN0IHsgY29udGFpbmVySGVpZ2h0LCBzY3JvbGxUb3AsIHNjcm9sbEhlaWdodCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoXG4gICAgICB2aWV3cG9ydC5oZWlnaHQgIT09IGNvbnRhaW5lckhlaWdodCB8fFxuICAgICAgdmlld3BvcnQudG9wICE9PSBzY3JvbGxUb3AgfHxcbiAgICAgIGNvbnRlbnQuaGVpZ2h0ICE9PSBzY3JvbGxIZWlnaHRcbiAgICApIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBjb250YWluZXJIZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCxcbiAgICAgICAgc2Nyb2xsVG9wOiB2aWV3cG9ydC50b3AsXG4gICAgICAgIHNjcm9sbEhlaWdodDogY29udGVudC5oZWlnaHQsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wczogUHJvcHM8VD4sIHN0YXRlOiBTdGF0ZTxUPikge1xuICAgIGNvbnN0IHsgaXRlbXMgfSA9IHByb3BzO1xuXG4gICAgLy8gYXNzdW1lIGltbXV0YWJsZSBpdGVtc1xuICAgIGlmIChwcm9wcy5pdGVtcyAhPT0gc3RhdGUuaXRlbXMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGl0ZW1zLFxuICAgICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIG51bGwgdG8gaW5kaWNhdGUgbm8gY2hhbmdlIHRvIHN0YXRlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc2V0UmVmID0gKHJlZjogUmVhY3QuRWxlbWVudFJlZjwqPikgPT4ge1xuICAgIGlmIChyZWYpIHtcbiAgICAgIHRoaXMuZ3JpZFJlZiA9IHJlZjtcbiAgICB9XG4gIH07XG5cbiAgZmV0Y2hNb3JlID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgbG9hZEl0ZW1zIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChsb2FkSXRlbXMgJiYgdHlwZW9mIGxvYWRJdGVtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgICAge1xuICAgICAgICAgIGlzRmV0Y2hpbmc6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IGxvYWRJdGVtcyh7IGZyb206IHRoaXMucHJvcHMuaXRlbXMubGVuZ3RoIH0pXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVPbkF1dG9NZWFzdXJpbmdVcGRhdGUgPSAoc3RhdGU6IE1lYXN1cmVtZW50U3RhdGUpID0+IHtcbiAgICBjb25zdCBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzID0gc3RhdGUgPT09ICdtZWFzdXJpbmcnO1xuICAgIGlmICh0aGlzLnN0YXRlLmhhc1BlbmRpbmdNZWFzdXJlbWVudHMgIT09IGhhc1BlbmRpbmdNZWFzdXJlbWVudHMpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vbkF1dG9NZWFzdXJpbmdVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMucHJvcHMub25BdXRvTWVhc3VyaW5nVXBkYXRlKHN0YXRlKTtcbiAgICB9XG4gIH07XG5cbiAgcmVmbG93ID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLmdyaWRSZWYpIHtcbiAgICAgIHRoaXMuZ3JpZFJlZi5yZWZsb3coKTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLmdyaWRSZWYpIHtcbiAgICAgIHRoaXMuZ3JpZFJlZi5oYW5kbGVSZXNpemUoKTtcbiAgICB9XG4gIH07XG5cbiAgZ3JpZFJlZjogTWFzb25yeTxUPjtcblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuc2Nyb2xsQ29udGFpbmVyID8gKFxuICAgICAgPFJlYWN0LkZyYWdtZW50PlxuICAgICAgICA8RmV0Y2hJdGVtc1xuICAgICAgICAgIGNvbnRhaW5lckhlaWdodD17dGhpcy5zdGF0ZS5jb250YWluZXJIZWlnaHR9XG4gICAgICAgICAgZmV0Y2hNb3JlPXt0aGlzLmZldGNoTW9yZX1cbiAgICAgICAgICBpc0ZldGNoaW5nPXtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaXNGZXRjaGluZyB8fCB0aGlzLnN0YXRlLmhhc1BlbmRpbmdNZWFzdXJlbWVudHNcbiAgICAgICAgICB9XG4gICAgICAgICAgc2Nyb2xsSGVpZ2h0PXt0aGlzLnN0YXRlLnNjcm9sbEhlaWdodH1cbiAgICAgICAgICBzY3JvbGxUb3A9e3RoaXMuc3RhdGUuc2Nyb2xsVG9wfVxuICAgICAgICAvPlxuICAgICAgICA8TWFzb25yeVxuICAgICAgICAgIHsuLi50aGlzLnByb3BzfVxuICAgICAgICAgIG9uVmlydHVhbGl6YXRpb25XaW5kb3dVcGRhdGU9e3RoaXMub25WaXJ0dWFsaXphdGlvbldpbmRvd1VwZGF0ZX1cbiAgICAgICAgICBvbkF1dG9NZWFzdXJpbmdVcGRhdGU9e3RoaXMuaGFuZGxlT25BdXRvTWVhc3VyaW5nVXBkYXRlfVxuICAgICAgICAgIHJlZj17dGhpcy5zZXRSZWZ9XG4gICAgICAgIC8+XG4gICAgICA8L1JlYWN0LkZyYWdtZW50PlxuICAgICkgOiAoXG4gICAgICA8TWFzb25yeSB7Li4udGhpcy5wcm9wc30gcmVmPXt0aGlzLnNldFJlZn0gLz5cbiAgICApO1xuICB9XG59XG4iLCIvKiBAZmxvdyAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hpbGRyZW46IFJlYWN0Lk5vZGUsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9TY3JvbGxCZWhhdmlvciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcz4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5wcmV2T3ZlcmZsb3cgPSBudWxsO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnByZXZPdmVyZmxvdyA9IHdpbmRvdy5kb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93O1xuICAgICAgd2luZG93LmRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gdGhpcy5wcmV2T3ZlcmZsb3c7XG4gICAgfVxuICB9XG5cbiAgcHJldk92ZXJmbG93OiBzdHJpbmcgfCBudWxsO1xuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufVxuIiwiLyogQGZsb3cgKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbnx9O1xuXG5mdW5jdGlvbiBxdWVyeUZvY3VzYWJsZUFsbChlbDogSFRNTERpdkVsZW1lbnQpIHtcbiAgY29uc3Qgc2VsZWN0b3IgPSBbXG4gICAgJ2FbaHJlZl0nLFxuICAgICdhcmVhW2hyZWZdJyxcbiAgICAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pJyxcbiAgICAnc2VsZWN0Om5vdChbZGlzYWJsZWRdKScsXG4gICAgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKScsXG4gICAgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLFxuICAgICdpZnJhbWUnLFxuICAgICdvYmplY3QnLFxuICAgICdlbWJlZCcsXG4gICAgJ1t0YWJpbmRleD1cIi0xXCJdJyxcbiAgICAnW3RhYmluZGV4PVwiMFwiXScsXG4gICAgJ1tjb250ZW50ZWRpdGFibGVdJyxcbiAgICAnYXVkaW9bY29udHJvbHNdJyxcbiAgICAndmlkZW9bY29udHJvbHNdJyxcbiAgICAnc3VtbWFyeScsXG4gIF0uam9pbignLCcpO1xuICByZXR1cm4gZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG59XG5cbmNvbnN0IGZvY3VzRWxlbWVudCA9IChlbDogSFRNTEVsZW1lbnQpID0+IHtcbiAgaWYgKHR5cGVvZiBlbC5mb2N1cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVsLmZvY3VzKCk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYXBGb2N1c0JlaGF2aW9yIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzPiB7XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMucHJldmlvdXNseUZvY3VzZWRFbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgdGhpcy5mb2N1c0ZpcnN0Q2hpbGQoKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuaGFuZGxlRm9jdXMsIHRydWUpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzLCB0cnVlKTtcbiAgICBpZiAodGhpcy5wcmV2aW91c2x5Rm9jdXNlZEVsKSB7XG4gICAgICBmb2N1c0VsZW1lbnQodGhpcy5wcmV2aW91c2x5Rm9jdXNlZEVsKTtcbiAgICB9XG4gIH1cblxuICBzZXRFbFJlZiA9IChlbDogP0hUTUxEaXZFbGVtZW50KSA9PiB7XG4gICAgaWYgKGVsKSB7XG4gICAgICB0aGlzLmVsID0gZWw7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZUZvY3VzID0gKGV2ZW50OiBGb2N1c0V2ZW50KSA9PiB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMuZWwgfHxcbiAgICAgIChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmIHRoaXMuZWwuY29udGFpbnMoZXZlbnQudGFyZ2V0KSlcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuZm9jdXNGaXJzdENoaWxkKCk7XG4gIH07XG5cbiAgZm9jdXNGaXJzdENoaWxkKCkge1xuICAgIGNvbnN0IHsgZWwgfSA9IHRoaXM7XG4gICAgaWYgKGVsKSB7XG4gICAgICBmb2N1c0VsZW1lbnQocXVlcnlGb2N1c2FibGVBbGwoZWwpWzBdKTtcbiAgICB9XG4gIH1cblxuICBlbDogP0hUTUxEaXZFbGVtZW50O1xuXG4gIHByZXZpb3VzbHlGb2N1c2VkRWw6ID9IVE1MRWxlbWVudDtcblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIDxkaXYgcmVmPXt0aGlzLnNldEVsUmVmfT57dGhpcy5wcm9wcy5jaGlsZHJlbn08L2Rpdj47XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5pbXBvcnQgRGl2aWRlciBmcm9tICcuL0RpdmlkZXIuanMnO1xuaW1wb3J0IEhlYWRpbmcgZnJvbSAnLi9IZWFkaW5nLmpzJztcbmltcG9ydCBJY29uQnV0dG9uIGZyb20gJy4vSWNvbkJ1dHRvbi5qcyc7XG5pbXBvcnQgU3RvcFNjcm9sbEJlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL1N0b3BTY3JvbGxCZWhhdmlvci5qcyc7XG5pbXBvcnQgVHJhcEZvY3VzQmVoYXZpb3IgZnJvbSAnLi9iZWhhdmlvcnMvVHJhcEZvY3VzQmVoYXZpb3IuanMnO1xuaW1wb3J0IE91dHNpZGVFdmVudEJlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL091dHNpZGVFdmVudEJlaGF2aW9yLmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9Nb2RhbC5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgYWNjZXNzaWJpbGl0eUNsb3NlTGFiZWw6IHN0cmluZyxcbiAgYWNjZXNzaWJpbGl0eU1vZGFsTGFiZWw6IHN0cmluZyxcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICBmb290ZXI/OiBSZWFjdC5Ob2RlLFxuICBoZWFkaW5nOiBzdHJpbmcgfCBSZWFjdC5Ob2RlLFxuICBvbkRpc21pc3M6ICgpID0+IHZvaWQsXG4gIHJvbGU/OiAnYWxlcnRkaWFsb2cnIHwgJ2RpYWxvZycsXG4gIHNpemU/OiAnc20nIHwgJ21kJyB8ICdsZycgfCBudW1iZXIsXG58fTtcblxuY29uc3QgU0laRV9XSURUSF9NQVAgPSB7XG4gIHNtOiA0MTQsXG4gIG1kOiA1NDQsXG4gIGxnOiA4MDQsXG59O1xuXG5jb25zdCBFU0NBUEVfS0VZX0NPREUgPSAyNztcblxuZnVuY3Rpb24gQmFja2Ryb3AoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuPzogUmVhY3QuTm9kZSB9KSB7XG4gIHJldHVybiAoXG4gICAgPFJlYWN0LkZyYWdtZW50PlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5CYWNrZHJvcH0gLz5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1JlYWN0LkZyYWdtZW50PlxuICApO1xufVxuXG5mdW5jdGlvbiBIZWFkZXIoe1xuICBoZWFkaW5nLFxuICByb2xlLFxufToge1xuICBoZWFkaW5nOiBzdHJpbmcgfCBSZWFjdC5Ob2RlLFxuICByb2xlPzogJ2FsZXJ0ZGlhbG9nJyB8ICdkaWFsb2cnLFxufSkge1xuICBpZiAodHlwZW9mIGhlYWRpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGhlYWRpbmc7XG4gIH1cblxuICBpZiAocm9sZSA9PT0gJ2RpYWxvZycpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPEJveFxuICAgICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7XG4gICAgICAgICAgX19zdHlsZTogeyBwYWRkaW5nTGVmdDogNTAsIHBhZGRpbmdSaWdodDogNTAgfSxcbiAgICAgICAgfX1cbiAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICBqdXN0aWZ5Q29udGVudD1cImNlbnRlclwiXG4gICAgICAgIHBhZGRpbmdZPXs1fVxuICAgICAgPlxuICAgICAgICA8SGVhZGluZyBzaXplPVwieHNcIiBhY2Nlc3NpYmlsaXR5TGV2ZWw9ezF9PlxuICAgICAgICAgIHtoZWFkaW5nfVxuICAgICAgICA8L0hlYWRpbmc+XG4gICAgICA8L0JveD5cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8Qm94IGRpc3BsYXk9XCJmbGV4XCIgcGFkZGluZz17NH0+XG4gICAgICA8SGVhZGluZyBzaXplPVwic21cIiBhY2Nlc3NpYmlsaXR5TGV2ZWw9ezF9PlxuICAgICAgICB7aGVhZGluZ31cbiAgICAgIDwvSGVhZGluZz5cbiAgICA8L0JveD5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kYWwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHM+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBhY2Nlc3NpYmlsaXR5Q2xvc2VMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGFjY2Vzc2liaWxpdHlNb2RhbExhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgIGZvb3RlcjogUHJvcFR5cGVzLm5vZGUsXG4gICAgaGVhZGluZzogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm5vZGVdKS5pc1JlcXVpcmVkLFxuICAgIG9uRGlzbWlzczogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcm9sZTogUHJvcFR5cGVzLm9uZU9mKFsnYWxlcnRkaWFsb2cnLCAnZGlhbG9nJ10pLFxuICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgUHJvcFR5cGVzLm51bWJlcixcbiAgICAgIFByb3BUeXBlcy5vbmVPZihbJ3NtJywgJ21kJywgJ2xnJ10pLFxuICAgIF0pLFxuICB9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuaGFuZGxlS2V5VXApO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5oYW5kbGVLZXlVcCk7XG4gIH1cblxuICBoYW5kbGVPdXRzaWRlQ2xpY2sgPSAoKSA9PiB7XG4gICAgdGhpcy5wcm9wcy5vbkRpc21pc3MoKTtcbiAgfTtcblxuICBoYW5kbGVDbG9zZUNsaWNrID0gKCkgPT4ge1xuICAgIHRoaXMucHJvcHMub25EaXNtaXNzKCk7XG4gIH07XG5cbiAgaGFuZGxlS2V5VXAgPSAoZXZlbnQ6IHsga2V5Q29kZTogbnVtYmVyIH0pID0+IHtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gRVNDQVBFX0tFWV9DT0RFKSB7XG4gICAgICB0aGlzLnByb3BzLm9uRGlzbWlzcygpO1xuICAgIH1cbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWNjZXNzaWJpbGl0eUNsb3NlTGFiZWwsXG4gICAgICBhY2Nlc3NpYmlsaXR5TW9kYWxMYWJlbCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZm9vdGVyLFxuICAgICAgaGVhZGluZyxcbiAgICAgIHJvbGUgPSAnZGlhbG9nJyxcbiAgICAgIHNpemUgPSAnc20nLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3Qgd2lkdGggPSB0eXBlb2Ygc2l6ZSA9PT0gJ3N0cmluZycgPyBTSVpFX1dJRFRIX01BUFtzaXplXSA6IHNpemU7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFN0b3BTY3JvbGxCZWhhdmlvcj5cbiAgICAgICAgPFRyYXBGb2N1c0JlaGF2aW9yPlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e2FjY2Vzc2liaWxpdHlNb2RhbExhYmVsfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuY29udGFpbmVyfVxuICAgICAgICAgICAgcm9sZT17cm9sZX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8QmFja2Ryb3A+XG4gICAgICAgICAgICAgIDxPdXRzaWRlRXZlbnRCZWhhdmlvciBvbkNsaWNrPXt0aGlzLmhhbmRsZU91dHNpZGVDbGlja30+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfSB0YWJJbmRleD17LTF9IHN0eWxlPXt7IHdpZHRoIH19PlxuICAgICAgICAgICAgICAgICAgPEJveFxuICAgICAgICAgICAgICAgICAgICBmbGV4PVwiZ3Jvd1wiXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uPVwicmVsYXRpdmVcIlxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5PVwiZmxleFwiXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbj1cImNvbHVtblwiXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxCb3ggZml0PlxuICAgICAgICAgICAgICAgICAgICAgIDxIZWFkZXIgaGVhZGluZz17aGVhZGluZ30gcm9sZT17cm9sZX0gLz5cbiAgICAgICAgICAgICAgICAgICAgICB7cm9sZSA9PT0gJ2RpYWxvZycgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgPFJlYWN0LkZyYWdtZW50PlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8Qm94IHBhZGRpbmc9ezJ9IHBvc2l0aW9uPVwiYWJzb2x1dGVcIiB0b3AgcmlnaHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlMYWJlbD17YWNjZXNzaWJpbGl0eUNsb3NlTGFiZWx9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwiY2FuY2VsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xvc2VDbGlja31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPERpdmlkZXIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvUmVhY3QuRnJhZ21lbnQ+XG4gICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgICAgICAgICAgIDxCb3ggZmxleD1cImdyb3dcIiBvdmVyZmxvdz1cImF1dG9cIiBwb3NpdGlvbj1cInJlbGF0aXZlXCI+XG4gICAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICAgICAgICAgICAgPEJveCBmaXQ+XG4gICAgICAgICAgICAgICAgICAgICAge2Zvb3RlciAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8Qm94PlxuICAgICAgICAgICAgICAgICAgICAgICAgICB7cm9sZSA9PT0gJ2RpYWxvZycgJiYgPERpdmlkZXIgLz59XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxCb3ggcGFkZGluZz17NH0+e2Zvb3Rlcn08L0JveD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQm94PlxuICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDwvQm94PlxuICAgICAgICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvT3V0c2lkZUV2ZW50QmVoYXZpb3I+XG4gICAgICAgICAgICA8L0JhY2tkcm9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L1RyYXBGb2N1c0JlaGF2aW9yPlxuICAgICAgPC9TdG9wU2Nyb2xsQmVoYXZpb3I+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9QdWxzYXIuY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIHBhdXNlZD86IGJvb2xlYW4sXG4gIHNpemU/OiBudW1iZXIsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUHVsc2FyKHsgcGF1c2VkLCBzaXplID0gMTM1IH06IFByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPEJveFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17e1xuICAgICAgICBfX3N0eWxlOiB7XG4gICAgICAgICAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHBhdXNlZCA/IDAgOiAnaW5maW5pdGUnLFxuICAgICAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICAgICAgICBib3hTaGFkb3c6ICdub25lJyxcbiAgICAgICAgfSxcbiAgICAgIH19XG4gICAgICBkaXNwbGF5PXtwYXVzZWQgPyAnbm9uZScgOiAnYmxvY2snfVxuICAgICAgaGVpZ2h0PXtzaXplfVxuICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgICB3aWR0aD17c2l6ZX1cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmlubmVyQ2lyY2xlfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5vdXRlckNpcmNsZX0gLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvQm94PlxuICApO1xufVxuXG5QdWxzYXIucHJvcFR5cGVzID0ge1xuICBwYXVzZWQ6IFByb3BUeXBlcy5ib29sLFxuICBzaXplOiBQcm9wVHlwZXMubnVtYmVyLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vUmFkaW9CdXR0b24uY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoZWNrZWQ/OiBib29sZWFuLFxuICBkaXNhYmxlZD86IGJvb2xlYW4sXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU/OiBzdHJpbmcsXG4gIG9uQ2hhbmdlOiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PD4sXG4gICAgY2hlY2tlZDogYm9vbGVhbixcbiAgfSkgPT4gdm9pZCxcbiAgdmFsdWU6IHN0cmluZyxcbiAgc2l6ZT86ICdzbScgfCAnbWQnLFxufH07XG5cbnR5cGUgU3RhdGUgPSB7fFxuICBmb2N1c2VkOiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGlvQnV0dG9uIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydzbScsICdtZCddKSxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGNoZWNrZWQ6IGZhbHNlLFxuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBzaXplOiAnbWQnLFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIGZvY3VzZWQ6IGZhbHNlLFxuICB9O1xuXG4gIGhhbmRsZUNoYW5nZSA9IChldmVudDogU3ludGhldGljSW5wdXRFdmVudDw+KSA9PiB7XG4gICAgY29uc3QgeyBvbkNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGNoZWNrZWQgfSA9IGV2ZW50LnRhcmdldDtcbiAgICBvbkNoYW5nZSh7IGNoZWNrZWQsIGV2ZW50IH0pO1xuICB9O1xuXG4gIGhhbmRsZUJsdXIgPSAoKSA9PiB0aGlzLnNldFN0YXRlKHsgZm9jdXNlZDogZmFsc2UgfSk7XG5cbiAgaGFuZGxlRm9jdXMgPSAoKSA9PiB0aGlzLnNldFN0YXRlKHsgZm9jdXNlZDogdHJ1ZSB9KTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjaGVja2VkLCBkaXNhYmxlZCwgaWQsIG5hbWUsIHNpemUsIHZhbHVlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgZm9jdXNlZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoc3R5bGVzLlJhZGlvQnV0dG9uLCB7XG4gICAgICAgICAgW3N0eWxlcy5SYWRpb0J1dHRvbklzRm9jdXNlZF06IGZvY3VzZWQsXG4gICAgICAgICAgW3N0eWxlcy5SYWRpb0J1dHRvblNtXTogc2l6ZSA9PT0gJ3NtJyxcbiAgICAgICAgICBbc3R5bGVzLlJhZGlvQnV0dG9uTWRdOiBzaXplID09PSAnbWQnLFxuICAgICAgICAgIFtzdHlsZXMuUmFkaW9CdXR0b25XaGl0ZUJnXTogIWRpc2FibGVkIHx8IGNoZWNrZWQsXG4gICAgICAgICAgW3N0eWxlcy5SYWRpb0J1dHRvbkxpZ2h0R3JheUJnXTogZGlzYWJsZWQgJiYgIWNoZWNrZWQsXG4gICAgICAgIH0pfVxuICAgICAgPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfVxuICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NuYW1lcyhzdHlsZXMuSW5wdXQsIHtcbiAgICAgICAgICAgIFtzdHlsZXMuSW5wdXRFbmFibGVkXTogIWRpc2FibGVkLFxuICAgICAgICAgICAgW3N0eWxlcy5JbnB1dFNtXTogc2l6ZSA9PT0gJ3NtJyxcbiAgICAgICAgICAgIFtzdHlsZXMuSW5wdXRNZF06IHNpemUgPT09ICdtZCcsXG4gICAgICAgICAgfSl9XG4gICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgIGlkPXtpZH1cbiAgICAgICAgICBuYW1lPXtuYW1lfVxuICAgICAgICAgIG9uQmx1cj17dGhpcy5oYW5kbGVCbHVyfVxuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZUNoYW5nZX1cbiAgICAgICAgICBvbkZvY3VzPXt0aGlzLmhhbmRsZUZvY3VzfVxuICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICAvPlxuICAgICAgICB7Y2hlY2tlZCAmJiAoXG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKHN0eWxlcy5DaGVjaywge1xuICAgICAgICAgICAgICBbc3R5bGVzLkNoZWNrU21dOiBzaXplID09PSAnc20nLFxuICAgICAgICAgICAgICBbc3R5bGVzLkNoZWNrTWRdOiBzaXplID09PSAnbWQnLFxuICAgICAgICAgICAgICBbc3R5bGVzLkNoZWNrRW5hYmxlZF06ICFkaXNhYmxlZCxcbiAgICAgICAgICAgICAgW3N0eWxlcy5DaGVja0Rpc2FibGVkXTogZGlzYWJsZWQsXG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgRmV0Y2hJdGVtcyBmcm9tICcuL0ZldGNoSXRlbXMuanMnO1xuaW1wb3J0IFNjcm9sbENvbnRhaW5lciBmcm9tICcuL1Njcm9sbENvbnRhaW5lci5qcyc7XG5pbXBvcnQge1xuICBnZXRFbGVtZW50SGVpZ2h0LFxuICBnZXRTY3JvbGxIZWlnaHQsXG4gIGdldFNjcm9sbFBvcyxcbn0gZnJvbSAnLi9zY3JvbGxVdGlscy5qcyc7XG5pbXBvcnQgdGhyb3R0bGUgZnJvbSAnLi90aHJvdHRsZS5qcyc7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50LFxuICBpc0F0RW5kPzogYm9vbGVhbixcbiAgaXNGZXRjaGluZzogYm9vbGVhbixcbiAgZmV0Y2hNb3JlPzogKCkgPT4gdm9pZCxcbiAgcmVuZGVySGVpZ2h0PzogKCkgPT4gbnVtYmVyLFxufTtcblxudHlwZSBTdGF0ZSA9IHtcbiAgY29udGFpbmVySGVpZ2h0OiBudW1iZXIsXG4gIHNjcm9sbEhlaWdodDogbnVtYmVyLFxuICBzY3JvbGxUb3A6IG51bWJlcixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjcm9sbEZldGNoIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgLyoqXG4gICAqIEZldGNoZXMgYWRkaXRpb25hbCBpdGVtcyBpZiBuZWVkZWQuXG4gICAqL1xuICB1cGRhdGVQb3NpdGlvbiA9IHRocm90dGxlKCgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHRoaXMuZ2V0U2Nyb2xsU3RhdGUoKSk7XG4gIH0pO1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHM6IHt9O1xuXG4gIHN0YXRlID0ge1xuICAgIGNvbnRhaW5lckhlaWdodDogMCxcbiAgICBzY3JvbGxIZWlnaHQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwLFxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIHNjcm9sbCBsaXN0ZW5lciBhZnRlciB0aGUgY29tcG9uZW50IG1vdW50cy5cbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGNvbnRhaW5lckhlaWdodDogZ2V0RWxlbWVudEhlaWdodChjb250YWluZXIpLFxuICAgICAgICAuLi50aGlzLmdldFNjcm9sbFN0YXRlKCksXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc2Nyb2xsIGJ1ZmZlciBhbmQgY2hlY2sgYWZ0ZXIgdGhlIGNvbXBvbmVudCB1cGRhdGVzLlxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIC8vIHNldFRpbWVvdXQgc28gdGhlIHBhcmVudCBjb21wb25lbnQgY2FuIGNhbGN1bGF0ZSByZW5kZXJIZWlnaHQoKS5cbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2Nyb2xsYWJsZSBjb250ZW50IGhlaWdodC5cbiAgICovXG4gIGdldFNjcm9sbEhlaWdodCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBnZXRTY3JvbGxIZWlnaHQoY29udGFpbmVyKTtcbiAgfTtcblxuICBnZXRTY3JvbGxTdGF0ZSgpIHtcbiAgICBjb25zdCB7IGNvbnRhaW5lciwgcmVuZGVySGVpZ2h0IH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gcmVuZGVySGVpZ2h0IHx8IHRoaXMuZ2V0U2Nyb2xsSGVpZ2h0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbEhlaWdodDogc2Nyb2xsSGVpZ2h0KCksXG4gICAgICBzY3JvbGxUb3A6IGdldFNjcm9sbFBvcyhjb250YWluZXIpLFxuICAgIH07XG4gIH1cblxuICBzY3JvbGxCdWZmZXI6IG51bWJlcjtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjb250YWluZXJIZWlnaHQsIHNjcm9sbEhlaWdodCwgc2Nyb2xsVG9wIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgY29udGFpbmVyLCBmZXRjaE1vcmUsIGlzQXRFbmQsIGlzRmV0Y2hpbmcgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgIGNvbnRhaW5lckhlaWdodCxcbiAgICAgIGZldGNoTW9yZSxcbiAgICAgIGlzQXRFbmQsXG4gICAgICBpc0ZldGNoaW5nLFxuICAgICAgc2Nyb2xsSGVpZ2h0LFxuICAgICAgc2Nyb2xsVG9wLFxuICAgIH07XG5cbiAgICBpZiAoIWNvbnRhaW5lciB8fCBpc0F0RW5kKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIDxTY3JvbGxDb250YWluZXJcbiAgICAgICAgb25TY3JvbGw9e3RoaXMudXBkYXRlUG9zaXRpb259XG4gICAgICAgIHNjcm9sbENvbnRhaW5lcj17Y29udGFpbmVyfVxuICAgICAgPlxuICAgICAgICA8RmV0Y2hJdGVtcyB7Li4ucHJvcHN9IC8+XG4gICAgICA8L1Njcm9sbENvbnRhaW5lcj5cbiAgICApO1xuICB9XG59XG5cblNjcm9sbEZldGNoLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIFRoZSBzY3JvbGwgY29udGFpbmVyIHRvIHVzZS4gRGVmYXVsdHMgdG8gd2luZG93LlxuICAgKi9cbiAgY29udGFpbmVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGFkZEV2ZW50TGlzdGVuZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IFByb3BUeXBlcy5mdW5jLFxuICB9KSxcbiAgcmVuZGVySGVpZ2h0OiBQcm9wVHlwZXMuZnVuYyxcbiAgaXNBdEVuZDogUHJvcFR5cGVzLmJvb2wsXG4gIGlzRmV0Y2hpbmc6IFByb3BUeXBlcy5ib29sLFxuICBmZXRjaE1vcmU6IFByb3BUeXBlcy5mdW5jLFxufTtcblxuU2Nyb2xsRmV0Y2guZGVmYXVsdFByb3BzID0ge1xuICBjb250YWluZXI6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogbnVsbCxcbn07XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1NlYXJjaEZpZWxkLmNzcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY2Nlc3NpYmlsaXR5TGFiZWw6IHN0cmluZyxcbiAgYXV0b0NvbXBsZXRlPzogJ29uJyB8ICdvZmYnIHwgJ3VzZXJuYW1lJyB8ICduYW1lJyxcbiAgaWQ6IHN0cmluZyxcbiAgb25CbHVyPzogKHsgZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+IH0pID0+IHZvaWQsXG4gIG9uQ2hhbmdlOiAoe1xuICAgIHZhbHVlOiBzdHJpbmcsXG4gICAgc3ludGhldGljRXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+LFxuICB9KSA9PiB2b2lkLFxuICBvbkZvY3VzPzogKHtcbiAgICB2YWx1ZTogc3RyaW5nLFxuICAgIHN5bnRoZXRpY0V2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PixcbiAgfSkgPT4gdm9pZCxcbiAgcGxhY2Vob2xkZXI/OiBzdHJpbmcsXG4gIHZhbHVlPzogc3RyaW5nLFxufH07XG5cbnR5cGUgU3RhdGUgPSB7fFxuICBmb2N1c2VkOiBib29sZWFuLFxuICBob3ZlcmVkOiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaEZpZWxkIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGFjY2Vzc2liaWxpdHlMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGF1dG9Db21wbGV0ZTogUHJvcFR5cGVzLm9uZU9mKFsnb24nLCAnb2ZmJywgJ3VzZXJuYW1lJywgJ25hbWUnXSksXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuICAgIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIGZvY3VzZWQ6IGZhbHNlLFxuICAgIGhvdmVyZWQ6IGZhbHNlLFxuICB9O1xuXG4gIGhhbmRsZUNoYW5nZSA9IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIG9uQ2hhbmdlKHtcbiAgICAgIHZhbHVlOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgc3ludGhldGljRXZlbnQ6IGV2ZW50LFxuICAgIH0pO1xuICB9O1xuXG4gIGhhbmRsZUNsZWFyID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25DaGFuZ2UgfSA9IHRoaXMucHJvcHM7XG4gICAgb25DaGFuZ2UoeyB2YWx1ZTogJycsIHN5bnRoZXRpY0V2ZW50OiBldmVudCB9KTtcbiAgfTtcblxuICBoYW5kbGVNb3VzZUVudGVyID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGhvdmVyZWQ6IHRydWUgfSk7XG5cbiAgaGFuZGxlTW91c2VMZWF2ZSA9ICgpID0+IHRoaXMuc2V0U3RhdGUoeyBob3ZlcmVkOiBmYWxzZSB9KTtcblxuICBoYW5kbGVGb2N1cyA9IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uRm9jdXMgfSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IHRydWUgfSk7XG5cbiAgICBpZiAob25Gb2N1cykge1xuICAgICAgb25Gb2N1cyh7XG4gICAgICAgIHZhbHVlOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgICBzeW50aGV0aWNFdmVudDogZXZlbnQsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlQmx1ciA9IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uQmx1ciB9ID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLnNldFN0YXRlKHsgZm9jdXNlZDogZmFsc2UgfSk7XG5cbiAgICBpZiAob25CbHVyKSB7XG4gICAgICBvbkJsdXIoeyBldmVudCB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFjY2Vzc2liaWxpdHlMYWJlbCxcbiAgICAgIGF1dG9Db21wbGV0ZSxcbiAgICAgIGlkLFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICB2YWx1ZSxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHsgZm9jdXNlZCwgaG92ZXJlZCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIC8vIFRoaXMgbWlycm9ycyB0aGUgYnVpbHQgaW4gYnJvd3NlciBiZWhhdmlvci4gSWYgdGhlcmUncyBhIHZhbHVlLCBzaG93IHRoZVxuICAgIC8vIGNsZWFyIGJ1dHRvbiBpZiB5b3UncmUgaG92ZXJpbmcgb3IgaWYgeW91J3ZlIGZvY3VzZWQgb24gdGhlIGZpZWxkXG4gICAgY29uc3Qgc2hvd0NsZWFyID0gKGZvY3VzZWQgfHwgaG92ZXJlZCkgJiYgdmFsdWUgJiYgdmFsdWUubGVuZ3RoID4gMDtcblxuICAgIHJldHVybiAoXG4gICAgICA8Qm94XG4gICAgICAgIGRpc3BsYXk9XCJmbGV4XCJcbiAgICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgICAgIGFsaWduSXRlbXM9XCJjZW50ZXJcIlxuICAgICAgICBvbk1vdXNlRW50ZXI9e3RoaXMuaGFuZGxlTW91c2VFbnRlcn1cbiAgICAgICAgb25Nb3VzZUxlYXZlPXt0aGlzLmhhbmRsZU1vdXNlTGVhdmV9XG4gICAgICAgIG9uRm9jdXM9e3RoaXMuaGFuZGxlRm9jdXN9XG4gICAgICAgIG9uQmx1cj17dGhpcy5oYW5kbGVCbHVyfVxuICAgICAgICBjb2xvcj1cIndoaXRlXCJcbiAgICAgID5cbiAgICAgICAgPEJveFxuICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3tcbiAgICAgICAgICAgIF9fc3R5bGU6IHtcbiAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICAgICAgICAvLyBBZGRlZCB0aGUgZm9sbG93aW5nIGxpbmVzIGZvciBTYWZhcmkgc3VwcG9ydFxuICAgICAgICAgICAgICB0b3A6ICc1MCUnLFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC01MCUpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfX1cbiAgICAgICAgICBwb3NpdGlvbj1cImFic29sdXRlXCJcbiAgICAgICAgICBsZWZ0XG4gICAgICAgICAgcGFkZGluZ1g9ezR9XG4gICAgICAgID5cbiAgICAgICAgICA8SWNvbiBpY29uPVwic2VhcmNoXCIgYWNjZXNzaWJpbGl0eUxhYmVsPVwiXCIgLz5cbiAgICAgICAgPC9Cb3g+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIGFyaWEtbGFiZWw9e2FjY2Vzc2liaWxpdHlMYWJlbH1cbiAgICAgICAgICBhdXRvQ29tcGxldGU9e2F1dG9Db21wbGV0ZX1cbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5pbnB1dH1cbiAgICAgICAgICBpZD17aWR9XG4gICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlfVxuICAgICAgICAgIHBsYWNlaG9sZGVyPXtwbGFjZWhvbGRlcn1cbiAgICAgICAgICByb2xlPVwic2VhcmNoYm94XCJcbiAgICAgICAgICB0eXBlPVwic2VhcmNoXCJcbiAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgIC8+XG4gICAgICAgIHtzaG93Q2xlYXIgJiYgKFxuICAgICAgICAgIDxCb3ggcG9zaXRpb249XCJhYnNvbHV0ZVwiIHJpZ2h0IHRvcD5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuY2xlYXJ9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xlYXJ9XG4gICAgICAgICAgICAgIHRhYkluZGV4PXstMX1cbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxJY29uIGljb249XCJjbGVhclwiIGFjY2Vzc2liaWxpdHlMYWJlbD1cIlwiIC8+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8L0JveD5cbiAgICAgICAgKX1cbiAgICAgIDwvQm94PlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBUZXh0IGZyb20gJy4vVGV4dC5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vU2VnbWVudGVkQ29udHJvbC5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgaXRlbXM6IEFycmF5PFJlYWN0Lk5vZGU+LFxuICBvbkNoYW5nZTogKHsgZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8PiwgYWN0aXZlSW5kZXg6IG51bWJlciB9KSA9PiB2b2lkLFxuICByZXNwb25zaXZlPzogYm9vbGVhbixcbiAgc2VsZWN0ZWRJdGVtSW5kZXg6IG51bWJlcixcbiAgc2l6ZT86ICdtZCcgfCAnbGcnLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNlZ21lbnRlZENvbnRyb2wocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHsgaXRlbXMsIG9uQ2hhbmdlLCByZXNwb25zaXZlLCBzZWxlY3RlZEl0ZW1JbmRleCwgc2l6ZSA9ICdtZCcgfSA9IHByb3BzO1xuICBjb25zdCBidXR0b25XaWR0aCA9IHJlc3BvbnNpdmVcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogYCR7TWF0aC5mbG9vcigxMDAgLyBNYXRoLm1heCgxLCBpdGVtcy5sZW5ndGgpKX0lYDtcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoc3R5bGVzLlNlZ21lbnRlZENvbnRyb2wsIHtcbiAgICAgICAgW3N0eWxlcy5tZF06IHNpemUgPT09ICdtZCcsXG4gICAgICAgIFtzdHlsZXMubGddOiBzaXplID09PSAnbGcnLFxuICAgICAgfSl9XG4gICAgICByb2xlPVwidGFibGlzdFwiXG4gICAgPlxuICAgICAge2l0ZW1zLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICBjb25zdCBpc1NlbGVjdGVkID0gaSA9PT0gc2VsZWN0ZWRJdGVtSW5kZXg7XG4gICAgICAgIGNvbnN0IGNzID0gY2xhc3NuYW1lcyhzdHlsZXMuaXRlbSwge1xuICAgICAgICAgIFtzdHlsZXMuaXRlbUlzTm90U2VsZWN0ZWRdOiAhaXNTZWxlY3RlZCxcbiAgICAgICAgICBbc3R5bGVzLml0ZW1Jc1NlbGVjdGVkXTogaXNTZWxlY3RlZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgYXJpYS1zZWxlY3RlZD17aXNTZWxlY3RlZH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y3N9XG4gICAgICAgICAgICBrZXk9e2l9XG4gICAgICAgICAgICBvbkNsaWNrPXtlID0+IG9uQ2hhbmdlKHsgZXZlbnQ6IGUsIGFjdGl2ZUluZGV4OiBpIH0pfVxuICAgICAgICAgICAgcm9sZT1cInRhYlwiXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIHN0eWxlPXt7IHdpZHRoOiBidXR0b25XaWR0aCB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHt0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgPyAoXG4gICAgICAgICAgICAgIDxUZXh0XG4gICAgICAgICAgICAgICAgYm9sZFxuICAgICAgICAgICAgICAgIGNvbG9yPXtpc1NlbGVjdGVkID8gJ2RhcmtHcmF5JyA6ICdncmF5J31cbiAgICAgICAgICAgICAgICBhbGlnbj1cImNlbnRlclwiXG4gICAgICAgICAgICAgICAgc2l6ZT17c2l6ZX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHtpdGVtfVxuICAgICAgICAgICAgICA8L1RleHQ+XG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICA8Qm94IGRpc3BsYXk9XCJmbGV4XCIganVzdGlmeUNvbnRlbnQ9XCJjZW50ZXJcIj5cbiAgICAgICAgICAgICAgICB7aXRlbX1cbiAgICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApO1xuICAgICAgfSl9XG4gICAgPC9kaXY+XG4gICk7XG59XG5cblNlZ21lbnRlZENvbnRyb2wucHJvcFR5cGVzID0ge1xuICBpdGVtczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm5vZGUpLmlzUmVxdWlyZWQsXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICByZXNwb25zaXZlOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2VsZWN0ZWRJdGVtSW5kZXg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnbWQnLCAnbGcnXSksXG59O1xuIiwiLy8gQGZsb3dcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBUZXh0IGZyb20gJy4vVGV4dC5qcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBpZDogc3RyaW5nLFxuICB0ZXh0Pzogc3RyaW5nLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZvcm1FcnJvck1lc3NhZ2UoeyBpZCwgdGV4dCA9ICcnIH06IFByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPFRleHQgY29sb3I9XCJvcmFuZ2VcIj5cbiAgICAgIDxzcGFuIGlkPXtgJHtpZH0tZXJyb3JgfT57dGV4dH08L3NwYW4+XG4gICAgPC9UZXh0PlxuICApO1xufVxuXG5Gb3JtRXJyb3JNZXNzYWdlLnByb3BUeXBlcyA9IHtcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgdGV4dDogUHJvcFR5cGVzLnN0cmluZyxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IEZvcm1FcnJvck1lc3NhZ2UgZnJvbSAnLi9Gb3JtRXJyb3JNZXNzYWdlLmpzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi9JY29uLmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9TZWxlY3RMaXN0LmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBlcnJvck1lc3NhZ2U/OiBzdHJpbmcsXG4gIGRpc2FibGVkPzogYm9vbGVhbixcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZT86IHN0cmluZyxcbiAgb25DaGFuZ2U6ICh7IGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PD4sIHZhbHVlOiBzdHJpbmcgfSkgPT4gdm9pZCxcbiAgb3B0aW9uczogQXJyYXk8e1xuICAgIGxhYmVsOiBzdHJpbmcsXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgfT4sXG4gIHBsYWNlaG9sZGVyPzogc3RyaW5nLFxuICB2YWx1ZT86ID9zdHJpbmcsXG58fTtcblxudHlwZSBTdGF0ZSA9IHt8XG4gIGZvY3VzZWQ6IGJvb2xlYW4sXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VsZWN0TGlzdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgZXJyb3JNZXNzYWdlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvcHRpb25zOiBQcm9wVHlwZXMuYXJyYXlPZihcbiAgICAgIFByb3BUeXBlcy5leGFjdCh7XG4gICAgICAgIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgICAgIHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgICB9KVxuICAgICksXG4gICAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgb3B0aW9uczogW10sXG4gIH07XG5cbiAgc3RhdGUgPSB7XG4gICAgZm9jdXNlZDogZmFsc2UsXG4gIH07XG5cbiAgc2V0U2VsZWN0TGlzdFJlZiA9IChyZWY6ID9IVE1MU2VsZWN0RWxlbWVudCkgPT4ge1xuICAgIHRoaXMuc2VsZWN0ID0gcmVmO1xuICB9O1xuXG4gIGhhbmRsZU9uQ2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PD4pID0+IHtcbiAgICBjb25zdCB7IG9uQ2hhbmdlLCB2YWx1ZSB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoXG4gICAgICBldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCAmJlxuICAgICAgdmFsdWUgIT09IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICkge1xuICAgICAgb25DaGFuZ2UoeyBldmVudCwgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgc2VsZWN0OiA/SFRNTFNlbGVjdEVsZW1lbnQ7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpc2FibGVkLFxuICAgICAgZXJyb3JNZXNzYWdlLFxuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgdmFsdWUsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCB7IGZvY3VzZWQgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCBjbGFzc2VzID0gY2xhc3NuYW1lcyhcbiAgICAgIHN0eWxlcy5zZWxlY3QsXG4gICAgICBkaXNhYmxlZCA/IHN0eWxlcy5kaXNhYmxlZCA6IHN0eWxlcy5lbmFibGVkLFxuICAgICAgZXJyb3JNZXNzYWdlID8gc3R5bGVzLmVycm9yZWQgOiBzdHlsZXMubm9ybWFsXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8Qm94PlxuICAgICAgICA8Qm94XG4gICAgICAgICAgY29sb3I9e2Rpc2FibGVkID8gJ2xpZ2h0R3JheScgOiAnd2hpdGUnfVxuICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyBib3JkZXJSYWRpdXM6IDQgfSB9fVxuICAgICAgICAgIGRpc3BsYXk9XCJmbGV4XCJcbiAgICAgICAgICBwb3NpdGlvbj1cInJlbGF0aXZlXCJcbiAgICAgICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgICA+XG4gICAgICAgICAgPEJveFxuICAgICAgICAgICAgYWxpZ25JdGVtcz1cImNlbnRlclwiXG4gICAgICAgICAgICBib3R0b21cbiAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3tcbiAgICAgICAgICAgICAgX19zdHlsZTogeyBwYWRkaW5nUmlnaHQ6IDE0LCBwYWRkaW5nVG9wOiAyIH0sXG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICAgICAgcG9zaXRpb249XCJhYnNvbHV0ZVwiXG4gICAgICAgICAgICByaWdodFxuICAgICAgICAgICAgdG9wXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPEljb25cbiAgICAgICAgICAgICAgaWNvbj1cImFycm93LWRvd25cIlxuICAgICAgICAgICAgICBzaXplPXsxMn1cbiAgICAgICAgICAgICAgY29sb3I9e2Rpc2FibGVkID8gJ2dyYXknIDogJ2RhcmtHcmF5J31cbiAgICAgICAgICAgICAgYWNjZXNzaWJpbGl0eUxhYmVsPVwiXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgPHNlbGVjdFxuICAgICAgICAgICAgYXJpYS1kZXNjcmliZWRieT17ZXJyb3JNZXNzYWdlICYmIGZvY3VzZWQgPyBgJHtpZH0tZXJyb3JgIDogbnVsbH1cbiAgICAgICAgICAgIGFyaWEtaW52YWxpZD17ZXJyb3JNZXNzYWdlID8gJ3RydWUnIDogJ2ZhbHNlJ31cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlc31cbiAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICAgIGlkPXtpZH1cbiAgICAgICAgICAgIG5hbWU9e25hbWV9XG4gICAgICAgICAgICBvbkJsdXI9e3RoaXMuaGFuZGxlT25DaGFuZ2V9XG4gICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVPbkNoYW5nZX1cbiAgICAgICAgICAgIHJlZj17dGhpcy5zZXRTZWxlY3RMaXN0UmVmfVxuICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtwbGFjZWhvbGRlciAmJlxuICAgICAgICAgICAgICAhdmFsdWUgJiYgKFxuICAgICAgICAgICAgICAgIDxvcHRpb24gc2VsZWN0ZWQgZGlzYWJsZWQgdmFsdWUgaGlkZGVuPlxuICAgICAgICAgICAgICAgICAge3BsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgIDwvb3B0aW9uPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAge29wdGlvbnMubWFwKG9wdGlvbiA9PiAoXG4gICAgICAgICAgICAgIDxvcHRpb24ga2V5PXtvcHRpb24udmFsdWV9IHZhbHVlPXtvcHRpb24udmFsdWV9PlxuICAgICAgICAgICAgICAgIHtvcHRpb24ubGFiZWx9XG4gICAgICAgICAgICAgIDwvb3B0aW9uPlxuICAgICAgICAgICAgKSl9XG4gICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDwvQm94PlxuXG4gICAgICAgIHtlcnJvck1lc3NhZ2UgJiYgKFxuICAgICAgICAgIDxCb3ggbWFyZ2luVG9wPXsxfT5cbiAgICAgICAgICAgIDxGb3JtRXJyb3JNZXNzYWdlIGlkPXtpZH0gdGV4dD17ZXJyb3JNZXNzYWdlfSAvPlxuICAgICAgICAgIDwvQm94PlxuICAgICAgICApfVxuICAgICAgPC9Cb3g+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vU3Bpbm5lci5jc3MnO1xuXG5jb25zdCBTSVpFID0gNDA7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY2Nlc3NpYmlsaXR5TGFiZWw6IHN0cmluZyxcbiAgc2hvdzogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTcGlubmVyKHsgYWNjZXNzaWJpbGl0eUxhYmVsLCBzaG93IH06IFByb3BzKSB7XG4gIHJldHVybiBzaG93ID8gKFxuICAgIDxCb3ggZGlzcGxheT1cImZsZXhcIiBqdXN0aWZ5Q29udGVudD1cImFyb3VuZFwiIG92ZXJmbG93PVwiaGlkZGVuXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmljb259PlxuICAgICAgICA8SWNvblxuICAgICAgICAgIGljb249XCJrbm9vcFwiXG4gICAgICAgICAgYWNjZXNzaWJpbGl0eUxhYmVsPXthY2Nlc3NpYmlsaXR5TGFiZWx9XG4gICAgICAgICAgc2l6ZT17U0laRX1cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvQm94PlxuICApIDogKFxuICAgIDxkaXYgLz5cbiAgKTtcbn1cblxuU3Bpbm5lci5wcm9wVHlwZXMgPSB7XG4gIHNob3c6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG4gIGFjY2Vzc2liaWxpdHlMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxufTtcbiIsIi8vIEBmbG93XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgbGF5b3V0IGZyb20gJy4vTGF5b3V0LmNzcyc7XG5cbnR5cGUgVGhyZXNob2xkID1cbiAgfCB7fCB0b3A6IG51bWJlciB8IHN0cmluZyB8fVxuICB8IHt8IGJvdHRvbTogbnVtYmVyIHwgc3RyaW5nIHx9XG4gIHwge3wgbGVmdDogbnVtYmVyIHwgc3RyaW5nIHx9XG4gIHwge3wgcmlnaHQ6IG51bWJlciB8IHN0cmluZyB8fVxuICB8IHt8IHRvcDogbnVtYmVyIHwgc3RyaW5nLCBib3R0b206IG51bWJlciB8IHN0cmluZyB8fVxuICB8IHt8IGxlZnQ6IG51bWJlciB8IHN0cmluZywgcmlnaHQ6IG51bWJlciB8IHN0cmluZyB8fVxuICB8IHt8XG4gICAgICB0b3A6IG51bWJlciB8IHN0cmluZyxcbiAgICAgIGxlZnQ6IG51bWJlciB8IHN0cmluZyxcbiAgICAgIHJpZ2h0OiBudW1iZXIgfCBzdHJpbmcsXG4gICAgICBib3R0b206IG51bWJlciB8IHN0cmluZyxcbiAgICB8fTtcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoaWxkcmVuOiBSZWFjdC5Ob2RlLFxuICBkYW5nZXJvdXNseVNldFpJbmRleD86IHsgX196SW5kZXg6IG51bWJlciB9LFxuICAuLi5UaHJlc2hvbGQsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3RpY2t5KHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7IGRhbmdlcm91c2x5U2V0WkluZGV4ID0geyBfX3pJbmRleDogMSB9LCBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gIGNvbnN0IHN0eWxlID0ge1xuICAgIHRvcDogcHJvcHMudG9wICE9IG51bGwgPyBwcm9wcy50b3AgOiB1bmRlZmluZWQsXG4gICAgbGVmdDogcHJvcHMubGVmdCAhPSBudWxsID8gcHJvcHMubGVmdCA6IHVuZGVmaW5lZCxcbiAgICByaWdodDogcHJvcHMucmlnaHQgIT0gbnVsbCA/IHByb3BzLnJpZ2h0IDogdW5kZWZpbmVkLFxuICAgIGJvdHRvbTogcHJvcHMuYm90dG9tICE9IG51bGwgPyBwcm9wcy5ib3R0b20gOiB1bmRlZmluZWQsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXG4gICAgekluZGV4OiBkYW5nZXJvdXNseVNldFpJbmRleC5fX3pJbmRleCxcbiAgfTtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17bGF5b3V0LnN0aWNreX0gc3R5bGU9e3N0eWxlfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuU3RpY2t5LnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBkYW5nZXJvdXNseVNldFpJbmRleDogUHJvcFR5cGVzLmV4YWN0KHtcbiAgICBfX3pJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgfSksXG4gIHRvcDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBsZWZ0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIGJvdHRvbTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICByaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vU3dpdGNoLmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBkaXNhYmxlZD86IGJvb2xlYW4sXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU/OiBzdHJpbmcsXG4gIG9uQ2hhbmdlOiAoeyBldmVudDogU3ludGhldGljSW5wdXRFdmVudDw+LCB2YWx1ZTogYm9vbGVhbiB9KSA9PiB2b2lkLFxuICBzd2l0Y2hlZD86IGJvb2xlYW4sXG58fTtcblxudHlwZSBTdGF0ZSA9IHt8XG4gIGZvY3VzZWQ6IGJvb2xlYW4sXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3dpdGNoIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgc3dpdGNoZWQ6IFByb3BUeXBlcy5ib29sLFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIHN3aXRjaGVkOiBmYWxzZSxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBmb2N1c2VkOiBmYWxzZSxcbiAgfTtcblxuICBoYW5kbGVCbHVyID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IGZhbHNlIH0pO1xuXG4gIGhhbmRsZUZvY3VzID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IHRydWUgfSk7XG5cbiAgaGFuZGxlQ2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PD4pID0+IHtcbiAgICBjb25zdCB7IG9uQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgY2hlY2tlZCB9ID0gZXZlbnQudGFyZ2V0O1xuICAgIG9uQ2hhbmdlKHsgZXZlbnQsIHZhbHVlOiBjaGVja2VkIH0pO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGRpc2FibGVkLCBpZCwgbmFtZSwgc3dpdGNoZWQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBzd2l0Y2hTdHlsZXMgPSBjbGFzc25hbWVzKFxuICAgICAgc3R5bGVzLnN3aXRjaCxcbiAgICAgIHtcbiAgICAgICAgW3N0eWxlcy5mb2N1c2VkXTogdGhpcy5zdGF0ZS5mb2N1c2VkLFxuICAgICAgfSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgZGlzYWJsZWRcbiAgICAgICAgPyBzd2l0Y2hlZFxuICAgICAgICAgID8gc3R5bGVzLnN3aXRjaEdyYXlcbiAgICAgICAgICA6IHN0eWxlcy5zd2l0Y2hMaWdodEdyYXlcbiAgICAgICAgOiBzd2l0Y2hlZFxuICAgICAgICAgID8gc3R5bGVzLnN3aXRjaERhcmtHcmF5XG4gICAgICAgICAgOiBzdHlsZXMuc3dpdGNoV2hpdGVcbiAgICApO1xuXG4gICAgY29uc3Qgc2xpZGVyU3R5bGVzID0gY2xhc3NuYW1lcyhcbiAgICAgIHN0eWxlcy5zbGlkZXIsXG4gICAgICBzd2l0Y2hlZCA/IHN0eWxlcy5zbGlkZXJSaWdodCA6IHN0eWxlcy5zbGlkZXJMZWZ0LFxuICAgICAgc3dpdGNoZWQgJiYgIWRpc2FibGVkID8gc3R5bGVzLnNsaWRlckRhcmsgOiBzdHlsZXMuc2xpZGVyTGlnaHRcbiAgICApO1xuXG4gICAgY29uc3QgaW5wdXRTdHlsZXMgPSBjbGFzc25hbWVzKHN0eWxlcy5jaGVja2JveCwge1xuICAgICAgW3N0eWxlcy5jaGVja2JveEVuYWJsZWRdOiAhZGlzYWJsZWQsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N3aXRjaFN0eWxlc30+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIGNoZWNrZWQ9e3N3aXRjaGVkfVxuICAgICAgICAgIGNsYXNzTmFtZT17aW5wdXRTdHlsZXN9XG4gICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgIGlkPXtpZH1cbiAgICAgICAgICBuYW1lPXtuYW1lfVxuICAgICAgICAgIG9uQmx1cj17dGhpcy5oYW5kbGVCbHVyfVxuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZUNoYW5nZX1cbiAgICAgICAgICBvbkZvY3VzPXt0aGlzLmhhbmRsZUZvY3VzfVxuICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzbGlkZXJTdHlsZXN9IC8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFRleHQgZnJvbSAnLi9UZXh0LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9UYWJzLmNzcyc7XG5pbXBvcnQgbGF5b3V0IGZyb20gJy4vTGF5b3V0LmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY3RpdmVUYWJJbmRleDogbnVtYmVyLFxuICB0YWJzOiBBcnJheTx7fFxuICAgIHRleHQ6IFJlYWN0Lk5vZGUsXG4gICAgaHJlZjogc3RyaW5nLFxuICB8fT4sXG4gIG9uQ2hhbmdlOiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PD4sXG4gICAgYWN0aXZlVGFiSW5kZXg6IG51bWJlcixcbiAgfSkgPT4gdm9pZCxcbiAgd3JhcD86IGJvb2xlYW4sXG58fTtcblxudHlwZSBTdGF0ZSA9IHt8XG4gIGZvY3VzZWRUYWJJbmRleDogP251bWJlcixcbiAgaG92ZXJlZFRhYkluZGV4OiA/bnVtYmVyLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhYnMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYWN0aXZlVGFiSW5kZXg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICB0YWJzOiBQcm9wVHlwZXMuYXJyYXlPZihcbiAgICAgIFByb3BUeXBlcy5leGFjdCh7XG4gICAgICAgIHRleHQ6IFByb3BUeXBlcy5ub2RlLFxuICAgICAgICBocmVmOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgfSlcbiAgICApLmlzUmVxdWlyZWQsXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgd3JhcDogUHJvcFR5cGVzLmJvb2wsXG4gIH07XG5cbiAgc3RhdGU6IFN0YXRlID0ge1xuICAgIGZvY3VzZWRUYWJJbmRleDogdW5kZWZpbmVkLFxuICAgIGhvdmVyZWRUYWJJbmRleDogdW5kZWZpbmVkLFxuICB9O1xuXG4gIGhhbmRsZVRhYkNsaWNrID0gKGk6IG51bWJlciwgZTogU3ludGhldGljTW91c2VFdmVudDw+KSA9PiB7XG4gICAgY29uc3QgeyBvbkNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICBvbkNoYW5nZSh7IGFjdGl2ZVRhYkluZGV4OiBpLCBldmVudDogZSB9KTtcbiAgfTtcblxuICBoYW5kbGVUYWJGb2N1cyA9IChpOiBudW1iZXIpID0+IHRoaXMuc2V0U3RhdGUoeyBmb2N1c2VkVGFiSW5kZXg6IGkgfSk7XG5cbiAgaGFuZGxlVGFiQmx1ciA9ICgpID0+IHRoaXMuc2V0U3RhdGUoeyBmb2N1c2VkVGFiSW5kZXg6IHVuZGVmaW5lZCB9KTtcblxuICBoYW5kbGVUYWJNb3VzZUVudGVyID0gKGk6IG51bWJlcikgPT4gdGhpcy5zZXRTdGF0ZSh7IGhvdmVyZWRUYWJJbmRleDogaSB9KTtcblxuICBoYW5kbGVUYWJNb3VzZUxlYXZlID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGhvdmVyZWRUYWJJbmRleDogdW5kZWZpbmVkIH0pO1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IHRhYnMsIGFjdGl2ZVRhYkluZGV4LCB3cmFwIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgZm9jdXNlZFRhYkluZGV4LCBob3ZlcmVkVGFiSW5kZXggfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKHN0eWxlcy5UYWJzLCB3cmFwICYmIGxheW91dC5mbGV4V3JhcCl9XG4gICAgICAgIHJvbGU9XCJ0YWJsaXN0XCJcbiAgICAgID5cbiAgICAgICAge3RhYnMubWFwKCh7IHRleHQsIGhyZWYgfSwgaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlzQWN0aXZlID0gaSA9PT0gYWN0aXZlVGFiSW5kZXg7XG4gICAgICAgICAgY29uc3QgaXNIb3ZlcmVkID0gaSA9PT0gaG92ZXJlZFRhYkluZGV4O1xuICAgICAgICAgIGNvbnN0IGlzRm9jdXNlZCA9IGkgPT09IGZvY3VzZWRUYWJJbmRleDtcbiAgICAgICAgICBjb25zdCBjcyA9IGNsYXNzbmFtZXMoc3R5bGVzLnRhYiwge1xuICAgICAgICAgICAgW3N0eWxlcy50YWJJc05vdEFjdGl2ZV06ICFpc0FjdGl2ZSxcbiAgICAgICAgICAgIFtzdHlsZXMudGFiSXNBY3RpdmVdOiBpc0FjdGl2ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgYXJpYS1zZWxlY3RlZD17aXNBY3RpdmV9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3N9XG4gICAgICAgICAgICAgIGhyZWY9e2hyZWZ9XG4gICAgICAgICAgICAgIGtleT17YCR7aX0ke2hyZWZ9YH1cbiAgICAgICAgICAgICAgb25DbGljaz17KGU6IFN5bnRoZXRpY01vdXNlRXZlbnQ8PikgPT4gdGhpcy5oYW5kbGVUYWJDbGljayhpLCBlKX1cbiAgICAgICAgICAgICAgb25Gb2N1cz17KCkgPT4gdGhpcy5oYW5kbGVUYWJGb2N1cyhpKX1cbiAgICAgICAgICAgICAgb25CbHVyPXt0aGlzLmhhbmRsZVRhYkJsdXJ9XG4gICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17KCkgPT4gdGhpcy5oYW5kbGVUYWJNb3VzZUVudGVyKGkpfVxuICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9e3RoaXMuaGFuZGxlVGFiTW91c2VMZWF2ZX1cbiAgICAgICAgICAgICAgcm9sZT1cInRhYlwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxUZXh0XG4gICAgICAgICAgICAgICAgYm9sZFxuICAgICAgICAgICAgICAgIGNvbG9yPXtpc0FjdGl2ZSB8fCBpc0hvdmVyZWQgfHwgaXNGb2N1c2VkID8gJ2RhcmtHcmF5JyA6ICdncmF5J31cbiAgICAgICAgICAgICAgICBzaXplPVwibWRcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge3RleHR9XG4gICAgICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICApO1xuICAgICAgICB9KX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IEZvcm1FcnJvck1lc3NhZ2UgZnJvbSAnLi9Gb3JtRXJyb3JNZXNzYWdlLmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9UZXh0QXJlYS5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgZXJyb3JNZXNzYWdlPzogc3RyaW5nLFxuICBkaXNhYmxlZD86IGJvb2xlYW4sXG4gIGhhc0Vycm9yPzogYm9vbGVhbixcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZT86IHN0cmluZyxcbiAgb25CbHVyPzogKHtcbiAgICBldmVudDogU3ludGhldGljRm9jdXNFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PixcbiAgICB2YWx1ZTogc3RyaW5nLFxuICB9KSA9PiB2b2lkLFxuICBvbkNoYW5nZTogKHtcbiAgICBldmVudDogU3ludGhldGljSW5wdXRFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PixcbiAgICB2YWx1ZTogc3RyaW5nLFxuICB9KSA9PiB2b2lkLFxuICBvbkZvY3VzPzogKHtcbiAgICBldmVudDogU3ludGhldGljRm9jdXNFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PixcbiAgICB2YWx1ZTogc3RyaW5nLFxuICB9KSA9PiB2b2lkLFxuICBvbktleURvd24/OiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNLZXlib2FyZEV2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+LFxuICAgIHZhbHVlOiBzdHJpbmcsXG4gIH0pID0+IHZvaWQsXG4gIHBsYWNlaG9sZGVyPzogc3RyaW5nLFxuICByb3dzPzogbnVtYmVyIC8qIGRlZmF1bHQ6IDMgKi8sXG4gIHZhbHVlPzogc3RyaW5nLFxufH07XG5cbnR5cGUgU3RhdGUgPSB7fFxuICBmb2N1c2VkOiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHRBcmVhIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBlcnJvck1lc3NhZ2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgaGFzRXJyb3I6IFByb3BUeXBlcy5ib29sLFxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uS2V5RG93bjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgcm93czogUHJvcFR5cGVzLm51bWJlcixcbiAgICB2YWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBoYXNFcnJvcjogZmFsc2UsXG4gICAgcm93czogMyxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBmb2N1c2VkOiBmYWxzZSxcbiAgfTtcblxuICBzZXRUZXh0QXJlYVJlZiA9IChyZWY6ID9IVE1MVGV4dEFyZWFFbGVtZW50KSA9PiB7XG4gICAgdGhpcy50ZXh0YXJlYSA9IHJlZjtcbiAgfTtcblxuICBoYW5kbGVDaGFuZ2UgPSAoZXZlbnQ6IFN5bnRoZXRpY0lucHV0RXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIG9uQ2hhbmdlKHsgZXZlbnQsIHZhbHVlOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlIH0pO1xuICB9O1xuXG4gIGhhbmRsZUJsdXIgPSAoZXZlbnQ6IFN5bnRoZXRpY0ZvY3VzRXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uQmx1ciB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAob25CbHVyKSB7XG4gICAgICBvbkJsdXIoeyBldmVudCwgdmFsdWU6IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUgfSk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZUZvY3VzID0gKGV2ZW50OiBTeW50aGV0aWNGb2N1c0V2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBvbkZvY3VzIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChvbkZvY3VzKSB7XG4gICAgICBvbkZvY3VzKHsgZXZlbnQsIHZhbHVlOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlIH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVLZXlEb3duID0gKGV2ZW50OiBTeW50aGV0aWNLZXlib2FyZEV2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBvbktleURvd24gfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKG9uS2V5RG93bikge1xuICAgICAgb25LZXlEb3duKHsgZXZlbnQsIHZhbHVlOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBOT1RFOiB3ZSBjYW5ub3QgbW92ZSB0byBSZWFjdCBjcmVhdGVSZWYgdW50aWwgd2UgYXVkaXQgdXNlcyBvZiBjYWxsc2l0ZXNcbiAgLy8gdGhhdCByZWFjaCBpbnRvIHRoaXMgY29tcG9uZW50IGFuZCB1c2UgdGhpcyBpbnN0YW5jZSB2YXJpYWJsZVxuICB0ZXh0YXJlYTogP0hUTUxFbGVtZW50O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXNhYmxlZCxcbiAgICAgIGVycm9yTWVzc2FnZSxcbiAgICAgIGhhc0Vycm9yLFxuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICByb3dzLFxuICAgICAgdmFsdWUsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCB7IGZvY3VzZWQgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCBjbGFzc2VzID0gY2xhc3NuYW1lcyhcbiAgICAgIHN0eWxlcy50ZXh0QXJlYSxcbiAgICAgIGRpc2FibGVkID8gc3R5bGVzLmRpc2FibGVkIDogc3R5bGVzLmVuYWJsZWQsXG4gICAgICBoYXNFcnJvciB8fCBlcnJvck1lc3NhZ2UgPyBzdHlsZXMuZXJyb3JlZCA6IHN0eWxlcy5ub3JtYWxcbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxzcGFuPlxuICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICBhcmlhLWRlc2NyaWJlZGJ5PXtlcnJvck1lc3NhZ2UgJiYgZm9jdXNlZCA/IGAke2lkfS1lcnJvcmAgOiBudWxsfVxuICAgICAgICAgIGFyaWEtaW52YWxpZD17ZXJyb3JNZXNzYWdlIHx8IGhhc0Vycm9yID8gJ3RydWUnIDogJ2ZhbHNlJ31cbiAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzZXN9XG4gICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgIGlkPXtpZH1cbiAgICAgICAgICBuYW1lPXtuYW1lfVxuICAgICAgICAgIG9uQmx1cj17dGhpcy5oYW5kbGVCbHVyfVxuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZUNoYW5nZX1cbiAgICAgICAgICBvbkZvY3VzPXt0aGlzLmhhbmRsZUZvY3VzfVxuICAgICAgICAgIG9uS2V5RG93bj17dGhpcy5oYW5kbGVLZXlEb3dufVxuICAgICAgICAgIHBsYWNlaG9sZGVyPXtwbGFjZWhvbGRlcn1cbiAgICAgICAgICByZWY9e3RoaXMuc2V0VGV4dEFyZWFSZWZ9XG4gICAgICAgICAgcm93cz17cm93c31cbiAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgIC8+XG4gICAgICAgIHtlcnJvck1lc3NhZ2UgJiYgKFxuICAgICAgICAgIDxCb3ggbWFyZ2luVG9wPXsxfT5cbiAgICAgICAgICAgIDxGb3JtRXJyb3JNZXNzYWdlIGlkPXtpZH0gdGV4dD17ZXJyb3JNZXNzYWdlfSAvPlxuICAgICAgICAgIDwvQm94PlxuICAgICAgICApfVxuICAgICAgPC9zcGFuPlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IEZvcm1FcnJvck1lc3NhZ2UgZnJvbSAnLi9Gb3JtRXJyb3JNZXNzYWdlLmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9UZXh0RmllbGQuY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGF1dG9Db21wbGV0ZT86XG4gICAgfCAnY3VycmVudC1wYXNzd29yZCdcbiAgICB8ICduZXctcGFzc3dvcmQnXG4gICAgfCAnb24nXG4gICAgfCAnb2ZmJ1xuICAgIHwgJ3VzZXJuYW1lJyxcbiAgZGlzYWJsZWQ/OiBib29sZWFuLFxuICBlcnJvck1lc3NhZ2U/OiBzdHJpbmcsXG4gIGhhc0Vycm9yPzogYm9vbGVhbixcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZT86IHN0cmluZyxcbiAgb25CbHVyPzogKHtcbiAgICBldmVudDogU3ludGhldGljRm9jdXNFdmVudDxIVE1MSW5wdXRFbGVtZW50PixcbiAgICB2YWx1ZTogc3RyaW5nLFxuICB9KSA9PiB2b2lkLFxuICBvbkNoYW5nZTogKHtcbiAgICBldmVudDogU3ludGhldGljSW5wdXRFdmVudDxIVE1MSW5wdXRFbGVtZW50PixcbiAgICB2YWx1ZTogc3RyaW5nLFxuICB9KSA9PiB2b2lkLFxuICBvbkZvY3VzPzogKHtcbiAgICBldmVudDogU3ludGhldGljRm9jdXNFdmVudDxIVE1MSW5wdXRFbGVtZW50PixcbiAgICB2YWx1ZTogc3RyaW5nLFxuICB9KSA9PiB2b2lkLFxuICBvbktleURvd24/OiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNLZXlib2FyZEV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+LFxuICAgIHZhbHVlOiBzdHJpbmcsXG4gIH0pID0+IHZvaWQsXG4gIHBsYWNlaG9sZGVyPzogc3RyaW5nLFxuICB0eXBlPzogJ2RhdGUnIHwgJ2VtYWlsJyB8ICdudW1iZXInIHwgJ3Bhc3N3b3JkJyB8ICd0ZXh0JyB8ICd1cmwnLFxuICB2YWx1ZT86IHN0cmluZyxcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgZm9jdXNlZDogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0RmllbGQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYXV0b0NvbXBsZXRlOiBQcm9wVHlwZXMub25lT2YoW1xuICAgICAgJ2N1cnJlbnQtcGFzc3dvcmQnLFxuICAgICAgJ25ldy1wYXNzd29yZCcsXG4gICAgICAnb24nLFxuICAgICAgJ29mZicsXG4gICAgICAndXNlcm5hbWUnLFxuICAgIF0pLFxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBlcnJvck1lc3NhZ2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgaGFzRXJyb3I6IFByb3BUeXBlcy5ib29sLFxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uS2V5RG93bjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgdHlwZTogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAgICdkYXRlJyxcbiAgICAgICdlbWFpbCcsXG4gICAgICAnbnVtYmVyJyxcbiAgICAgICdwYXNzd29yZCcsXG4gICAgICAndGV4dCcsXG4gICAgICAndXJsJyxcbiAgICBdKSxcbiAgICB2YWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBoYXNFcnJvcjogZmFsc2UsXG4gICAgdHlwZTogJ3RleHQnLFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIGZvY3VzZWQ6IGZhbHNlLFxuICB9O1xuXG4gIHNldFRleHRGaWVsZFJlZiA9IChyZWY6ID9IVE1MSW5wdXRFbGVtZW50KSA9PiB7XG4gICAgdGhpcy50ZXh0ZmllbGQgPSByZWY7XG4gIH07XG5cbiAgaGFuZGxlQ2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBvbkNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICBvbkNoYW5nZSh7IGV2ZW50LCB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSB9KTtcbiAgfTtcblxuICBoYW5kbGVCbHVyID0gKGV2ZW50OiBTeW50aGV0aWNGb2N1c0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBvbkJsdXIgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKG9uQmx1cikge1xuICAgICAgb25CbHVyKHsgZXZlbnQsIHZhbHVlOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlIH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVGb2N1cyA9IChldmVudDogU3ludGhldGljRm9jdXNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25Gb2N1cyB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAob25Gb2N1cykge1xuICAgICAgb25Gb2N1cyh7IGV2ZW50LCB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlS2V5RG93biA9IChldmVudDogU3ludGhldGljS2V5Ym9hcmRFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25LZXlEb3duIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChvbktleURvd24pIHtcbiAgICAgIG9uS2V5RG93bih7IGV2ZW50LCB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gTk9URTogd2UgY2Fubm90IG1vdmUgdG8gUmVhY3QgY3JlYXRlUmVmIHVudGlsIHdlIGF1ZGl0IHVzZXMgb2YgY2FsbHNpdGVzXG4gIC8vIHRoYXQgcmVhY2ggaW50byB0aGlzIGNvbXBvbmVudCBhbmQgdXNlIHRoaXMgaW5zdGFuY2UgdmFyaWFibGVcbiAgdGV4dGZpZWxkOiA/SFRNTElucHV0RWxlbWVudDtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXV0b0NvbXBsZXRlLFxuICAgICAgZGlzYWJsZWQsXG4gICAgICBlcnJvck1lc3NhZ2UsXG4gICAgICBoYXNFcnJvcixcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgdHlwZSxcbiAgICAgIHZhbHVlLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgeyBmb2N1c2VkIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzbmFtZXMoXG4gICAgICBzdHlsZXMudGV4dEZpZWxkLFxuICAgICAgZGlzYWJsZWQgPyBzdHlsZXMuZGlzYWJsZWQgOiBzdHlsZXMuZW5hYmxlZCxcbiAgICAgIGhhc0Vycm9yIHx8IGVycm9yTWVzc2FnZSA/IHN0eWxlcy5lcnJvcmVkIDogc3R5bGVzLm5vcm1hbFxuICAgICk7XG5cbiAgICAvLyB0eXBlPSdudW1iZXInIGRvZXNuJ3Qgd29yayBvbiBpb3Mgc2FmYXJpIHdpdGhvdXQgYSBwYXR0ZXJuXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQ0NDc2NjgvaW5wdXQtdHlwZS1udW1iZXItaXMtbm90LXNob3dpbmctYS1udW1iZXIta2V5cGFkLW9uLWlvc1xuICAgIGNvbnN0IHBhdHRlcm4gPSB0eXBlID09PSAnbnVtYmVyJyA/ICdcXFxcZConIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxzcGFuPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICBhcmlhLWRlc2NyaWJlZGJ5PXtlcnJvck1lc3NhZ2UgJiYgZm9jdXNlZCA/IGAke2lkfS1lcnJvcmAgOiBudWxsfVxuICAgICAgICAgIGFyaWEtaW52YWxpZD17ZXJyb3JNZXNzYWdlIHx8IGhhc0Vycm9yID8gJ3RydWUnIDogJ2ZhbHNlJ31cbiAgICAgICAgICBhdXRvQ29tcGxldGU9e2F1dG9Db21wbGV0ZX1cbiAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzZXN9XG4gICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgIGlkPXtpZH1cbiAgICAgICAgICBuYW1lPXtuYW1lfVxuICAgICAgICAgIG9uQmx1cj17dGhpcy5oYW5kbGVCbHVyfVxuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZUNoYW5nZX1cbiAgICAgICAgICBvbkZvY3VzPXt0aGlzLmhhbmRsZUZvY3VzfVxuICAgICAgICAgIG9uS2V5RG93bj17dGhpcy5oYW5kbGVLZXlEb3dufVxuICAgICAgICAgIHBhdHRlcm49e3BhdHRlcm59XG4gICAgICAgICAgcGxhY2Vob2xkZXI9e3BsYWNlaG9sZGVyfVxuICAgICAgICAgIHJlZj17dGhpcy5zZXRUZXh0RmllbGRSZWZ9XG4gICAgICAgICAgdHlwZT17dHlwZX1cbiAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgIC8+XG4gICAgICAgIHtlcnJvck1lc3NhZ2UgJiYgKFxuICAgICAgICAgIDxCb3ggbWFyZ2luVG9wPXsxfT5cbiAgICAgICAgICAgIDxGb3JtRXJyb3JNZXNzYWdlIGlkPXtpZH0gdGV4dD17ZXJyb3JNZXNzYWdlfSAvPlxuICAgICAgICAgIDwvQm94PlxuICAgICAgICApfVxuICAgICAgPC9zcGFuPlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5pbXBvcnQgTWFzayBmcm9tICcuL01hc2suanMnO1xuaW1wb3J0IFRleHQgZnJvbSAnLi9UZXh0LmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjb2xvcj86ICdkYXJrR3JheScgfCAnb3JhbmdlJyxcbiAgaWNvbj86ICdhcnJvdy1jaXJjbGUtZm9yd2FyZCcsIC8vIGxlYXZpbmcgb3BlbiB0byBhZGRpdGlvbmFsIGljb25zIGluIHRoZSBmdXR1cmVcbiAgdGV4dDogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPixcbiAgdGh1bWJuYWlsPzogUmVhY3QuTm9kZSxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUb2FzdChwcm9wczogUHJvcHMpIHtcbiAgY29uc3QgeyBjb2xvciA9ICdkYXJrR3JheScsIGljb24sIHRodW1ibmFpbCwgdGV4dCB9ID0gcHJvcHM7XG5cbiAgbGV0IGNvbnRlbnRzO1xuICAvLyBDb25maXJtYXRpb24gVG9hc3RzXG4gIGlmICh0ZXh0IGluc3RhbmNlb2YgQXJyYXkgJiYgdGV4dC5sZW5ndGggPiAxKSB7XG4gICAgY29udGVudHMgPSAoXG4gICAgICA8Qm94IHhzPXt7IGRpc3BsYXk6ICdmbGV4JyB9fT5cbiAgICAgICAgPEJveCB4cz17eyBkaXNwbGF5OiAnZmxleENvbHVtbicgfX0gZmxleD1cIm5vbmVcIiBqdXN0aWZ5Q29udGVudD1cImNlbnRlclwiPlxuICAgICAgICAgIHt0aHVtYm5haWwgPyAoXG4gICAgICAgICAgICA8TWFzayBzaGFwZT1cInJvdW5kZWRcIiBoZWlnaHQ9ezQ4fSB3aWR0aD17NDh9PlxuICAgICAgICAgICAgICB7dGh1bWJuYWlsfVxuICAgICAgICAgICAgPC9NYXNrPlxuICAgICAgICAgICkgOiBudWxsfVxuICAgICAgICA8L0JveD5cbiAgICAgICAgPEJveFxuICAgICAgICAgIHhzPXt7IGRpc3BsYXk6ICdmbGV4Q29sdW1uJyB9fVxuICAgICAgICAgIGp1c3RpZnlDb250ZW50PVwiY2VudGVyXCJcbiAgICAgICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7IF9fc3R5bGU6IHsgcGFkZGluZ0xlZnQ6IDEwIH0gfX1cbiAgICAgICAgPlxuICAgICAgICAgIDxCb3hcbiAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyBmb250V2VpZ2h0OiAnbm9ybWFsJyB9IH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPFRleHQgY29sb3I9XCJ3aGl0ZVwiIHNpemU9XCJsZ1wiPlxuICAgICAgICAgICAgICB7dGV4dFswXX1cbiAgICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgICA8L0JveD5cbiAgICAgICAgICA8VGV4dCBib2xkIGNvbG9yPVwid2hpdGVcIiBzaXplPVwibGdcIj5cbiAgICAgICAgICAgIHt0ZXh0WzFdfVxuICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgPC9Cb3g+XG4gICAgICA8L0JveD5cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvYXN0cyBhcyBHdWlkZXNcbiAgICBjb250ZW50cyA9IChcbiAgICAgIDxCb3hcbiAgICAgICAgeHM9e3sgZGlzcGxheTogJ2ZsZXgnIH19XG4gICAgICAgIGp1c3RpZnlDb250ZW50PVwiYmV0d2VlblwiXG4gICAgICAgIGFsaWduSXRlbXM9XCJjZW50ZXJcIlxuICAgICAgPlxuICAgICAgICA8VGV4dCBib2xkIGNvbG9yPVwid2hpdGVcIiBzaXplPVwibGdcIj5cbiAgICAgICAgICB7dGV4dH1cbiAgICAgICAgPC9UZXh0PlxuICAgICAgICB7aWNvbiAmJiAoXG4gICAgICAgICAgPEJveCBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7IF9fc3R5bGU6IHsgcGFkZGluZ0xlZnQ6IDI0IH0gfX0+XG4gICAgICAgICAgICA8SWNvbiBhY2Nlc3NpYmlsaXR5TGFiZWw9XCJcIiBjb2xvcj1cIndoaXRlXCIgaWNvbj17aWNvbn0gc2l6ZT17MzZ9IC8+XG4gICAgICAgICAgPC9Cb3g+XG4gICAgICAgICl9XG4gICAgICA8L0JveD5cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8Qm94IG1hcmdpbkJvdHRvbT17M30gcGFkZGluZ1g9ezR9IG1heFdpZHRoPXszNzZ9IHdpZHRoPVwiMTAwdndcIj5cbiAgICAgIDxCb3ggY29sb3I9e2NvbG9yfSBmaXQgcGFkZGluZ1g9ezh9IHBhZGRpbmdZPXs1fSBzaGFwZT1cInBpbGxcIj5cbiAgICAgICAge2NvbnRlbnRzfVxuICAgICAgPC9Cb3g+XG4gICAgPC9Cb3g+XG4gICk7XG59XG5cblRvYXN0LnByb3BUeXBlcyA9IHtcbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ2RhcmtHcmF5JywgJ29yYW5nZSddKSxcbiAgaWNvbjogUHJvcFR5cGVzLm9uZU9mKFsnYXJyb3ctY2lyY2xlLWZvcndhcmQnXSksIC8vIGxlYXZpbmcgb3BlbiB0byBhZGRpdGlvbmFsIGljb25zIGluIHRoZSBmdXR1cmVcbiAgdGV4dDogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgUHJvcFR5cGVzLnN0cmluZyxcbiAgICBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSxcbiAgXSkuaXNSZXF1aXJlZCxcbiAgdGh1bWJuYWlsOiBQcm9wVHlwZXMubm9kZSxcbn07XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQ29udHJvbGxlciBmcm9tICcuL0NvbnRyb2xsZXIuanMnO1xuaW1wb3J0IFRleHQgZnJvbSAnLi9UZXh0LmpzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbjogUmVhY3QuTm9kZSxcbiAgaW5saW5lPzogYm9vbGVhbixcbiAgdGV4dDogc3RyaW5nLFxufH07XG5cbnR5cGUgU3RhdGUgPSB7fFxuICBob3ZlcmVkOiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRlID0ge1xuICAgIGhvdmVyZWQ6IGZhbHNlLFxuICB9O1xuXG4gIGNoaWxkUmVmOiB7fCBjdXJyZW50OiBudWxsIHwgUmVhY3QuRWxlbWVudFJlZjwnZGl2Jz4gfH0gPSBSZWFjdC5jcmVhdGVSZWYoKTtcblxuICBoYW5kbGVNb3VzZUVudGVyID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGhvdmVyZWQ6IHRydWUgfSk7XG5cbiAgaGFuZGxlTW91c2VMZWF2ZSA9ICgpID0+IHRoaXMuc2V0U3RhdGUoeyBob3ZlcmVkOiBmYWxzZSB9KTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgaW5saW5lLCB0ZXh0IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgaG92ZXJlZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7IGN1cnJlbnQ6IGFuY2hvciB9ID0gdGhpcy5jaGlsZFJlZjtcblxuICAgIHJldHVybiAoXG4gICAgICA8Qm94IGRpc3BsYXk9e2lubGluZSA/ICdpbmxpbmVCbG9jaycgOiAnYmxvY2snfT5cbiAgICAgICAgPEJveFxuICAgICAgICAgIG9uTW91c2VFbnRlcj17dGhpcy5oYW5kbGVNb3VzZUVudGVyfVxuICAgICAgICAgIG9uTW91c2VMZWF2ZT17dGhpcy5oYW5kbGVNb3VzZUxlYXZlfVxuICAgICAgICAgIHJlZj17dGhpcy5jaGlsZFJlZn1cbiAgICAgICAgPlxuICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9Cb3g+XG4gICAgICAgIHtob3ZlcmVkICYmXG4gICAgICAgICAgISFhbmNob3IgJiYgKFxuICAgICAgICAgICAgPENvbnRyb2xsZXJcbiAgICAgICAgICAgICAgYW5jaG9yPXthbmNob3J9XG4gICAgICAgICAgICAgIGJnQ29sb3I9XCJkYXJrR3JheVwiXG4gICAgICAgICAgICAgIGNhcmV0PXtmYWxzZX1cbiAgICAgICAgICAgICAgaWRlYWxEaXJlY3Rpb249XCJkb3duXCJcbiAgICAgICAgICAgICAgb25EaXNtaXNzPXtub29wfVxuICAgICAgICAgICAgICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3JcbiAgICAgICAgICAgICAgc2l6ZT17bnVsbH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPEJveCBtYXhXaWR0aD17MTgwfSBwYWRkaW5nWT17MX0gcGFkZGluZ1g9ezJ9IHJvbGU9XCJ0b29sdGlwXCI+XG4gICAgICAgICAgICAgICAgPFRleHQgY29sb3I9XCJ3aGl0ZVwiIHNpemU9XCJ4c1wiPlxuICAgICAgICAgICAgICAgICAge3RleHR9XG4gICAgICAgICAgICAgICAgPC9UZXh0PlxuICAgICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICAgIDwvQ29udHJvbGxlcj5cbiAgICAgICAgICApfVxuICAgICAgPC9Cb3g+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9Ub3VjaGFibGUuY3NzJztcblxudHlwZSBTaGFwZSA9XG4gIHwgJ3NxdWFyZSdcbiAgfCAncm91bmRlZCdcbiAgfCAncGlsbCdcbiAgfCAnY2lyY2xlJ1xuICB8ICdyb3VuZGVkVG9wJ1xuICB8ICdyb3VuZGVkQm90dG9tJ1xuICB8ICdyb3VuZGVkTGVmdCdcbiAgfCAncm91bmRlZFJpZ2h0JztcblxudHlwZSBNb3VzZUN1cnNvciA9XG4gIHwgJ2NvcHknXG4gIHwgJ2dyYWInXG4gIHwgJ2dyYWJiaW5nJ1xuICB8ICdtb3ZlJ1xuICB8ICdub0Ryb3AnXG4gIHwgJ3BvaW50ZXInXG4gIHwgJ3pvb21JbidcbiAgfCAnem9vbU91dCc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGZ1bGxIZWlnaHQ/OiBib29sZWFuLFxuICBmdWxsV2lkdGg/OiBib29sZWFuLFxuICBtb3VzZUN1cnNvcj86IE1vdXNlQ3Vyc29yLFxuICBvbk1vdXNlRW50ZXI/OiAoeyBldmVudDogU3ludGhldGljTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4gfSkgPT4gdm9pZCxcbiAgb25Nb3VzZUxlYXZlPzogKHsgZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+IH0pID0+IHZvaWQsXG4gIG9uVG91Y2g/OiAoe1xuICAgIGV2ZW50OlxuICAgICAgfCBTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PlxuICAgICAgfCBTeW50aGV0aWNLZXlib2FyZEV2ZW50PEhUTUxEaXZFbGVtZW50PixcbiAgfSkgPT4gdm9pZCxcbiAgc2hhcGU/OiBTaGFwZSxcbnx9O1xuXG5jb25zdCBTUEFDRV9DSEFSX0NPREUgPSAzMjtcbmNvbnN0IEVOVEVSX0NIQVJfQ09ERSA9IDEzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb3VjaGFibGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHM+IHtcbiAgaGFuZGxlS2V5UHJlc3MgPSAoZXZlbnQ6IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBvblRvdWNoIH0gPSB0aGlzLnByb3BzO1xuICAgIC8vIENoZWNrIHRvIHNlZSBpZiBzcGFjZSBvciBlbnRlciB3ZXJlIHByZXNzZWRcbiAgICBpZiAoXG4gICAgICBvblRvdWNoICYmXG4gICAgICAoZXZlbnQuY2hhckNvZGUgPT09IFNQQUNFX0NIQVJfQ09ERSB8fCBldmVudC5jaGFyQ29kZSA9PT0gRU5URVJfQ0hBUl9DT0RFKVxuICAgICkge1xuICAgICAgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb24gdG8gc3RvcCBzY3JvbGxpbmcgd2hlbiBzcGFjZSBpcyBwcmVzc2VkXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgb25Ub3VjaCh7IGV2ZW50IH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVNb3VzZUVudGVyID0gKGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25Nb3VzZUVudGVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChvbk1vdXNlRW50ZXIpIHtcbiAgICAgIG9uTW91c2VFbnRlcih7IGV2ZW50IH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVNb3VzZUxlYXZlID0gKGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25Nb3VzZUxlYXZlIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChvbk1vdXNlTGVhdmUpIHtcbiAgICAgIG9uTW91c2VMZWF2ZSh7IGV2ZW50IH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVDbGljayA9IChldmVudDogU3ludGhldGljTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uVG91Y2ggfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKG9uVG91Y2gpIHtcbiAgICAgIG9uVG91Y2goeyBldmVudCB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZnVsbFdpZHRoID0gdHJ1ZSxcbiAgICAgIGZ1bGxIZWlnaHQsXG4gICAgICBtb3VzZUN1cnNvciA9ICdwb2ludGVyJyxcbiAgICAgIHNoYXBlID0gJ3NxdWFyZScsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBjbGFzc2VzID0gY2xhc3NuYW1lcyhcbiAgICAgIHN0eWxlcy50b3VjaGFibGUsXG4gICAgICBzdHlsZXNbbW91c2VDdXJzb3JdLFxuICAgICAgc3R5bGVzW3NoYXBlXSxcbiAgICAgIHtcbiAgICAgICAgW3N0eWxlcy5mdWxsSGVpZ2h0XTogZnVsbEhlaWdodCxcbiAgICAgICAgW3N0eWxlcy5mdWxsV2lkdGhdOiBmdWxsV2lkdGgsXG4gICAgICB9XG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlc31cbiAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja31cbiAgICAgICAgb25Nb3VzZUVudGVyPXt0aGlzLmhhbmRsZU1vdXNlRW50ZXJ9XG4gICAgICAgIG9uTW91c2VMZWF2ZT17dGhpcy5oYW5kbGVNb3VzZUxlYXZlfVxuICAgICAgICBvbktleVByZXNzPXt0aGlzLmhhbmRsZUtleVByZXNzfVxuICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgdGFiSW5kZXg9XCIwXCJcbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5Ub3VjaGFibGUucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGZ1bGxIZWlnaHQ6IFByb3BUeXBlcy5ib29sLFxuICBmdWxsV2lkdGg6IFByb3BUeXBlcy5ib29sLFxuICBtb3VzZUN1cnNvcjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnY29weScsXG4gICAgJ2dyYWInLFxuICAgICdncmFiYmluZycsXG4gICAgJ21vdmUnLFxuICAgICdub0Ryb3AnLFxuICAgICdwb2ludGVyJyxcbiAgICAnem9vbUluJyxcbiAgICAnem9vbU91dCcsXG4gIF0pLFxuICBvblRvdWNoOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZUVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgc2hhcGU6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ3NxdWFyZScsXG4gICAgJ3JvdW5kZWQnLFxuICAgICdwaWxsJyxcbiAgICAnY2lyY2xlJyxcbiAgICAncm91bmRlZFRvcCcsXG4gICAgJ3JvdW5kZWRCb3R0b20nLFxuICAgICdyb3VuZGVkTGVmdCcsXG4gICAgJ3JvdW5kZWRSaWdodCcsXG4gIF0pLFxufTtcbiIsIi8vIEBmbG93XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9WaWRlby5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY3VycmVudFRpbWU6IG51bWJlcixcbiAgZHVyYXRpb246IG51bWJlcixcbiAgc2VlazogKHRpbWU6IG51bWJlcikgPT4gdm9pZCxcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgc2Vla2luZzogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWRlb1BsYXloZWFkIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBjdXJyZW50VGltZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIGR1cmF0aW9uOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgc2VlazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBzZWVraW5nOiBmYWxzZSxcbiAgfTtcblxuICBzZXRQbGF5aGVhZFJlZiA9IChyZWY6ID9IVE1MRGl2RWxlbWVudCkgPT4ge1xuICAgIHRoaXMucGxheWhlYWQgPSByZWY7XG4gIH07XG5cbiAgc2VlayA9IChjbGllbnRYOiBudW1iZXIpID0+IHtcbiAgICBpZiAodGhpcy5wbGF5aGVhZCkge1xuICAgICAgY29uc3QgeyBkdXJhdGlvbiwgc2VlayB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHsgbGVmdCwgd2lkdGggfSA9IHRoaXMucGxheWhlYWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBwZXJjZW50ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oKGNsaWVudFggLSBsZWZ0KSAvIHdpZHRoLCAxKSk7XG4gICAgICBjb25zdCBuZXdUaW1lID0gcGVyY2VudCAqIGR1cmF0aW9uO1xuICAgICAgc2VlayhuZXdUaW1lKTtcbiAgICB9XG4gIH07XG5cbiAgc3RvcENsaWNrID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgaGFuZGxlTW91c2VEb3duID0gKGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBzZWVraW5nOiB0cnVlIH0pO1xuICAgIHRoaXMuc2VlayhldmVudC5jbGllbnRYKTtcbiAgfTtcblxuICBoYW5kbGVNb3VzZU1vdmUgPSAoZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBzZWVraW5nIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzZWVraW5nKSB7XG4gICAgICB0aGlzLnNlZWsoZXZlbnQuY2xpZW50WCk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZU1vdXNlVXAgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHNlZWtpbmc6IGZhbHNlIH0pO1xuICB9O1xuXG4gIHBsYXloZWFkOiA/SFRNTERpdkVsZW1lbnQ7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY3VycmVudFRpbWUsIGR1cmF0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHdpZHRoID0gYCR7TWF0aC5mbG9vcigoY3VycmVudFRpbWUgKiAxMDAwMCkgLyBkdXJhdGlvbikgLyAxMDB9JWA7XG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3hcbiAgICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgICAgIGRpc3BsYXk9XCJmbGV4XCJcbiAgICAgICAgZmxleD1cImdyb3dcIlxuICAgICAgICBhbGlnbkl0ZW1zPVwiY2VudGVyXCJcbiAgICAgICAgaGVpZ2h0PXsxNn1cbiAgICAgID5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGFyaWEtdmFsdWVtYXg9e2R1cmF0aW9ufVxuICAgICAgICAgIGFyaWEtdmFsdWVtaW49XCIwXCJcbiAgICAgICAgICBhcmlhLXZhbHVlbm93PXtjdXJyZW50VGltZX1cbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5wbGF5aGVhZH1cbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLnN0b3BDbGlja31cbiAgICAgICAgICBvbktleVByZXNzPXt0aGlzLnN0b3BDbGlja31cbiAgICAgICAgICBvbk1vdXNlRG93bj17dGhpcy5oYW5kbGVNb3VzZURvd259XG4gICAgICAgICAgb25Nb3VzZU1vdmU9e3RoaXMuaGFuZGxlTW91c2VNb3ZlfVxuICAgICAgICAgIG9uTW91c2VVcD17dGhpcy5oYW5kbGVNb3VzZVVwfVxuICAgICAgICAgIHJlZj17dGhpcy5zZXRQbGF5aGVhZFJlZn1cbiAgICAgICAgICByb2xlPVwicHJvZ3Jlc3NiYXJcIlxuICAgICAgICAgIHRhYkluZGV4PVwiLTFcIlxuICAgICAgICA+XG4gICAgICAgICAgPEJveFxuICAgICAgICAgICAgbGVmdFxuICAgICAgICAgICAgcmlnaHRcbiAgICAgICAgICAgIHBvc2l0aW9uPVwiYWJzb2x1dGVcIlxuICAgICAgICAgICAgY29sb3I9XCJsaWdodEdyYXlcIlxuICAgICAgICAgICAgc2hhcGU9XCJyb3VuZGVkXCJcbiAgICAgICAgICAgIGhlaWdodD17NH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8Qm94IGNvbG9yPVwid2hpdGVcIiBzaGFwZT1cInJvdW5kZWRcIiBoZWlnaHQ9XCIxMDAlXCIgd2lkdGg9e3dpZHRofSAvPlxuICAgICAgICAgIDwvQm94PlxuICAgICAgICAgIDxCb3hcbiAgICAgICAgICAgIHBvc2l0aW9uPVwiYWJzb2x1dGVcIlxuICAgICAgICAgICAgc2hhcGU9XCJyb3VuZGVkXCJcbiAgICAgICAgICAgIGhlaWdodD17NH1cbiAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyBsZWZ0OiB3aWR0aCB9IH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPEJveFxuICAgICAgICAgICAgICBzaGFwZT1cImNpcmNsZVwiXG4gICAgICAgICAgICAgIHdpZHRoPXsxNn1cbiAgICAgICAgICAgICAgaGVpZ2h0PXsxNn1cbiAgICAgICAgICAgICAgY29sb3I9XCJ3aGl0ZVwiXG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQ9ey0yfVxuICAgICAgICAgICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7IF9fc3R5bGU6IHsgbWFyZ2luVG9wOiAtNiB9IH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvQm94PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvQm94PlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5pbXBvcnQgVGV4dCBmcm9tICcuL1RleHQuanMnO1xuaW1wb3J0IFRvdWNoYWJsZSBmcm9tICcuL1RvdWNoYWJsZS5qcyc7XG5pbXBvcnQgVmlkZW9QbGF5aGVhZCBmcm9tICcuL1ZpZGVvUGxheWhlYWQuanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1ZpZGVvLmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY2Nlc3NpYmlsaXR5TWF4aW1pemVMYWJlbDogc3RyaW5nLFxuICBhY2Nlc3NpYmlsaXR5TWluaW1pemVMYWJlbDogc3RyaW5nLFxuICBhY2Nlc3NpYmlsaXR5TXV0ZUxhYmVsOiBzdHJpbmcsXG4gIGFjY2Vzc2liaWxpdHlQYXVzZUxhYmVsOiBzdHJpbmcsXG4gIGFjY2Vzc2liaWxpdHlQbGF5TGFiZWw6IHN0cmluZyxcbiAgYWNjZXNzaWJpbGl0eVVubXV0ZUxhYmVsOiBzdHJpbmcsXG4gIGN1cnJlbnRUaW1lOiBudW1iZXIsXG4gIGR1cmF0aW9uOiBudW1iZXIsXG4gIGZ1bGxzY3JlZW46IGJvb2xlYW4sXG4gIG9uRnVsbHNjcmVlbkNoYW5nZTogKCkgPT4gdm9pZCxcbiAgb25QYXVzZTogKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHZvaWQsXG4gIG9uUGxheTogKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHZvaWQsXG4gIG9uVm9sdW1lQ2hhbmdlOiAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4gdm9pZCxcbiAgcGxheWluZzogYm9vbGVhbixcbiAgc2VlazogKHRpbWU6IG51bWJlcikgPT4gdm9pZCxcbiAgdm9sdW1lOiBudW1iZXIsXG58fTtcblxuY29uc3QgZnVsbHNjcmVlbkVuYWJsZWQgPSAoKSA9PlxuICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICBkb2N1bWVudC5mdWxsc2NyZWVuRW5hYmxlZCB8fFxuICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCB8fFxuICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRW5hYmxlZCB8fFxuICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbmFibGVkO1xuXG5jb25zdCB0aW1lVG9TdHJpbmcgPSAodGltZT86IG51bWJlcikgPT4ge1xuICBjb25zdCByb3VuZGVkID0gTWF0aC5mbG9vcih0aW1lIHx8IDApO1xuICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcihyb3VuZGVkIC8gNjApO1xuICBjb25zdCBzZWNvbmRzID0gcm91bmRlZCAtIG1pbnV0ZXMgKiA2MDtcbiAgY29uc3QgbWludXRlc1N0ciA9IG1pbnV0ZXMgPCAxMCA/IGAwJHttaW51dGVzfWAgOiBtaW51dGVzO1xuICBjb25zdCBzZWNvbmRzU3RyID0gc2Vjb25kcyA8IDEwID8gYDAke3NlY29uZHN9YCA6IHNlY29uZHM7XG4gIHJldHVybiBgJHttaW51dGVzU3RyfToke3NlY29uZHNTdHJ9YDtcbn07XG5cbmNsYXNzIFZpZGVvQ29udHJvbHMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHM+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBhY2Nlc3NpYmlsaXR5TWF4aW1pemVMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGFjY2Vzc2liaWxpdHlNaW5pbWl6ZUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgYWNjZXNzaWJpbGl0eU11dGVMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGFjY2Vzc2liaWxpdHlQYXVzZUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgYWNjZXNzaWJpbGl0eVBsYXlMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGFjY2Vzc2liaWxpdHlVbm11dGVMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGN1cnJlbnRUaW1lOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgZHVyYXRpb246IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICBmdWxsc2NyZWVuOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAgIG9uRnVsbHNjcmVlbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvblBhdXNlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIG9uUGxheTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvblZvbHVtZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBwbGF5aW5nOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAgIHNlZWs6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgdm9sdW1lOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIH07XG5cbiAgaGFuZGxlRnVsbHNjcmVlbkNoYW5nZSA9ICh7XG4gICAgZXZlbnQsXG4gIH06IHtcbiAgICBldmVudDpcbiAgICAgIHwgU3ludGhldGljTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD5cbiAgICAgIHwgU3ludGhldGljS2V5Ym9hcmRFdmVudDxIVE1MRGl2RWxlbWVudD4sXG4gIH0pID0+IHtcbiAgICBjb25zdCB7IG9uRnVsbHNjcmVlbkNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBvbkZ1bGxzY3JlZW5DaGFuZ2UoKTtcbiAgfTtcblxuICBoYW5kbGVQbGF5aW5nQ2hhbmdlID0gKHtcbiAgICBldmVudCxcbiAgfToge1xuICAgIGV2ZW50OlxuICAgICAgfCBTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PlxuICAgICAgfCBTeW50aGV0aWNLZXlib2FyZEV2ZW50PEhUTUxEaXZFbGVtZW50PixcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHsgcGxheWluZywgb25QYXVzZSwgb25QbGF5IH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChwbGF5aW5nKSB7XG4gICAgICBvblBhdXNlKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb25QbGF5KGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlVm9sdW1lQ2hhbmdlID0gKHtcbiAgICBldmVudCxcbiAgfToge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzICovXG4gICAgZXZlbnQ6XG4gICAgICB8IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+XG4gICAgICB8IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ8SFRNTERpdkVsZW1lbnQ+LFxuICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3Qvbm8tdW51c2VkLXByb3AtdHlwZXMgKi9cbiAgfSkgPT4ge1xuICAgIGNvbnN0IHsgb25Wb2x1bWVDaGFuZ2UgfSA9IHRoaXMucHJvcHM7XG4gICAgb25Wb2x1bWVDaGFuZ2UoZXZlbnQpO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBhY2Nlc3NpYmlsaXR5TWF4aW1pemVMYWJlbCxcbiAgICAgIGFjY2Vzc2liaWxpdHlNaW5pbWl6ZUxhYmVsLFxuICAgICAgYWNjZXNzaWJpbGl0eU11dGVMYWJlbCxcbiAgICAgIGFjY2Vzc2liaWxpdHlQYXVzZUxhYmVsLFxuICAgICAgYWNjZXNzaWJpbGl0eVBsYXlMYWJlbCxcbiAgICAgIGFjY2Vzc2liaWxpdHlVbm11dGVMYWJlbCxcbiAgICAgIGN1cnJlbnRUaW1lLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBmdWxsc2NyZWVuLFxuICAgICAgcGxheWluZyxcbiAgICAgIHNlZWssXG4gICAgICB2b2x1bWUsXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgbXV0ZWQgPSB2b2x1bWUgPT09IDA7XG4gICAgY29uc3Qgc2hvd0Z1bGxzY3JlZW5CdXR0b24gPVxuICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIWZ1bGxzY3JlZW5FbmFibGVkKCk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY29udHJvbHN9PlxuICAgICAgICA8Qm94IHBhZGRpbmc9ezJ9PlxuICAgICAgICAgIDxUb3VjaGFibGUgb25Ub3VjaD17dGhpcy5oYW5kbGVQbGF5aW5nQ2hhbmdlfSBmdWxsV2lkdGg9e2ZhbHNlfT5cbiAgICAgICAgICAgIDxJY29uXG4gICAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlMYWJlbD17XG4gICAgICAgICAgICAgICAgcGxheWluZyA/IGFjY2Vzc2liaWxpdHlQYXVzZUxhYmVsIDogYWNjZXNzaWJpbGl0eVBsYXlMYWJlbFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbG9yPVwid2hpdGVcIlxuICAgICAgICAgICAgICBpY29uPXtwbGF5aW5nID8gJ3BhdXNlJyA6ICdwbGF5J31cbiAgICAgICAgICAgICAgc2l6ZT17MjB9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvVG91Y2hhYmxlPlxuICAgICAgICA8L0JveD5cbiAgICAgICAgPEJveCB3aWR0aD17NTB9IHBhZGRpbmc9ezJ9PlxuICAgICAgICAgIDxUZXh0IGNvbG9yPVwid2hpdGVcIiBhbGlnbj1cInJpZ2h0XCIgc2l6ZT1cInhzXCI+XG4gICAgICAgICAgICB7dGltZVRvU3RyaW5nKGN1cnJlbnRUaW1lKX1cbiAgICAgICAgICA8L1RleHQ+XG4gICAgICAgIDwvQm94PlxuICAgICAgICA8Qm94IHBhZGRpbmc9ezJ9IGZsZXg9XCJncm93XCI+XG4gICAgICAgICAgPFZpZGVvUGxheWhlYWRcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lPXtjdXJyZW50VGltZX1cbiAgICAgICAgICAgIGR1cmF0aW9uPXtkdXJhdGlvbn1cbiAgICAgICAgICAgIHNlZWs9e3NlZWt9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9Cb3g+XG4gICAgICAgIDxCb3ggd2lkdGg9ezUwfSBwYWRkaW5nPXsyfT5cbiAgICAgICAgICA8VGV4dCBjb2xvcj1cIndoaXRlXCIgYWxpZ249XCJyaWdodFwiIHNpemU9XCJ4c1wiPlxuICAgICAgICAgICAge3RpbWVUb1N0cmluZyhkdXJhdGlvbil9XG4gICAgICAgICAgPC9UZXh0PlxuICAgICAgICA8L0JveD5cbiAgICAgICAgPEJveCBwYWRkaW5nPXsyfT5cbiAgICAgICAgICA8VG91Y2hhYmxlIG9uVG91Y2g9e3RoaXMuaGFuZGxlVm9sdW1lQ2hhbmdlfSBmdWxsV2lkdGg9e2ZhbHNlfT5cbiAgICAgICAgICAgIDxJY29uXG4gICAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlMYWJlbD17XG4gICAgICAgICAgICAgICAgbXV0ZWQgPyBhY2Nlc3NpYmlsaXR5VW5tdXRlTGFiZWwgOiBhY2Nlc3NpYmlsaXR5TXV0ZUxhYmVsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29sb3I9XCJ3aGl0ZVwiXG4gICAgICAgICAgICAgIGljb249e211dGVkID8gJ211dGUnIDogJ3NvdW5kJ31cbiAgICAgICAgICAgICAgc2l6ZT17MjB9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvVG91Y2hhYmxlPlxuICAgICAgICA8L0JveD5cbiAgICAgICAge3Nob3dGdWxsc2NyZWVuQnV0dG9uICYmIChcbiAgICAgICAgICA8Qm94IHBhZGRpbmc9ezJ9PlxuICAgICAgICAgICAgPFRvdWNoYWJsZSBvblRvdWNoPXt0aGlzLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2V9IGZ1bGxXaWR0aD17ZmFsc2V9PlxuICAgICAgICAgICAgICA8SWNvblxuICAgICAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlMYWJlbD17XG4gICAgICAgICAgICAgICAgICBmdWxsc2NyZWVuXG4gICAgICAgICAgICAgICAgICAgID8gYWNjZXNzaWJpbGl0eU1pbmltaXplTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgOiBhY2Nlc3NpYmlsaXR5TWF4aW1pemVMYWJlbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2xvcj1cIndoaXRlXCJcbiAgICAgICAgICAgICAgICBpY29uPXtmdWxsc2NyZWVuID8gJ21pbmltaXplJyA6ICdtYXhpbWl6ZSd9XG4gICAgICAgICAgICAgICAgc2l6ZT17MjB9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L1RvdWNoYWJsZT5cbiAgICAgICAgICA8L0JveD5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmlkZW9Db250cm9scztcbiIsIi8vIEBmbG93XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgVmlkZW9Db250cm9scyBmcm9tICcuL1ZpZGVvQ29udHJvbHMuanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1ZpZGVvLmNzcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcblxudHlwZSBTb3VyY2UgPVxuICB8IHN0cmluZ1xuICB8IEFycmF5PHt8IHR5cGU6ICd2aWRlby9tM3U4JyB8ICd2aWRlby9tcDQnIHwgJ3ZpZGVvL29nZycsIHNyYzogc3RyaW5nIHx9PjtcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFjY2Vzc2liaWxpdHlNYXhpbWl6ZUxhYmVsOiBzdHJpbmcsXG4gIGFjY2Vzc2liaWxpdHlNaW5pbWl6ZUxhYmVsOiBzdHJpbmcsXG4gIGFjY2Vzc2liaWxpdHlNdXRlTGFiZWw6IHN0cmluZyxcbiAgYWNjZXNzaWJpbGl0eVBhdXNlTGFiZWw6IHN0cmluZyxcbiAgYWNjZXNzaWJpbGl0eVBsYXlMYWJlbDogc3RyaW5nLFxuICBhY2Nlc3NpYmlsaXR5VW5tdXRlTGFiZWw6IHN0cmluZyxcbiAgYXNwZWN0UmF0aW86IG51bWJlcixcbiAgY2FwdGlvbnM6IHN0cmluZyxcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICBjb250cm9scz86IGJvb2xlYW4sXG4gIGxvb3A/OiBib29sZWFuLFxuICBvbkR1cmF0aW9uQ2hhbmdlPzogKHtcbiAgICBldmVudDogU3ludGhldGljRXZlbnQ8SFRNTFZpZGVvRWxlbWVudD4sXG4gICAgZHVyYXRpb246IG51bWJlcixcbiAgfSkgPT4gdm9pZCxcbiAgb25FbmRlZD86ICh7IGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PiB9KSA9PiB2b2lkLFxuICBvbkZ1bGxzY3JlZW5DaGFuZ2U/OiAoeyBldmVudDogRXZlbnQsIGZ1bGxzY3JlZW46IGJvb2xlYW4gfSkgPT4gdm9pZCxcbiAgb25Mb2FkZWRDaGFuZ2U/OiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PixcbiAgICBsb2FkZWQ6IG51bWJlcixcbiAgfSkgPT4gdm9pZCxcbiAgb25QbGF5PzogKHsgZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxEaXZFbGVtZW50PiB9KSA9PiB2b2lkLFxuICBvblBhdXNlPzogKHsgZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxEaXZFbGVtZW50PiB9KSA9PiB2b2lkLFxuICBvblJlYWR5PzogKHsgZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxWaWRlb0VsZW1lbnQ+IH0pID0+IHZvaWQsXG4gIG9uU2Vlaz86ICh7IGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PiB9KSA9PiB2b2lkLFxuICBvblRpbWVDaGFuZ2U/OiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PixcbiAgICB0aW1lOiBudW1iZXIsXG4gIH0pID0+IHZvaWQsXG4gIG9uVm9sdW1lQ2hhbmdlPzogKHtcbiAgICBldmVudDogU3ludGhldGljRXZlbnQ8SFRNTERpdkVsZW1lbnQ+LFxuICAgIHZvbHVtZTogbnVtYmVyLFxuICB9KSA9PiB2b2lkLFxuICBwbGF5YmFja1JhdGU6IG51bWJlcixcbiAgcGxheWluZzogYm9vbGVhbixcbiAgcGxheXNJbmxpbmU/OiBib29sZWFuLFxuICBwb3N0ZXI/OiBzdHJpbmcsXG4gIHByZWxvYWQ6ICdhdXRvJyB8ICdtZXRhZGF0YScgfCAnbm9uZScsXG4gIHNyYzogU291cmNlLFxuICB2b2x1bWU6IG51bWJlcixcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgY3VycmVudFRpbWU6IG51bWJlcixcbiAgZHVyYXRpb246IG51bWJlcixcbiAgZnVsbHNjcmVlbjogYm9vbGVhbixcbnx9O1xuXG4vLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBmdWxsc2NyZWVuIGFuZCB2ZW5kb3IgcHJlZml4ZXMgc2VlXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRnVsbHNjcmVlbl9BUElcblxuY29uc3QgcmVxdWVzdEZ1bGxzY3JlZW4gPSAoZWxlbWVudDogSFRNTEVsZW1lbnQpID0+IHtcbiAgaWYgKGVsZW1lbnQucmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICBlbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgfSBlbHNlIGlmIChlbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgICBlbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgfSBlbHNlIGlmIChlbGVtZW50Lm1velJlcXVlc3RGdWxsU2NyZWVuKSB7XG4gICAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgICBlbGVtZW50Lm1velJlcXVlc3RGdWxsU2NyZWVuKCk7XG4gICAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgfSBlbHNlIGlmIChlbGVtZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICAgIGVsZW1lbnQubXNSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICB9XG59O1xuXG5jb25zdCBleGl0RnVsbHNjcmVlbiA9ICgpID0+IHtcbiAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgaWYgKGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKSB7XG4gICAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgICBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpO1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICAgIGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKCk7XG4gICAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKSB7XG4gICAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgICBkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKCk7XG4gICAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuKSB7XG4gICAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgICBkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuKCk7XG4gIH1cbn07XG5cbi8vIE5vcm1hbGx5IGRvY3VtZW50LmZ1bGxzY3JlZW4gc3VmZmljZXMgaGVyZSBhcyBhIGZsYWcsIGJ1dCBJRTExIGRvZXMgbm90XG4vLyBoYXZlIGEgdmVuZG9yIHNwZWNpZmljIHZlcnNpb24gc28gd2UgbXVzdCBpbnN0ZWFkIHVzZSB0aGUgYWN0dWFsIGVsZW1lbnRcbmNvbnN0IGlzRnVsbHNjcmVlbiA9ICgpID0+XG4gIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8XG4gIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVsZW1lbnQ7XG5cbmNvbnN0IGFkZEZ1bGxzY3JlZW5FdmVudExpc3RlbmVyID0gKGxpc3RlbmVyOiBFdmVudExpc3RlbmVyKSA9PiB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBsaXN0ZW5lcik7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLCBsaXN0ZW5lcik7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLCBsaXN0ZW5lcik7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ01TRnVsbHNjcmVlbkNoYW5nZScsIGxpc3RlbmVyKTtcbn07XG5cbmNvbnN0IHJlbW92ZUZ1bGxzY3JlZW5FdmVudExpc3RlbmVyID0gKGxpc3RlbmVyOiBFdmVudExpc3RlbmVyKSA9PiB7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBsaXN0ZW5lcik7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLCBsaXN0ZW5lcik7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLCBsaXN0ZW5lcik7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ01TRnVsbHNjcmVlbkNoYW5nZScsIGxpc3RlbmVyKTtcbn07XG5cbmNvbnN0IGlzTmV3U291cmNlID0gKG9sZFNvdXJjZTogU291cmNlLCBuZXdTb3VyY2U6IFNvdXJjZSk6IGJvb2xlYW4gPT4ge1xuICBpZiAodHlwZW9mIG9sZFNvdXJjZSAhPT0gdHlwZW9mIG5ld1NvdXJjZSkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgdHlwZSBjaGFuZ2VkIGZyb20gc3RyaW5nIHRvIEFycmF5XG4gICAgLy8gb3IgdmljZSB2ZXJzYSwgd2UgaGF2ZSBhIG5ldyBzb3VyY2VcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShuZXdTb3VyY2UpKSB7XG4gICAgaWYgKG9sZFNvdXJjZS5sZW5ndGggIT09IG5ld1NvdXJjZS5sZW5ndGgpIHtcbiAgICAgIC8vIElmIHRoZSBzb3VyY2VzIGFyZSBib3RoIGFuIEFycmF5LCBhbmQgdGhlIGxlbmd0aHNcbiAgICAgIC8vIGRvIG5vdCBtYXRjaCB3ZSBldmFsdWF0ZSBhcyBhIG5ldyBzb3VyY2VcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgc291cmNlcyBhcmUgYm90aCBhbiBBcnJheSBhbmQgdGhlIHNhbWUgbGVuZ3RoLFxuICAgIC8vIHZlcmlmeSBldmVyeSBlbGVtZW50IHN0YXllZCB0aGUgc2FtZVxuICAgIHJldHVybiBuZXdTb3VyY2Uuc29tZShcbiAgICAgIChzb3VyY2UsIGluZGV4KSA9PlxuICAgICAgICAhQXJyYXkuaXNBcnJheShvbGRTb3VyY2UpIHx8XG4gICAgICAgIHNvdXJjZS50eXBlICE9PSBvbGRTb3VyY2VbaW5kZXhdLnR5cGUgfHxcbiAgICAgICAgc291cmNlLnNyYyAhPT0gb2xkU291cmNlW2luZGV4XS5zcmNcbiAgICApO1xuICB9XG4gIC8vIElmIHRoZSBzb3VyY2VzIGFyZSBib3RoIGEgc3RyaW5nLCBzaW1wbHkgY29tcGFyZVxuICAvLyB0aGUgbmV3IHdpdGggdGhlIG9sZFxuICByZXR1cm4gbmV3U291cmNlICE9PSBvbGRTb3VyY2U7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWRlbyBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYWNjZXNzaWJpbGl0eU1heGltaXplTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgYWNjZXNzaWJpbGl0eU1pbmltaXplTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgYWNjZXNzaWJpbGl0eU11dGVMYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBhY2Nlc3NpYmlsaXR5UGF1c2VMYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBhY2Nlc3NpYmlsaXR5UGxheUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFjY2Vzc2liaWxpdHlVbm11dGVMYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBhc3BlY3RSYXRpbzogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIGNhcHRpb25zOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgIGNvbnRyb2xzOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBsb29wOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBvbkR1cmF0aW9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkVuZGVkOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkZ1bGxzY3JlZW5DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uTG9hZGVkQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblBsYXk6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUGF1c2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUmVhZHk6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uU2VlazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25UaW1lQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblZvbHVtZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcGxheWJhY2tSYXRlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHBsYXlpbmc6IFByb3BUeXBlcy5ib29sLFxuICAgIHBsYXlzSW5saW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBwb3N0ZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgcHJlbG9hZDogUHJvcFR5cGVzLm9uZU9mKFsnYXV0bycsICdtZXRhZGF0YScsICdub25lJ10pLFxuICAgIHNyYzogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgUHJvcFR5cGVzLmFycmF5T2YoXG4gICAgICAgIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICAgICAgdHlwZTogUHJvcFR5cGVzLm9uZU9mKFsndmlkZW8vbTN1OCcsICd2aWRlby9tcDQnLCAndmlkZW8vb2dnJ10pXG4gICAgICAgICAgICAuaXNSZXF1aXJlZCxcbiAgICAgICAgICBzcmM6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgXSkuaXNSZXF1aXJlZCxcbiAgICB2b2x1bWU6IFByb3BUeXBlcy5udW1iZXIsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBwbGF5YmFja1JhdGU6IDEsXG4gICAgcGxheWluZzogZmFsc2UsXG4gICAgcHJlbG9hZDogJ2F1dG8nLFxuICAgIHZvbHVtZTogMSxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBjdXJyZW50VGltZTogMCxcbiAgICBkdXJhdGlvbjogMCxcbiAgICBmdWxsc2NyZWVuOiBmYWxzZSxcbiAgfTtcblxuICAvKipcbiAgICogUmVhY3QgbGlmZWN5Y2xlIGhvb2tzIHBlcnRpbmVudCB0byBWaWRlb1xuICAgKi9cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IHBsYXliYWNrUmF0ZSwgcGxheWluZywgdm9sdW1lIH0gPSB0aGlzLnByb3BzO1xuICAgIC8vIFNldCB1cCBldmVudCBsaXN0ZW5lcnMgdG8gY2F0Y2ggYmFja2Rvb3JzIGluIGZ1bGxzY3JlZW5cbiAgICAvLyBjaGFuZ2VzIHN1Y2ggYXMgdXNpbmcgdGhlIEVTQyBrZXkgdG8gZXhpdFxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBhZGRGdWxsc2NyZWVuRXZlbnRMaXN0ZW5lcih0aGlzLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgIH1cbiAgICAvLyBMb2FkIHRoZSB2aWRlbyB0byBoeWRyYXRlIHRoZSBET00gYWZ0ZXIgYSBzZXJ2ZXIgcmVuZGVyXG4gICAgdGhpcy5sb2FkKCk7XG4gICAgLy8gU2V0IHRoZSBpbml0aWFsIHZvbHVtZVxuICAgIHRoaXMuc2V0Vm9sdW1lKHZvbHVtZSk7XG4gICAgLy8gU2V0IHRoZSBpbml0aWFsIHBsYXliYWNrIHJhdGVcbiAgICB0aGlzLnNldFBsYXliYWNrUmF0ZShwbGF5YmFja1JhdGUpO1xuICAgIC8vIFNpbXVsYXRlIGFuIGF1dG9wbGF5IGVmZmVjdCBpZiB0aGUgY29tcG9uZW50XG4gICAgaWYgKHBsYXlpbmcpIHtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IFByb3BzKSB7XG4gICAgLy8gSWYgdGhlIHZpZGVvIHNvdXJjZSBjaGFuZ2VkLCByZWxvYWQgdGhlIHZpZGVvXG4gICAgaWYgKGlzTmV3U291cmNlKHByZXZQcm9wcy5zcmMsIHRoaXMucHJvcHMuc3JjKSkge1xuICAgICAgdGhpcy5sb2FkKCk7XG4gICAgfVxuICAgIC8vIElmIHRoZSB2b2x1bWUgY2hhbmdlZCwgc2V0IHRoZSBuZXcgdm9sdW1lXG4gICAgaWYgKHByZXZQcm9wcy52b2x1bWUgIT09IHRoaXMucHJvcHMudm9sdW1lKSB7XG4gICAgICB0aGlzLnNldFZvbHVtZSh0aGlzLnByb3BzLnZvbHVtZSk7XG4gICAgfVxuICAgIC8vIElmIHRoZSBwbGF5YmFjayByYXRlIGNoYW5nZWQsIHNldCB0aGUgbmV3IHJhdGVcbiAgICBpZiAocHJldlByb3BzLnBsYXliYWNrUmF0ZSAhPT0gdGhpcy5wcm9wcy5wbGF5YmFja1JhdGUpIHtcbiAgICAgIHRoaXMuc2V0UGxheWJhY2tSYXRlKHRoaXMucHJvcHMucGxheWJhY2tSYXRlKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHBsYXliYWNrIGNoYW5nZWQsIHBsYXkgb3IgcGF1c2UgdGhlIHZpZGVvXG4gICAgaWYgKHByZXZQcm9wcy5wbGF5aW5nICE9PSB0aGlzLnByb3BzLnBsYXlpbmcpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLnBsYXlpbmcpIHtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgcmVtb3ZlRnVsbHNjcmVlbkV2ZW50TGlzdGVuZXIodGhpcy5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBET00gcmVmZXJlbmNlIGhvdXNla2VlcGluZyB0aGF0IGlzIG5lZWRlZCBmb3IgZnVuY3Rpb25hbGl0eVxuICAgKi9cblxuICAvLyBUaGUgcGxheWVyIGVsZW1lbnQgZW5jYXBzdWxhdGVzIHRoZSBhY3R1YWwgdmlkZW8gRE9NXG4gIC8vIGVsZW1lbnQgYXMgd2VsbCBhcyB0aGUgY29udHJvbHMgdG8gYnJpbmcgYm90aCBmdWxsc2NyZWVuXG4gIHNldFBsYXllclJlZiA9IChyZWY6ID9IVE1MRGl2RWxlbWVudCkgPT4ge1xuICAgIHRoaXMucGxheWVyID0gcmVmO1xuICB9O1xuXG4gIC8vIFRoZSBhY3R1YWwgcmVmZXJlbmNlIHRvIHRoZSB2aWRlbyBIVE1MIERPTSBlbGVtZW50XG4gIHNldFZpZGVvUmVmID0gKHJlZjogP0hUTUxWaWRlb0VsZW1lbnQpID0+IHtcbiAgICB0aGlzLnZpZGVvID0gcmVmO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbnMgdGhhdCBkaXJlY3RseSBpbnRlcmFjdCB3aXRoIHRoZSBIVE1MIHZpZGVvIGVsZW1lbnRcbiAgICovXG5cbiAgLy8gU2V0IHRoZSB2aWRlbyB0byB0aGUgZGVzaXJlZCBwbGF5YmFjayByYXRlOiAxIChub3JtYWwpXG4gIHNldFBsYXliYWNrUmF0ZSA9IChwbGF5YmFja1JhdGU6IG51bWJlcikgPT4ge1xuICAgIGlmICh0aGlzLnZpZGVvKSB7XG4gICAgICB0aGlzLnZpZGVvLnBsYXliYWNrUmF0ZSA9IHBsYXliYWNrUmF0ZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU2V0IHRoZSB2aWRlbyB0byB0aGUgZGVzaXJlZCB2b2x1bWU6IDAgKG11dGVkKSAtPiAxIChtYXgpXG4gIHNldFZvbHVtZSA9ICh2b2x1bWU6IG51bWJlcikgPT4ge1xuICAgIGlmICh0aGlzLnZpZGVvKSB7XG4gICAgICB0aGlzLnZpZGVvLnZvbHVtZSA9IHZvbHVtZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2hhbmdlIHRoZSB2aWRlbyBzb3VyY2UgYW5kIHJlLWxvYWQgdGhlIHZpZGVvXG4gIGxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMudmlkZW8pIHtcbiAgICAgIHRoaXMudmlkZW8ubG9hZCgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQYXVzZSB0aGUgdmlkZW9cbiAgcGF1c2UgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMudmlkZW8pIHtcbiAgICAgIHRoaXMudmlkZW8ucGF1c2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGxheSB0aGUgdmlkZW9cbiAgcGxheSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy52aWRlbykge1xuICAgICAgdGhpcy52aWRlby5wbGF5KCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlZWsgdGhlIHZpZGVvIHRvIHRoZSBkZXNpcmVkIHRpbWVcbiAgc2VlayA9ICh0aW1lOiBudW1iZXIpID0+IHtcbiAgICBpZiAodGhpcy52aWRlbykge1xuICAgICAgdGhpcy52aWRlby5jdXJyZW50VGltZSA9IHRpbWU7XG4gICAgfVxuICB9O1xuXG4gIC8vIEVudGVyL2V4aXQgZnVsbHNjcmVlbiB2aWRlbyBwbGF5ZXIgbW9kZVxuICB0b2dnbGVGdWxsc2NyZWVuID0gKCkgPT4ge1xuICAgIGlmIChpc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGxheWVyKSB7XG4gICAgICByZXF1ZXN0RnVsbHNjcmVlbih0aGlzLnBsYXllcik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVycyBmb3IgdmFyaW91cyBtZWRpYSBldmVudHMgb24gdGhlIHZpZGVvXG4gICAqL1xuXG4gIC8vIFNlbnQgd2hlbiBlbm91Z2ggZGF0YSBpcyBhdmFpbGFibGUgdGhhdCB0aGUgbWVkaWEgY2FuIGJlIHBsYXllZFxuICBoYW5kbGVDYW5QbGF5ID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25SZWFkeSB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChvblJlYWR5KSB7XG4gICAgICBvblJlYWR5KHsgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoZSBtZXRhZGF0YSBoYXMgbG9hZGVkIG9yIGNoYW5nZWQsIGluZGljYXRpbmcgYSBjaGFuZ2UgaW5cbiAgLy8gZHVyYXRpb24gb2YgdGhlIG1lZGlhXG4gIGhhbmRsZUR1cmF0aW9uQ2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25EdXJhdGlvbkNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBkdXJhdGlvbiA9ICh0aGlzLnZpZGVvICYmIHRoaXMudmlkZW8uZHVyYXRpb24pIHx8IDA7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGR1cmF0aW9uIH0pO1xuXG4gICAgaWYgKG9uRHVyYXRpb25DaGFuZ2UpIHtcbiAgICAgIG9uRHVyYXRpb25DaGFuZ2UoeyBldmVudCwgZHVyYXRpb24gfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbnQgd2hlbiBwbGF5YmFjayBjb21wbGV0ZXMuXG4gIGhhbmRsZUVuZGVkID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25FbmRlZCB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChvbkVuZGVkKSB7XG4gICAgICBvbkVuZGVkKHsgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbnQgd2hlbiB0aGUgdmlkZW8gaXMgc3dpdGNoZWQgdG8vb3V0LW9mIGZ1bGxzY3JlZW4gbW9kZVxuICBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlID0gKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgIGNvbnN0IHsgb25GdWxsc2NyZWVuQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGZ1bGxzY3JlZW4gPSAhIWlzRnVsbHNjcmVlbigpO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBmdWxsc2NyZWVuIH0pO1xuXG4gICAgaWYgKG9uRnVsbHNjcmVlbkNoYW5nZSkge1xuICAgICAgb25GdWxsc2NyZWVuQ2hhbmdlKHsgZXZlbnQsIGZ1bGxzY3JlZW4gfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbnQgd2hlbiBwbGF5YmFjayBvZiB0aGUgbWVkaWEgc3RhcnRzIGFmdGVyIGhhdmluZyBiZWVuIHBhdXNlZC5cbiAgaGFuZGxlUGxheSA9IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBvblBsYXkgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAob25QbGF5KSB7XG4gICAgICBvblBsYXkoeyBldmVudCB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU2VudCB3aGVuIHBsYXliYWNrIGlzIHBhdXNlZC5cbiAgaGFuZGxlUGF1c2UgPSAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25QYXVzZSB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChvblBhdXNlKSB7XG4gICAgICBvblBhdXNlKHsgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbnQgcGVyaW9kaWNhbGx5IHRvIGluZm9ybSBpbnRlcmVzdGVkIHBhcnRpZXMgb2YgcHJvZ3Jlc3MgZG93bmxvYWRpbmcgdGhlIG1lZGlhXG4gIGhhbmRsZVByb2dyZXNzID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25Mb2FkZWRDaGFuZ2UgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBidWZmZXJlZCB9ID0gdGhpcy52aWRlbyB8fCB7fTtcbiAgICBjb25zdCBsb2FkZWQgPVxuICAgICAgYnVmZmVyZWQgJiYgYnVmZmVyZWQubGVuZ3RoID4gMCA/IGJ1ZmZlcmVkLmVuZChidWZmZXJlZC5sZW5ndGggLSAxKSA6IDA7XG5cbiAgICBpZiAob25Mb2FkZWRDaGFuZ2UpIHtcbiAgICAgIG9uTG9hZGVkQ2hhbmdlKHsgZXZlbnQsIGxvYWRlZCB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU2VudCB3aGVuIGEgc2VlayBvcGVyYXRpb24gY29tcGxldGVzLlxuICBoYW5kbGVTZWVrID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25TZWVrIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKG9uU2Vlaykge1xuICAgICAgb25TZWVrKHsgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoZSB0aW1lIGluZGljYXRlZCBieSB0aGUgZWxlbWVudCdzIGN1cnJlbnRUaW1lIGF0dHJpYnV0ZSBoYXMgY2hhbmdlZFxuICBoYW5kbGVUaW1lVXBkYXRlID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25UaW1lQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gKHRoaXMudmlkZW8gJiYgdGhpcy52aWRlby5jdXJyZW50VGltZSkgfHwgMDtcbiAgICB0aGlzLnNldFN0YXRlKHsgY3VycmVudFRpbWUgfSk7XG5cbiAgICBpZiAob25UaW1lQ2hhbmdlKSB7XG4gICAgICBvblRpbWVDaGFuZ2UoeyBldmVudCwgdGltZTogY3VycmVudFRpbWUgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbnQgd2hlbiB0aGUgYXVkaW8gdm9sdW1lIGNoYW5nZXNcbiAgaGFuZGxlVm9sdW1lQ2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uVm9sdW1lQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IG11dGVkID0gKHRoaXMudmlkZW8gJiYgdGhpcy52aWRlby5tdXRlZCkgfHwgZmFsc2U7XG5cbiAgICBpZiAob25Wb2x1bWVDaGFuZ2UpIHtcbiAgICAgIG9uVm9sdW1lQ2hhbmdlKHsgZXZlbnQsIHZvbHVtZTogbXV0ZWQgPyAxIDogMCB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmlkZW86ID9IVE1MVmlkZW9FbGVtZW50O1xuXG4gIHBsYXllcjogP0hUTUxEaXZFbGVtZW50O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBhc3BlY3RSYXRpbyxcbiAgICAgIGNhcHRpb25zLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBsb29wLFxuICAgICAgcGxheWluZyxcbiAgICAgIHBsYXlzSW5saW5lLFxuICAgICAgcG9zdGVyLFxuICAgICAgcHJlbG9hZCxcbiAgICAgIHNyYyxcbiAgICAgIHZvbHVtZSxcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGN1cnJlbnRUaW1lLCBkdXJhdGlvbiwgZnVsbHNjcmVlbiB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGNvbnN0IHBhZGRpbmdCb3R0b20gPSAoZnVsbHNjcmVlbiAmJiAnMCcpIHx8IGAkeygxIC8gYXNwZWN0UmF0aW8pICogMTAwfSVgO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgcmVmPXt0aGlzLnNldFBsYXllclJlZn1cbiAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMucGxheWVyfVxuICAgICAgICBzdHlsZT17eyBwYWRkaW5nQm90dG9tLCBoZWlnaHQ6IGZ1bGxzY3JlZW4gPyAnMTAwJScgOiAwIH19XG4gICAgICA+XG4gICAgICAgIDx2aWRlb1xuICAgICAgICAgIGF1dG9QbGF5PXtwbGF5aW5nfVxuICAgICAgICAgIGxvb3A9e2xvb3B9XG4gICAgICAgICAgbXV0ZWQ9e3ZvbHVtZSA9PT0gMH1cbiAgICAgICAgICBwbGF5c0lubGluZT17cGxheXNJbmxpbmV9XG4gICAgICAgICAgcG9zdGVyPXtwb3N0ZXJ9XG4gICAgICAgICAgcHJlbG9hZD17cHJlbG9hZH1cbiAgICAgICAgICBzcmM9e3R5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gc3JjIDogdW5kZWZpbmVkfVxuICAgICAgICAgIHJlZj17dGhpcy5zZXRWaWRlb1JlZn1cbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy52aWRlb31cbiAgICAgICAgICBvbkNhblBsYXk9e3RoaXMuaGFuZGxlQ2FuUGxheX1cbiAgICAgICAgICBvbkR1cmF0aW9uQ2hhbmdlPXt0aGlzLmhhbmRsZUR1cmF0aW9uQ2hhbmdlfVxuICAgICAgICAgIG9uRW5kZWQ9e3RoaXMuaGFuZGxlRW5kZWR9XG4gICAgICAgICAgb25TZWVrZWQ9e3RoaXMuaGFuZGxlU2Vla31cbiAgICAgICAgICBvblRpbWVVcGRhdGU9e3RoaXMuaGFuZGxlVGltZVVwZGF0ZX1cbiAgICAgICAgICBvblByb2dyZXNzPXt0aGlzLmhhbmRsZVByb2dyZXNzfVxuICAgICAgICA+XG4gICAgICAgICAge0FycmF5LmlzQXJyYXkoc3JjKSAmJlxuICAgICAgICAgICAgc3JjLm1hcChzb3VyY2UgPT4gKFxuICAgICAgICAgICAgICA8c291cmNlIGtleT17c291cmNlLnNyY30gc3JjPXtzb3VyY2Uuc3JjfSB0eXBlPXtzb3VyY2UudHlwZX0gLz5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDx0cmFjayBraW5kPVwiY2FwdGlvbnNcIiBzcmM9e2NhcHRpb25zfSAvPlxuICAgICAgICA8L3ZpZGVvPlxuICAgICAgICB7Y2hpbGRyZW4gJiYgKFxuICAgICAgICAgIDxCb3ggcG9zaXRpb249XCJhYnNvbHV0ZVwiIHRvcCBsZWZ0IGJvdHRvbSByaWdodCBvdmVyZmxvdz1cImhpZGRlblwiPlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgIDwvQm94PlxuICAgICAgICApfVxuICAgICAgICB7LyogTmVlZCB0byB1c2UgZnVsbCBwYXRoIGZvciB0aGVzZSBwcm9wcyBzbyBGbG93IGNhbiBpbmZlciBjb3JyZWN0IHN1YnR5cGUgKi99XG4gICAgICAgIHt0aGlzLnByb3BzLmNvbnRyb2xzICYmIChcbiAgICAgICAgICA8VmlkZW9Db250cm9sc1xuICAgICAgICAgICAgYWNjZXNzaWJpbGl0eU1heGltaXplTGFiZWw9e3RoaXMucHJvcHMuYWNjZXNzaWJpbGl0eU1heGltaXplTGFiZWx9XG4gICAgICAgICAgICBhY2Nlc3NpYmlsaXR5TWluaW1pemVMYWJlbD17dGhpcy5wcm9wcy5hY2Nlc3NpYmlsaXR5TWluaW1pemVMYWJlbH1cbiAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlNdXRlTGFiZWw9e3RoaXMucHJvcHMuYWNjZXNzaWJpbGl0eU11dGVMYWJlbH1cbiAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlQYXVzZUxhYmVsPXt0aGlzLnByb3BzLmFjY2Vzc2liaWxpdHlQYXVzZUxhYmVsfVxuICAgICAgICAgICAgYWNjZXNzaWJpbGl0eVBsYXlMYWJlbD17dGhpcy5wcm9wcy5hY2Nlc3NpYmlsaXR5UGxheUxhYmVsfVxuICAgICAgICAgICAgYWNjZXNzaWJpbGl0eVVubXV0ZUxhYmVsPXt0aGlzLnByb3BzLmFjY2Vzc2liaWxpdHlVbm11dGVMYWJlbH1cbiAgICAgICAgICAgIGN1cnJlbnRUaW1lPXtjdXJyZW50VGltZX1cbiAgICAgICAgICAgIGR1cmF0aW9uPXtkdXJhdGlvbn1cbiAgICAgICAgICAgIGZ1bGxzY3JlZW49e2Z1bGxzY3JlZW59XG4gICAgICAgICAgICBvblBsYXk9e3RoaXMuaGFuZGxlUGxheX1cbiAgICAgICAgICAgIG9uUGF1c2U9e3RoaXMuaGFuZGxlUGF1c2V9XG4gICAgICAgICAgICBvbkZ1bGxzY3JlZW5DaGFuZ2U9e3RoaXMudG9nZ2xlRnVsbHNjcmVlbn1cbiAgICAgICAgICAgIG9uVm9sdW1lQ2hhbmdlPXt0aGlzLmhhbmRsZVZvbHVtZUNoYW5nZX1cbiAgICAgICAgICAgIHBsYXlpbmc9e3BsYXlpbmd9XG4gICAgICAgICAgICBzZWVrPXt0aGlzLnNlZWt9XG4gICAgICAgICAgICB2b2x1bWU9e3ZvbHVtZX1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImlkZW50aXR5IiwiY2xhc3NOYW1lIiwiU2V0IiwiaW5saW5lU3R5bGUiLCJmcm9tQ2xhc3NOYW1lIiwiY2xhc3NOYW1lcyIsImZyb21JbmxpbmVTdHlsZSIsImNvbmNhdCIsInN0eWxlcyIsInJlZHVjZSIsImNsYXNzTmFtZUEiLCJpbmxpbmVTdHlsZUEiLCJjbGFzc05hbWVCIiwiaW5saW5lU3R5bGVCIiwibWFwQ2xhc3NOYW1lIiwiZm4iLCJBcnJheSIsImZyb20iLCJtYXAiLCJ0b1Byb3BzIiwicHJvcHMiLCJzaXplIiwic29ydCIsImpvaW4iLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwic3R5bGUiLCJ0b2dnbGUiLCJ2YWwiLCJtYXBwaW5nIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwicmFuZ2UiLCJzY2FsZSIsIm4iLCJNYXRoIiwiYWJzIiwicmFuZ2VXaXRob3V0WmVybyIsImJpbmQiLCJzY29wZSIsIm5hbWUiLCJ1bmlvbiIsImZucyIsIm1hcmdpblN0YXJ0Iiwid2hpdGVzcGFjZSIsIm1hcmdpbkVuZCIsIm1hcmdpblRvcCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQm90dG9tIiwibWFyZ2luTGVmdCIsIm1hcmdpbiIsInNtTWFyZ2luVG9wIiwic21NYXJnaW5SaWdodCIsInNtTWFyZ2luQm90dG9tIiwic21NYXJnaW5MZWZ0Iiwic21NYXJnaW4iLCJtZE1hcmdpblRvcCIsIm1kTWFyZ2luUmlnaHQiLCJtZE1hcmdpbkJvdHRvbSIsIm1kTWFyZ2luTGVmdCIsIm1kTWFyZ2luIiwibGdNYXJnaW5Ub3AiLCJsZ01hcmdpblJpZ2h0IiwibGdNYXJnaW5Cb3R0b20iLCJsZ01hcmdpbkxlZnQiLCJsZ01hcmdpbiIsInBhZGRpbmdYIiwicGFkZGluZ1kiLCJwYWRkaW5nIiwic21QYWRkaW5nWCIsInNtUGFkZGluZ1kiLCJzbVBhZGRpbmciLCJtZFBhZGRpbmdYIiwibWRQYWRkaW5nWSIsIm1kUGFkZGluZyIsImxnUGFkZGluZ1giLCJsZ1BhZGRpbmdZIiwibGdQYWRkaW5nIiwicHJlZml4IiwicHJlIiwiZGlzcGxheSIsInZhbHVlIiwiY29sdW1uIiwiZm9ybWF0SW50Qm9pbnQiLCJ4IiwidG9TdHJpbmciLCJwcm9wVG9GbiIsInhzIiwiYyIsInNtIiwibWQiLCJsZyIsIm5vbmUiLCJ4c0Rpc3BsYXlOb25lIiwiZmxleCIsInhzRGlzcGxheUZsZXgiLCJibG9jayIsInhzRGlzcGxheUJsb2NrIiwiaW5saW5lQmxvY2siLCJ4c0Rpc3BsYXlJbmxpbmVCbG9jayIsInZpc3VhbGx5SGlkZGVuIiwieHNEaXNwbGF5VmlzdWFsbHlIaWRkZW4iLCJkaXJlY3Rpb24iLCJyb3ciLCJ4c0RpcmVjdGlvblJvdyIsInhzRGlyZWN0aW9uQ29sdW1uIiwic21EaXNwbGF5Iiwic21EaXNwbGF5Tm9uZSIsInNtRGlzcGxheUZsZXgiLCJzbURpc3BsYXlCbG9jayIsInNtRGlzcGxheUlubGluZUJsb2NrIiwic21EaXNwbGF5VmlzdWFsbHlIaWRkZW4iLCJzbUNvbHVtbiIsInNtRGlyZWN0aW9uIiwic21EaXJlY3Rpb25Sb3ciLCJzbURpcmVjdGlvbkNvbHVtbiIsIm1kRGlzcGxheSIsIm1kRGlzcGxheU5vbmUiLCJtZERpc3BsYXlGbGV4IiwibWREaXNwbGF5QmxvY2siLCJtZERpc3BsYXlJbmxpbmVCbG9jayIsIm1kRGlzcGxheVZpc3VhbGx5SGlkZGVuIiwibWRDb2x1bW4iLCJtZERpcmVjdGlvbiIsIm1kRGlyZWN0aW9uUm93IiwibWREaXJlY3Rpb25Db2x1bW4iLCJsZ0Rpc3BsYXkiLCJsZ0Rpc3BsYXlOb25lIiwibGdEaXNwbGF5RmxleCIsImxnRGlzcGxheUJsb2NrIiwibGdEaXNwbGF5SW5saW5lQmxvY2siLCJsZ0Rpc3BsYXlWaXN1YWxseUhpZGRlbiIsImxnQ29sdW1uIiwibGdEaXJlY3Rpb24iLCJsZ0RpcmVjdGlvblJvdyIsImxnRGlyZWN0aW9uQ29sdW1uIiwiYWxpZ25Db250ZW50Iiwic3RhcnQiLCJsYXlvdXQiLCJjb250ZW50U3RhcnQiLCJlbmQiLCJjb250ZW50RW5kIiwiY2VudGVyIiwiY29udGVudENlbnRlciIsImJldHdlZW4iLCJjb250ZW50QmV0d2VlbiIsImFyb3VuZCIsImNvbnRlbnRBcm91bmQiLCJhbGlnbkl0ZW1zIiwiaXRlbXNTdGFydCIsIml0ZW1zRW5kIiwiaXRlbXNDZW50ZXIiLCJiYXNlbGluZSIsIml0ZW1zQmFzZWxpbmUiLCJhbGlnblNlbGYiLCJzZWxmU3RhcnQiLCJzZWxmRW5kIiwic2VsZkNlbnRlciIsInNlbGZCYXNlbGluZSIsInN0cmV0Y2giLCJzZWxmU3RyZXRjaCIsImJvdHRvbSIsImJvdHRvbTAiLCJjb2xvciIsImJsdWUiLCJjb2xvcnMiLCJibHVlQmciLCJkYXJrR3JheSIsImRhcmtHcmF5QmciLCJwaW5lIiwicGluZUJnIiwiZ3JheSIsImdyYXlCZyIsInJlZCIsInJlZEJnIiwib2xpdmUiLCJvbGl2ZUJnIiwibGlnaHRHcmF5IiwibGlnaHRHcmF5QmciLCJ3aGl0ZSIsIndoaXRlQmciLCJvcmFuZ2UiLCJvcmFuZ2VCZyIsImdyZWVuIiwiZ3JlZW5CZyIsIm5hdnkiLCJuYXZ5QmciLCJtaWRuaWdodCIsIm1pZG5pZ2h0QmciLCJwdXJwbGUiLCJwdXJwbGVCZyIsIm9yY2hpZCIsIm9yY2hpZEJnIiwiZWdncGxhbnQiLCJlZ2dwbGFudEJnIiwibWFyb29uIiwibWFyb29uQmciLCJ3YXRlcm1lbG9uIiwid2F0ZXJtZWxvbkJnIiwibGlnaHRXYXNoIiwibGlnaHRXYXNoQmciLCJkYXJrV2FzaCIsImRhcmtXYXNoQmciLCJ0cmFuc3BhcmVudERhcmtHcmF5IiwidHJhbnNwYXJlbnREYXJrR3JheUJnIiwiZml0IiwiZ3JvdyIsImZsZXhHcm93IiwiZmxleE5vbmUiLCJoZWlnaHQiLCJqdXN0aWZ5Q29udGVudCIsImp1c3RpZnlFbmQiLCJqdXN0aWZ5Q2VudGVyIiwianVzdGlmeUJldHdlZW4iLCJqdXN0aWZ5QXJvdW5kIiwibGVmdCIsImxlZnQwIiwiZGVwcmVjYXRlZE1hcmdpbiIsIm10IiwibWIiLCJtbCIsIm1yIiwid2hpdGVzcGFjZUxlZ2FjeSIsInRvcCIsIm1sQXV0byIsInJpZ2h0IiwibXJBdXRvIiwibWF4SGVpZ2h0IiwibWF4V2lkdGgiLCJtaW5IZWlnaHQiLCJtaW5XaWR0aCIsIm92ZXJmbG93IiwiaGlkZGVuIiwib3ZlcmZsb3dIaWRkZW4iLCJzY3JvbGwiLCJvdmVyZmxvd1Njcm9sbCIsImF1dG8iLCJvdmVyZmxvd0F1dG8iLCJzY3JvbGxYIiwib3ZlcmZsb3dTY3JvbGxYIiwic2Nyb2xsWSIsIm92ZXJmbG93U2Nyb2xsWSIsImRlcHJlY2F0ZWRQYWRkaW5nIiwieSIsInBvc2l0aW9uIiwiYWJzb2x1dGUiLCJyZWxhdGl2ZSIsImZpeGVkIiwicmlnaHQwIiwic2hhcGUiLCJjaXJjbGUiLCJib3JkZXJzIiwicGlsbCIsInJvdW5kZWQiLCJyb3VuZGVkQm90dG9tIiwicm91bmRlZExlZnQiLCJyb3VuZGVkUmlnaHQiLCJyb3VuZGVkVG9wIiwidG9wMCIsIndpZHRoIiwid3JhcCIsImZsZXhXcmFwIiwiZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZSIsIl9fc3R5bGUiLCJjb250YWlucyIsImtleSIsImFyciIsImluZGV4T2YiLCJvbWl0Iiwib2JqIiwiYWNjIiwiayIsIkJveCIsIlJlYWN0IiwicmVmIiwiY2hpbGRyZW4iLCJibGFja2xpc3QiLCJzIiwiYm94IiwicHJvcCIsIlJlYWN0LmNyZWF0ZUVsZW1lbnQiLCJkaXNwbGF5TmFtZSIsIkNvbHVtblByb3BUeXBlIiwiUHJvcFR5cGVzIiwib25lT2YiLCJNYXJnaW5Qcm9wVHlwZSIsIlBhZGRpbmdQcm9wVHlwZSIsInByb3BUeXBlcyIsIm5vZGUiLCJleGFjdCIsIm9iamVjdCIsIm9uZU9mVHlwZSIsImJvb2wiLCJudW1iZXIiLCJzdHJpbmciLCJhZGQiLCJhZGRDaXJjbGUiLCJhZGRQaW4iLCJhbGVydCIsImFsaWduQm90dG9tQ2VudGVyIiwiYWxpZ25Cb3R0b21MZWZ0IiwiYWxpZ25Cb3R0b21SaWdodCIsImFsaWduQm90dG9tIiwiYWxpZ25NaWRkbGUiLCJhbGlnblRvcENlbnRlciIsImFsaWduVG9wTGVmdCIsImFsaWduVG9wUmlnaHQiLCJhbGlnblRvcCIsImFuZ2xlZFBpbiIsImFwcHMiLCJhcnJvd0JhY2siLCJhcnJvd0NpcmNsZURvd24iLCJhcnJvd0NpcmNsZUZvcndhcmQiLCJhcnJvd0NpcmNsZVVwIiwiYXJyb3dEb3duIiwiYXJyb3dGb3J3YXJkIiwiYXJyb3dVcCIsImFycm93VXBSaWdodCIsImJlbGwiLCJjYW1lcmEiLCJjYW1lcmFSb2xsIiwiY2FuY2VsIiwiY2Fub25pY2FsUGluIiwiY29sb3JQaWNrZXIiLCJjaGVjayIsImNoZWNrQ2lyY2xlIiwiY2lyY2xlT3V0bGluZSIsImNsZWFyIiwiY2xvY2siLCJjb2ciLCJjb21wYXNzIiwiY29tcG9zZSIsImNyb3AiLCJkYXNoIiwiZG93bmxvYWQiLCJlZGl0IiwiZWxsaXBzaXMiLCJlbGxpcHNpc0NpcmNsZU91dGxpbmUiLCJlbnZlbG9wZSIsImV5ZSIsImZhY2Vib29rIiwiZmFjZUhhcHB5IiwiZmFjZVNhZCIsImZhY2VTbWlsZXkiLCJmaWxsT3BhcXVlIiwiZmlsbFRyYW5zcGFyZW50IiwiZmlsdGVyIiwiZmxhZyIsImZsYXNobGlnaHQiLCJmbGlwSG9yaXpvbnRhbCIsImZsaXBWZXJ0aWNhbCIsImdpZiIsImdsb2JlIiwiZ2xvYmVDaGVja2VkIiwiZ21haWwiLCJnb29nbGVQbHVzIiwiZ3JhcGhCYXIiLCJoYW5kbGUiLCJoYW5kUG9pbnRpbmciLCJoZWFydCIsImhlYXJ0QnJva2VuIiwiaW1wcmVzc3VtIiwia25vb3AiLCJsaWdodGJ1bGIiLCJsaW5rIiwibG9jYXRpb24iLCJsb2NrIiwibG9nb0xhcmdlIiwibG9nb1NtYWxsIiwibG9nb3V0IiwibWFyZ2luc0xhcmdlIiwibWFyZ2luc01lZGl1bSIsIm1hcmdpbnNTbWFsbCIsIm1heGltaXplIiwibWVnYXBob25lIiwibWVudSIsIm1pbmltaXplIiwibW92ZSIsIm11dGUiLCJvdmVybGF5VGV4dCIsInBhdXNlIiwicGVvcGxlIiwicGVyc29uIiwicGVyc29uQWRkIiwicGluIiwicGluSGlkZSIsInBpbnRlcmVzdCIsInBsYXkiLCJxdWVzdGlvbk1hcmsiLCJyZW1vdmUiLCJyZW9yZGVySW1hZ2VzIiwicmVwb3J0Iiwicm90YXRlIiwic2VhcmNoIiwic2VjdXJpdHkiLCJzaG9wcGluZ0JhZyIsInNtaWxleSIsInNtaWxleU91dGxpbmUiLCJzZW5kIiwic2hhcmUiLCJzb3VuZCIsInNwZWVjaCIsInNwZWVjaEVsbGlwc2lzIiwic3RhciIsInN3aXRjaEFjY291bnQiLCJ0YWciLCJ0ZXJtcyIsInRleHRBbGlnbkxlZnQiLCJ0ZXh0QWxpZ25DZW50ZXIiLCJ0ZXh0QWxpZ25SaWdodCIsInRleHRBbGxDYXBzIiwidGV4dEV4dHJhU21hbGwiLCJ0ZXh0TGFyZ2UiLCJ0ZXh0TGluZUhlaWdodCIsInRleHRNZWRpdW0iLCJ0ZXh0U2VudGVuY2VDYXNlIiwidGV4dFNpemUiLCJ0ZXh0U21hbGwiLCJ0ZXh0U3BhY2luZyIsInRyYXNoQ2FuIiwidHdpdHRlciIsInZpZGVvQ2FtZXJhIiwidmlld1R5cGVEZWZhdWx0Iiwidmlld1R5cGVEZW5zZSIsInZpZXdUeXBlTGlzdCIsIkljb25OYW1lcyIsImljb25zIiwiSWNvbiIsImFjY2Vzc2liaWxpdHlMYWJlbCIsImRhbmdlcm91c2x5U2V0U3ZnUGF0aCIsImljb24iLCJpbmxpbmUiLCJjcyIsImNsYXNzbmFtZXMiLCJpY29uQmxvY2siLCJwYXRoIiwiX19wYXRoIiwidW5kZWZpbmVkIiwiYXJpYUhpZGRlbiIsImlzUmVxdWlyZWQiLCJzaG91bGRTY2FsZUltYWdlIiwiSW1hZ2UiLCJoYW5kbGVMb2FkIiwib25Mb2FkIiwiaGFuZGxlRXJyb3IiLCJvbkVycm9yIiwibG9hZEltYWdlIiwicHJldlByb3BzIiwic3JjIiwid2luZG93IiwiaW1hZ2UiLCJvbmxvYWQiLCJvbmVycm9yIiwiYWx0IiwibmF0dXJhbEhlaWdodCIsIm5hdHVyYWxXaWR0aCIsInNpemVzIiwic3JjU2V0IiwiaXNTY2FsZWRJbWFnZSIsImNoaWxkQ29udGVudCIsImJhY2tncm91bmRDb2xvciIsImJhY2tncm91bmRJbWFnZSIsInBhZGRpbmdCb3R0b20iLCJpbWciLCJmdW5jIiwiZGVmYXVsdFByb3BzIiwiTWFzayIsIndpbGxDaGFuZ2VUcmFuc2Zvcm0iLCJ3YXNoIiwiY3giLCJTcXVhcmUiLCJEZWZhdWx0QXZhdGFyIiwiZmlyc3RJbml0aWFsIiwidG9VcHBlckNhc2UiLCJ0eXBvZ3JhcGh5IiwiYW50aWFsaWFzZWQiLCJzYW5zU2VyaWYiLCJsZWFkaW5nU21hbGwiLCJmb250V2VpZ2h0Qm9sZCIsIkF2YXRhciIsInN0YXRlIiwiaXNJbWFnZUxvYWRlZCIsImhhbmRsZUltYWdlRXJyb3IiLCJzZXRTdGF0ZSIsIm91dGxpbmUiLCJ2ZXJpZmllZCIsImJveFNoYWRvdyIsIkJhZGdlIiwidGV4dCIsIlNJWkVfU0NBTEUiLCJ4bCIsIlRleHQiLCJhbGlnbiIsImJvbGQiLCJpdGFsaWMiLCJzbVNpemUiLCJtZFNpemUiLCJsZ1NpemUiLCJsZWFkaW5nIiwidHJ1bmNhdGUiLCJfX2Rhbmdlcm91c2x5SW5jcmVhc2VMaW5lSGVpZ2h0Iiwic21TY2FsZSIsIm1kU2NhbGUiLCJsZ1NjYWxlIiwibGVhZGluZ1Nob3J0IiwibGVhZGluZ1RhbGwiLCJhbGlnbkNlbnRlciIsImFsaWduSnVzdGlmeSIsImFsaWduTGVmdCIsImFsaWduUmlnaHQiLCJicmVha1dvcmQiLCJmb250U3R5bGVJdGFsaWMiLCJmb250U3R5bGVOb3JtYWwiLCJmb250V2VpZ2h0Tm9ybWFsIiwiVGFnIiwidGl0bGUiLCJCdXR0b24iLCJhY2Nlc3NpYmlsaXR5RXhwYW5kZWQiLCJhY2Nlc3NpYmlsaXR5SGFzcG9wdXAiLCJkaXNhYmxlZCIsIm9uQ2xpY2siLCJ0eXBlIiwidGV4dENvbG9yIiwidHJhbnNwYXJlbnQiLCJjbGFzc2VzIiwiYnV0dG9uIiwic29saWQiLCJlbmFibGVkIiwiYm9yZGVyU3R5bGVzIiwicmFkaXVzTGFyZ2UiLCJyYWRpdXNTbWFsbCIsImV2ZW50IiwiQ2FyZCIsImhvdmVyZWQiLCJoYW5kbGVNb3VzZUVudGVyIiwib25Nb3VzZUVudGVyIiwiaGFuZGxlTW91c2VMZWF2ZSIsIm9uTW91c2VMZWF2ZSIsImFjdGl2ZSIsImNhcmQiLCJob3ZlciIsIkNoZWNrYm94IiwiZm9jdXNlZCIsImhhbmRsZUNoYW5nZSIsImNoZWNrZWQiLCJ0YXJnZXQiLCJvbkNoYW5nZSIsImhhbmRsZUNsaWNrIiwiY3VycmVudFRhcmdldCIsImhhbmRsZUJsdXIiLCJoYW5kbGVGb2N1cyIsImluZGV0ZXJtaW5hdGUiLCJzZXRJbmRldGVybWluYXRlIiwicHJldmlvdXNQcm9wcyIsImlucHV0IiwiaGFzRXJyb3IiLCJpZCIsImJvcmRlclN0eWxlIiwiYm9yZGVyIiwiYm9yZGVyRGFyayIsImJvcmRlckVycm9yIiwiaW5wdXRFbmFibGVkIiwiaW5wdXRTbSIsImlucHV0TWQiLCJlbCIsImNoZWNrRW5hYmxlZCIsImNoZWNrRm9jdXNlZCIsImNoZWNrTWQiLCJjaGVja1NtIiwiQ29sbGVjdGlvbiIsIkl0ZW0iLCJ2aWV3cG9ydFRvcCIsInZpZXdwb3J0TGVmdCIsIm1heCIsIml0ZW0iLCJ2aWV3cG9ydFdpZHRoIiwidmlld3BvcnRIZWlnaHQiLCJpdGVtcyIsImlkeCIsInB1c2giLCJsYXlvdXRTdHlsZXMiLCJhbnkiLCJhcnJheU9mIiwiVVAiLCJET1dOIiwiTUlEIiwiY29sdW1uTGF5b3V0IiwibnVtT2ZDb2x1bW5zIiwicGFkZGluZ0FsbCIsImd1dHRlciIsInBvc2l0aW9ucyIsIm1pbmRleCIsIm1pbkluZGV4IiwiaSIsImNvbHVtbnNGb3JDb2xsYWdlV2l0aENvdmVyIiwiZ2V0Q29sbGFnZUxheW91dCIsImNvdmVyIiwibnVtQ29scyIsImNvbHVtbnMiLCJoIiwidyIsImxheW91dEtleSIsImdyaWRDb2xzIiwibGF5b3V0SWR4IiwiY29sSGVpZ2h0cyIsImZpbGwiLCJjb2xDb3VudHMiLCJjb2wiLCJjb2xJZHgiLCJpdGVtSGVpZ2h0IiwiY292ZXJJbWFnZVdpZHRoIiwiY2VpbCIsInVuc2hpZnQiLCJDb2xsYWdlIiwicmVuZGVySW1hZ2UiLCJpbmRleCIsIkNvbHVtbiIsImRlcHJlY2F0ZWRDb2x1bW4iLCJzcGFuIiwic21TcGFuIiwibWRTcGFuIiwibGdTcGFuIiwiQ29udGFpbmVyIiwiRGl2aWRlciIsImRpdmlkZXIiLCJDYXJldCIsIlNQQUNFU19JTkRFWF9NQVAiLCJESVJfSU5ERVhfTUFQIiwidXAiLCJkb3duIiwiTUFSR0lOIiwiQ0FSRVRfSEVJR0hUIiwiQ0FSRVRfT0ZGU0VUX0ZST01fU0lERSIsIkJPUkRFUl9SQURJVVMiLCJnZXRNYWluRGlyIiwiZmx5b3V0U2l6ZSIsImlkZWFsRGlyZWN0aW9uIiwidHJpZ2dlclJlY3QiLCJ3aW5kb3dTaXplIiwic3BhY2VzIiwibWFpbkRpciIsImdldFN1YkRpciIsIm9mZnNldCIsInRyaWdnZXJNaWQiLCJ3aW5kb3dTcGFjZUF2YWlsYWJsZSIsImFib3ZlT3JMZWZ0IiwiYmVsb3dPclJpZ2h0Iiwic3ViRGlyIiwiY2FsY0VkZ2VTaGlmdHMiLCJmbHlvdXRWZXJ0aWNhbFNoaWZ0IiwiZmx5b3V0SG9yaXpvbnRhbFNoaWZ0IiwiY2FyZXRWZXJ0aWNhbFNoaWZ0IiwiY2FyZXRIb3Jpem9udGFsU2hpZnQiLCJpc0Nsb3NlVmVydGljYWxseSIsImlzQ2xvc2VIb3Jpem9udGFsbHkiLCJmbHlvdXQiLCJjYXJldCIsImFkanVzdE9mZnNldHMiLCJiYXNlIiwiZWRnZVNoaWZ0IiwiZmx5b3V0TGVmdCIsImZseW91dFRvcCIsImNhcmV0VG9wIiwiY2FyZXRSaWdodCIsImNhcmV0Qm90dG9tIiwiY2FyZXRMZWZ0IiwiZmx5b3V0T2Zmc2V0IiwiY2FyZXRPZmZzZXQiLCJiYXNlT2Zmc2V0cyIsInJlbGF0aXZlT2Zmc2V0IiwiSEFMRl9DQVJFVCIsIkNvbnRlbnRzIiwic2V0Rmx5b3V0UG9zaXRpb24iLCJwb3NpdGlvblJlbGF0aXZlVG9BbmNob3IiLCJwYWdlWE9mZnNldCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwic2Nyb2xsTGVmdCIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwiaW5uZXJIZWlnaHQiLCJpbm5lcldpZHRoIiwiY3VycmVudCIsImNsaWVudEhlaWdodCIsImNsaWVudFdpZHRoIiwiZWRnZVNoaWZ0cyIsInNldFRpbWVvdXQiLCJzaG91bGRGb2N1cyIsImZvY3VzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uUmVzaXplIiwib25LZXlEb3duIiwibmV4dFByb3BzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImJnQ29sb3IiLCJ2aXNpYmlsaXR5IiwiYmFja2dyb3VuZCIsInN0cm9rZSIsImJvcmRlckNvbG9yIiwiY29udGFpbmVyIiwiY29udGVudHMiLCJtYXhEaW1lbnNpb25zIiwibWluRGltZW5zaW9ucyIsImlubmVyQ29udGVudHMiLCJPdXRzaWRlRXZlbnRCZWhhdmlvciIsImhhbmRsZUNsaWNrRXZlbnQiLCJmaW5kRE9NTm9kZSIsIk5vZGUiLCJjYXB0dXJlIiwiU0laRV9XSURUSF9NQVAiLCJFU0NBUEVfS0VZX0NPREUiLCJDb250cm9sbGVyIiwidHJpZ2dlckJvdW5kaW5nUmVjdCIsImhhbmRsZUtleURvd24iLCJvbkRpc21pc3MiLCJrZXlDb2RlIiwiaGFuZGxlUGFnZUNsaWNrIiwiYW5jaG9yIiwiaGFuZGxlUmVzaXplIiwidXBkYXRlVHJpZ2dlclJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwiRmx5b3V0IiwiemlwIiwiYSIsImIiLCJCT1JERVJfV0lEVEgiLCJBVkFUQVJfU0laRVMiLCJhdmF0YXJMYXlvdXQiLCJ0ZXh0TGF5b3V0IiwiZGVnVG9SYWQiLCJkZWciLCJQSSIsInF1YXJ0ZXJQYWRkaW5nIiwic2luIiwiaW5pdGlhbCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdUb3AiLCJHcm91cEF2YXRhciIsImNvbGxhYm9yYXRvcnMiLCJhdmF0YXJXaWR0aCIsImF2YXRhckhlaWdodCIsIndpbGxDaGFuZ2UiLCJjb2xsYWJvcmF0b3IiLCJkZWZhdWx0SGVhZGluZ0xldmVscyIsIkhlYWRpbmciLCJhY2Nlc3NpYmlsaXR5TGV2ZWwiLCJoZWFkaW5nTGV2ZWwiLCJTSVpFX05BTUVfVE9fUElYRUwiLCJkZWZhdWx0SWNvbkJ1dHRvbkljb25Db2xvcnMiLCJQb2ciLCJpY29uQ29sb3IiLCJpY29uU2l6ZSIsInBvZyIsIkljb25CdXR0b24iLCJoYW5kbGVNb3VzZURvd24iLCJoYW5kbGVNb3VzZVVwIiwiTGFiZWwiLCJodG1sRm9yIiwibGFiZWwiLCJMYXllciIsIm1vdW50ZWQiLCJjcmVhdGVFbGVtZW50IiwiY29uc29sZSIsIndhcm4iLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsImNyZWF0ZVBvcnRhbCIsImFzcGVjdFJhdGlvIiwiTGV0dGVyYm94IiwiY29udGVudEFzcGVjdFJhdGlvIiwidmlld3BvcnRBc3BlY3RSYXRpbyIsImNvbnRlbnRIZWlnaHQiLCJjb250ZW50V2lkdGgiLCJUQUJfS0VZX0NPREUiLCJMaW5rIiwiZW5hYmxlRm9jdXNTdHlsZXMiLCJocmVmIiwiaGFuZGxlS2V5VXAiLCJyZWwiLCJsaW5rVGFyZ2V0IiwiYWNjZXNzaWJsZUZvY3VzU3R5bGUiLCJkZWJvdW5jZSIsInRocmVzaGhvbGQiLCJkZWZlclRpbWVyIiwiZGVib3VuY2VkIiwiYXJncyIsImNsZWFyVGltZW91dCIsIkZldGNoSXRlbXMiLCJjb250YWluZXJIZWlnaHQiLCJpc0F0RW5kIiwiaXNGZXRjaGluZyIsImZldGNoTW9yZSIsInNjcm9sbEhlaWdodCIsInNjcm9sbEJ1ZmZlciIsImdldFNjcm9sbENvbnRhaW5lciIsInNjcm9sbENvbnRhaW5lciIsIlNjcm9sbENvbnRhaW5lciIsImdldFNjcm9sbENvbnRhaW5lclJlZiIsImhhbmRsZVNjcm9sbCIsIm9uU2Nyb2xsIiwidXBkYXRlU2Nyb2xsQ29udGFpbmVyIiwibmV4dFNjcm9sbENvbnRhaW5lciIsIm9ubHkiLCJ0aHJvdHRsZSIsImxhc3QiLCJ0aHJvdHRsZWQiLCJub3ciLCJEYXRlIiwiTWVhc3VyZW1lbnRTdG9yZSIsIldlYWtNYXAiLCJnZXQiLCJoYXMiLCJzZXQiLCJnZXRFbGVtZW50SGVpZ2h0IiwiZWxlbWVudCIsImdldFdpbmRvd1Njcm9sbFBvcyIsImdldFJlbGF0aXZlU2Nyb2xsVG9wIiwiZ2V0U2Nyb2xsSGVpZ2h0IiwiZ2V0U2Nyb2xsUG9zIiwiRGVmYXVsdExheW91dFN5bWJvbCIsIlN5bWJvbCIsIlVuaWZvcm1Sb3dMYXlvdXRTeW1ib2wiLCJvZmZzY3JlZW4iLCJJbmZpbml0eSIsImNhY2hlIiwiY29sdW1uV2lkdGgiLCJtaW5Db2xzIiwiY29sdW1uV2lkdGhBbmRHdXR0ZXIiLCJjb2x1bW5Db3VudCIsImZsb29yIiwiaGVpZ2h0cyIsImNlbnRlck9mZnNldCIsImhlaWdodEFuZEd1dHRlciIsInNsaWNlIiwic3VtIiwiaWRlYWxDb2x1bW5XaWR0aCIsImNvbGd1ZXNzIiwiTWFzb25yeUxheW91dCIsIlVuaWZvcm1Sb3dMYXlvdXQiLCJSRVNJWkVfREVCT1VOQ0UiLCJWSVJUVUFMX0JVRkZFUl9GQUNUT1IiLCJsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbiIsIk1hc29ucnkiLCJncmlkV3JhcHBlciIsInVwZGF0ZVNjcm9sbFBvc2l0aW9uIiwibWVhc3VyZUNvbnRhaW5lckFzeW5jIiwibWVhc3VyZUNvbnRhaW5lciIsInNldEdyaWRXcmFwcGVyUmVmIiwic2V0U2Nyb2xsQ29udGFpbmVyUmVmIiwibG9hZEl0ZW1zIiwicmVuZGVyTWFzb25yeUNvbXBvbmVudCIsIml0ZW1EYXRhIiwiQ29tcG9uZW50IiwiY29tcCIsInZpcnR1YWxpemUiLCJ2aXJ0dWFsQm91bmRzVG9wIiwidmlydHVhbEJvdW5kc0JvdHRvbSIsImlzVmlzaWJsZSIsInZpcnR1YWxCdWZmZXIiLCJvZmZzZXRTY3JvbGxQb3MiLCJjb250YWluZXJPZmZzZXQiLCJ2aWV3cG9ydEJvdHRvbSIsIml0ZW1Db21wb25lbnQiLCJNYXNvbnJ5X19JdGVtIiwiTWFzb25yeV9fSXRlbV9fTW91bnRlZCIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsImhhc1BlbmRpbmdNZWFzdXJlbWVudHMiLCJzb21lIiwibWVhc3VyZW1lbnRTdG9yZSIsInByZXZTdGF0ZSIsInJlc2V0IiwiaW5zZXJ0QW5pbWF0aW9uRnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInNjcm9sbENvbnRhaW5lclJlZiIsIkhUTUxFbGVtZW50IiwicmVsYXRpdmVTY3JvbGxUb3AiLCJmb3JjZVVwZGF0ZSIsImZsZXhpYmxlIiwiZ3V0dGVyV2lkdGgiLCJmdWxsV2lkdGhMYXlvdXQiLCJMZWdhY3lVbmlmb3JtUm93TGF5b3V0IiwidW5pZm9ybVJvd0xheW91dCIsImRlZmF1bHRMYXlvdXQiLCJncmlkQm9keSIsIml0ZW1zVG9SZW5kZXIiLCJpdGVtc1RvTWVhc3VyZSIsIm1lYXN1cmluZ1Bvc2l0aW9ucyIsInBvcyIsImRhdGEiLCJtZWFzdXJlbWVudEluZGV4IiwiaW5zdGFuY2VPZiIsIkxlZ2FjeU1hc29ucnlMYXlvdXQiLCJzeW1ib2wiLCJsYXlvdXRDbGFzcyIsInN0YXRlc0ZvclJlbmRlcmluZyIsInJlbmRlclBvc2l0aW9ucyIsIk1hc29ucnlCZXRhIiwiaGFuZGxlVmlydHVhbGl6YXRpb25XaW5kb3dVcGRhdGUiLCJvblZpcnR1YWxpemF0aW9uV2luZG93VXBkYXRlIiwidmlld3BvcnQiLCJjb250ZW50IiwiaGFuZGxlT25BdXRvTWVhc3VyaW5nVXBkYXRlIiwib25BdXRvTWVhc3VyaW5nVXBkYXRlIiwic3RhdGVXaXRoV2lkdGgiLCJyZW5kZXJpbmdTdGF0ZXMiLCJuZXdTdGF0ZSIsIk1hc29ucnlJbmZpbml0ZUJldGEiLCJzZXRSZWYiLCJncmlkUmVmIiwicmVmbG93IiwiTm9TY3JvbGxCZWhhdmlvciIsInByZXZPdmVyZmxvdyIsInF1ZXJ5Rm9jdXNhYmxlQWxsIiwic2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9jdXNFbGVtZW50IiwiVHJhcEZvY3VzQmVoYXZpb3IiLCJzZXRFbFJlZiIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwiZm9jdXNGaXJzdENoaWxkIiwicHJldmlvdXNseUZvY3VzZWRFbCIsImFjdGl2ZUVsZW1lbnQiLCJCYWNrZHJvcCIsIkhlYWRlciIsImhlYWRpbmciLCJyb2xlIiwicGFkZGluZ0xlZnQiLCJNb2RhbCIsImhhbmRsZU91dHNpZGVDbGljayIsImhhbmRsZUNsb3NlQ2xpY2siLCJhY2Nlc3NpYmlsaXR5Q2xvc2VMYWJlbCIsImFjY2Vzc2liaWxpdHlNb2RhbExhYmVsIiwiZm9vdGVyIiwid3JhcHBlciIsIlB1bHNhciIsInBhdXNlZCIsImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IiwiaW5uZXJDaXJjbGUiLCJvdXRlckNpcmNsZSIsIlJhZGlvQnV0dG9uIiwiUmFkaW9CdXR0b25Jc0ZvY3VzZWQiLCJSYWRpb0J1dHRvblNtIiwiUmFkaW9CdXR0b25NZCIsIlJhZGlvQnV0dG9uV2hpdGVCZyIsIlJhZGlvQnV0dG9uTGlnaHRHcmF5QmciLCJJbnB1dCIsIklucHV0RW5hYmxlZCIsIklucHV0U20iLCJJbnB1dE1kIiwiQ2hlY2siLCJDaGVja1NtIiwiQ2hlY2tNZCIsIkNoZWNrRW5hYmxlZCIsIkNoZWNrRGlzYWJsZWQiLCJTY3JvbGxGZXRjaCIsInVwZGF0ZVBvc2l0aW9uIiwiZ2V0U2Nyb2xsU3RhdGUiLCJyZW5kZXJIZWlnaHQiLCJTZWFyY2hGaWVsZCIsInN5bnRoZXRpY0V2ZW50IiwiaGFuZGxlQ2xlYXIiLCJvbkZvY3VzIiwib25CbHVyIiwiYXV0b0NvbXBsZXRlIiwicGxhY2Vob2xkZXIiLCJzaG93Q2xlYXIiLCJwb2ludGVyRXZlbnRzIiwiU2VnbWVudGVkQ29udHJvbCIsInJlc3BvbnNpdmUiLCJzZWxlY3RlZEl0ZW1JbmRleCIsImJ1dHRvbldpZHRoIiwiaXNTZWxlY3RlZCIsIml0ZW1Jc05vdFNlbGVjdGVkIiwiaXRlbUlzU2VsZWN0ZWQiLCJlIiwiYWN0aXZlSW5kZXgiLCJGb3JtRXJyb3JNZXNzYWdlIiwiU2VsZWN0TGlzdCIsInNldFNlbGVjdExpc3RSZWYiLCJzZWxlY3QiLCJoYW5kbGVPbkNoYW5nZSIsIkhUTUxTZWxlY3RFbGVtZW50IiwiZXJyb3JNZXNzYWdlIiwib3B0aW9ucyIsImVycm9yZWQiLCJub3JtYWwiLCJib3JkZXJSYWRpdXMiLCJvcHRpb24iLCJTSVpFIiwiU3Bpbm5lciIsInNob3ciLCJTdGlja3kiLCJkYW5nZXJvdXNseVNldFpJbmRleCIsIl9fekluZGV4IiwiekluZGV4Iiwic3RpY2t5IiwiU3dpdGNoIiwic3dpdGNoZWQiLCJzd2l0Y2hTdHlsZXMiLCJzd2l0Y2giLCJzd2l0Y2hHcmF5Iiwic3dpdGNoTGlnaHRHcmF5Iiwic3dpdGNoRGFya0dyYXkiLCJzd2l0Y2hXaGl0ZSIsInNsaWRlclN0eWxlcyIsInNsaWRlciIsInNsaWRlclJpZ2h0Iiwic2xpZGVyTGVmdCIsInNsaWRlckRhcmsiLCJzbGlkZXJMaWdodCIsImlucHV0U3R5bGVzIiwiY2hlY2tib3giLCJjaGVja2JveEVuYWJsZWQiLCJUYWJzIiwiZm9jdXNlZFRhYkluZGV4IiwiaG92ZXJlZFRhYkluZGV4IiwiaGFuZGxlVGFiQ2xpY2siLCJhY3RpdmVUYWJJbmRleCIsImhhbmRsZVRhYkZvY3VzIiwiaGFuZGxlVGFiQmx1ciIsImhhbmRsZVRhYk1vdXNlRW50ZXIiLCJoYW5kbGVUYWJNb3VzZUxlYXZlIiwidGFicyIsImlzQWN0aXZlIiwiaXNIb3ZlcmVkIiwiaXNGb2N1c2VkIiwidGFiIiwidGFiSXNOb3RBY3RpdmUiLCJ0YWJJc0FjdGl2ZSIsIlRleHRBcmVhIiwic2V0VGV4dEFyZWFSZWYiLCJ0ZXh0YXJlYSIsInJvd3MiLCJ0ZXh0QXJlYSIsIlRleHRGaWVsZCIsInNldFRleHRGaWVsZFJlZiIsInRleHRmaWVsZCIsInRleHRGaWVsZCIsInBhdHRlcm4iLCJUb2FzdCIsInRodW1ibmFpbCIsImZvbnRXZWlnaHQiLCJub29wIiwiVG9vbHRpcCIsImNoaWxkUmVmIiwiU1BBQ0VfQ0hBUl9DT0RFIiwiRU5URVJfQ0hBUl9DT0RFIiwiVG91Y2hhYmxlIiwiaGFuZGxlS2V5UHJlc3MiLCJvblRvdWNoIiwiY2hhckNvZGUiLCJmdWxsV2lkdGgiLCJmdWxsSGVpZ2h0IiwibW91c2VDdXJzb3IiLCJ0b3VjaGFibGUiLCJWaWRlb1BsYXloZWFkIiwic2Vla2luZyIsInNldFBsYXloZWFkUmVmIiwicGxheWhlYWQiLCJzZWVrIiwiY2xpZW50WCIsImR1cmF0aW9uIiwicGVyY2VudCIsIm1pbiIsIm5ld1RpbWUiLCJzdG9wQ2xpY2siLCJoYW5kbGVNb3VzZU1vdmUiLCJjdXJyZW50VGltZSIsImZ1bGxzY3JlZW5FbmFibGVkIiwid2Via2l0RnVsbHNjcmVlbkVuYWJsZWQiLCJtb3pGdWxsU2NyZWVuRW5hYmxlZCIsIm1zRnVsbHNjcmVlbkVuYWJsZWQiLCJ0aW1lVG9TdHJpbmciLCJ0aW1lIiwibWludXRlcyIsInNlY29uZHMiLCJtaW51dGVzU3RyIiwic2Vjb25kc1N0ciIsIlZpZGVvQ29udHJvbHMiLCJoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlIiwib25GdWxsc2NyZWVuQ2hhbmdlIiwiaGFuZGxlUGxheWluZ0NoYW5nZSIsInBsYXlpbmciLCJvblBhdXNlIiwib25QbGF5IiwiaGFuZGxlVm9sdW1lQ2hhbmdlIiwib25Wb2x1bWVDaGFuZ2UiLCJhY2Nlc3NpYmlsaXR5TWF4aW1pemVMYWJlbCIsImFjY2Vzc2liaWxpdHlNaW5pbWl6ZUxhYmVsIiwiYWNjZXNzaWJpbGl0eU11dGVMYWJlbCIsImFjY2Vzc2liaWxpdHlQYXVzZUxhYmVsIiwiYWNjZXNzaWJpbGl0eVBsYXlMYWJlbCIsImFjY2Vzc2liaWxpdHlVbm11dGVMYWJlbCIsImZ1bGxzY3JlZW4iLCJ2b2x1bWUiLCJtdXRlZCIsInNob3dGdWxsc2NyZWVuQnV0dG9uIiwiY29udHJvbHMiLCJyZXF1ZXN0RnVsbHNjcmVlbiIsIndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuIiwibW96UmVxdWVzdEZ1bGxTY3JlZW4iLCJtc1JlcXVlc3RGdWxsc2NyZWVuIiwiZXhpdEZ1bGxzY3JlZW4iLCJ3ZWJraXRFeGl0RnVsbHNjcmVlbiIsIm1vekNhbmNlbEZ1bGxTY3JlZW4iLCJtc0V4aXRGdWxsc2NyZWVuIiwiaXNGdWxsc2NyZWVuIiwiZnVsbHNjcmVlbkVsZW1lbnQiLCJ3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCIsIm1vekZ1bGxTY3JlZW5FbGVtZW50IiwibXNGdWxsc2NyZWVuRWxlbWVudCIsImFkZEZ1bGxzY3JlZW5FdmVudExpc3RlbmVyIiwibGlzdGVuZXIiLCJyZW1vdmVGdWxsc2NyZWVuRXZlbnRMaXN0ZW5lciIsImlzTmV3U291cmNlIiwib2xkU291cmNlIiwibmV3U291cmNlIiwiaXNBcnJheSIsInNvdXJjZSIsIlZpZGVvIiwic2V0UGxheWVyUmVmIiwicGxheWVyIiwic2V0VmlkZW9SZWYiLCJ2aWRlbyIsInNldFBsYXliYWNrUmF0ZSIsInBsYXliYWNrUmF0ZSIsInNldFZvbHVtZSIsImxvYWQiLCJ0b2dnbGVGdWxsc2NyZWVuIiwiaGFuZGxlQ2FuUGxheSIsIm9uUmVhZHkiLCJoYW5kbGVEdXJhdGlvbkNoYW5nZSIsIm9uRHVyYXRpb25DaGFuZ2UiLCJoYW5kbGVFbmRlZCIsIm9uRW5kZWQiLCJoYW5kbGVQbGF5IiwiaGFuZGxlUGF1c2UiLCJoYW5kbGVQcm9ncmVzcyIsIm9uTG9hZGVkQ2hhbmdlIiwiYnVmZmVyZWQiLCJsb2FkZWQiLCJoYW5kbGVTZWVrIiwib25TZWVrIiwiaGFuZGxlVGltZVVwZGF0ZSIsIm9uVGltZUNoYW5nZSIsImNhcHRpb25zIiwibG9vcCIsInBsYXlzSW5saW5lIiwicG9zdGVyIiwicHJlbG9hZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQSxFQUFPLElBQU1BLFdBQVcsU0FBWEEsUUFBVztFQUFBLFNBQWM7RUFDcENDLGVBQVcsSUFBSUMsR0FBSixFQUR5QjtFQUVwQ0MsaUJBQWE7RUFGdUIsR0FBZDtFQUFBLENBQWpCOztFQVBQO0VBQ0E7OztBQVdBLEVBQU8sSUFBTUMsZ0JBQWdCLFNBQWhCQSxhQUFnQjtFQUFBLG9DQUFJQyxVQUFKO0VBQUlBLGNBQUo7RUFBQTs7RUFBQSxTQUEwQztFQUNyRUosZUFBVyxJQUFJQyxHQUFKLENBQVFHLFVBQVIsQ0FEMEQ7RUFFckVGLGlCQUFhO0VBRndELEdBQTFDO0VBQUEsQ0FBdEI7O0FBS1AsRUFBTyxJQUFNRyxrQkFBa0IsU0FBbEJBLGVBQWtCLENBQUNILFdBQUQ7RUFBQSxTQUFzQztFQUNuRUYsZUFBVyxJQUFJQyxHQUFKLEVBRHdEO0VBRW5FQztFQUZtRSxHQUF0QztFQUFBLENBQXhCOztBQUtQLEVBQU8sSUFBTUksU0FBUyxTQUFUQSxNQUFTLENBQUNDLE1BQUQ7RUFBQSxTQUNwQkEsT0FBT0MsTUFBUCxDQUNFO0VBQUEsUUFDZUMsVUFEZixRQUNJVCxTQURKO0VBQUEsUUFDd0NV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
